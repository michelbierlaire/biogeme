<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>biogeme.models &mdash; Biogeme 3.2.9 documentation</title>
      <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="../../" id="documentation_options" src="../../_static/documentation_options.js"></script>
        <script src="../../_static/jquery.js"></script>
        <script src="../../_static/underscore.js"></script>
        <script src="../../_static/_sphinx_javascript_frameworks_compat.js"></script>
        <script src="../../_static/doctools.js"></script>
    <script src="../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="../../index.html" class="icon icon-home"> Biogeme
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../algorithms.html">Algorithms</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../assisted.html">Assisted specification</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../biogeme.html">Biogeme</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../database.html">Database</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../distributions.html">Distributions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../draws.html">Draws</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../exceptions.html">Exceptions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../expressions.html">Expressions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../filenames.html">Filenames</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../idmanager.html">ID manager</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../loglikelihood.html">Log likelihood</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../messaging.html">Messaging</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../models.html">Models</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../optimization.html">Optimization</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../results.html">Results</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../segmentation.html">Segmentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../singleton.html">Singleton</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../tools.html">Tools</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../version.html">Version</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../vns.html">Variable Neighborhood Search</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">Biogeme</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../index.html" class="icon icon-home"></a> &raquo;</li>
          <li><a href="../index.html">Module code</a> &raquo;</li>
      <li>biogeme.models</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for biogeme.models</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot; Implements various models.</span>

<span class="sd">:author: Michel Bierlaire</span>
<span class="sd">:date: Fri Mar 29 17:13:14 2019</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="c1"># Too constraining</span>
<span class="c1"># pylint: disable=invalid-name</span>
<span class="c1"># pylint: disable=too-many-lines</span>

<span class="kn">import</span> <span class="nn">biogeme.exceptions</span> <span class="k">as</span> <span class="nn">excep</span>
<span class="kn">import</span> <span class="nn">biogeme.messaging</span> <span class="k">as</span> <span class="nn">msg</span>

<span class="kn">import</span> <span class="nn">biogeme.expressions</span> <span class="k">as</span> <span class="nn">expr</span>

<span class="n">logger</span> <span class="o">=</span> <span class="n">msg</span><span class="o">.</span><span class="n">bioMessage</span><span class="p">()</span>


<div class="viewcode-block" id="loglogit"><a class="viewcode-back" href="../../models.html#biogeme.models.loglogit">[docs]</a><span class="k">def</span> <span class="nf">loglogit</span><span class="p">(</span><span class="n">V</span><span class="p">,</span> <span class="n">av</span><span class="p">,</span> <span class="n">i</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;The logarithm of the logit model</span>

<span class="sd">    The model is defined as</span>

<span class="sd">    .. math:: \\frac{a_i e^{V_i}}{\\sum_{i=1}^J a_j e^{V_j}}</span>

<span class="sd">    :param V: dict of objects representing the utility functions of</span>
<span class="sd">              each alternative, indexed by numerical ids.</span>

<span class="sd">    :type V: dict(int:biogeme.expressions.expr.Expression)</span>

<span class="sd">    :param av: dict of objects representing the availability of each</span>
<span class="sd">               alternative (:math:`a_i` in the above formula), indexed</span>
<span class="sd">               by numerical ids. Must be consistent with V, or</span>
<span class="sd">               None. In this case, all alternatives are supposed to be</span>
<span class="sd">               always available.</span>

<span class="sd">    :type av: dict(int:biogeme.expressions.expr.Expression)</span>

<span class="sd">    :param i: id of the alternative for which the probability must be</span>
<span class="sd">              calculated.</span>
<span class="sd">    :type i: int</span>

<span class="sd">    :return: choice probability of alternative number i.</span>
<span class="sd">    :rtype: biogeme.expressions.expr.Expression</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="n">av</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">expr</span><span class="o">.</span><span class="n">_bioLogLogitFullChoiceSet</span><span class="p">(</span><span class="n">V</span><span class="p">,</span> <span class="n">av</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">choice</span><span class="o">=</span><span class="n">i</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">expr</span><span class="o">.</span><span class="n">_bioLogLogit</span><span class="p">(</span><span class="n">V</span><span class="p">,</span> <span class="n">av</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span></div>


<div class="viewcode-block" id="logit"><a class="viewcode-back" href="../../models.html#biogeme.models.logit">[docs]</a><span class="k">def</span> <span class="nf">logit</span><span class="p">(</span><span class="n">V</span><span class="p">,</span> <span class="n">av</span><span class="p">,</span> <span class="n">i</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;The logit model</span>

<span class="sd">    The model is defined as</span>

<span class="sd">    .. math:: \\frac{a_i e^{V_i}}{\\sum_{i=1}^J a_j e^{V_j}}</span>

<span class="sd">    :param V: dict of objects representing the utility functions of</span>
<span class="sd">              each alternative, indexed by numerical ids.</span>

<span class="sd">    :type V: dict(int:biogeme.expressions.expr.Expression)</span>

<span class="sd">    :param av: dict of objects representing the availability of each</span>
<span class="sd">               alternative (:math:`a_i` in the above formula), indexed</span>
<span class="sd">               by numerical ids. Must be consistent with V, or</span>
<span class="sd">               None. In this case, all alternatives are supposed to be</span>
<span class="sd">               always available.</span>

<span class="sd">    :type av: dict(int:biogeme.expressions.expr.Expression)</span>

<span class="sd">    :param i: id of the alternative for which the probability must be</span>
<span class="sd">              calculated.</span>
<span class="sd">    :type i: int</span>

<span class="sd">    :return: choice probability of alternative number i.</span>
<span class="sd">    :rtype: biogeme.expressions.expr.Expression</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">av</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">expr</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">expr</span><span class="o">.</span><span class="n">_bioLogLogitFullChoiceSet</span><span class="p">(</span><span class="n">V</span><span class="p">,</span> <span class="n">av</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">choice</span><span class="o">=</span><span class="n">i</span><span class="p">))</span>

    <span class="k">return</span> <span class="n">expr</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">expr</span><span class="o">.</span><span class="n">_bioLogLogit</span><span class="p">(</span><span class="n">V</span><span class="p">,</span> <span class="n">av</span><span class="p">,</span> <span class="n">i</span><span class="p">))</span></div>


<div class="viewcode-block" id="boxcox"><a class="viewcode-back" href="../../models.html#biogeme.models.boxcox">[docs]</a><span class="k">def</span> <span class="nf">boxcox</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">ell</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Box-Cox transform</span>

<span class="sd">    .. math:: B(x, \\ell) = \\frac{x^{\\ell}-1}{\\ell}.</span>

<span class="sd">    It has the property that</span>

<span class="sd">    .. math:: \\lim_{\\ell \\to 0} B(x,\\ell)=\\log(x).</span>

<span class="sd">    To avoid numerical difficulties, if :math:`\\ell &lt; 10^{-5}`,</span>
<span class="sd">    the McLaurin approximation is used:</span>

<span class="sd">    .. math:: \\log(x) + \\ell \\log(x)^2 + \\frac{1}{6} \\ell^2 \\log(x)^3</span>
<span class="sd">              + \\frac{1}{24} \\ell^3 \\log(x)^4.</span>

<span class="sd">    :param x: a variable to transform.</span>
<span class="sd">    :type x: biogeme.expressions.expr.Expression</span>
<span class="sd">    :param ell: parameter of the transformation.</span>
<span class="sd">    :type ell: biogeme.expressions.expr.Expression</span>

<span class="sd">    :return: the Box-Cox transform</span>
<span class="sd">    :rtype: biogeme.expressions.expr.Expression</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">regular</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span><span class="o">**</span><span class="n">ell</span> <span class="o">-</span> <span class="mf">1.0</span><span class="p">)</span> <span class="o">/</span> <span class="n">ell</span>
    <span class="n">mclaurin</span> <span class="o">=</span> <span class="p">(</span>
        <span class="n">expr</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="o">+</span> <span class="n">ell</span> <span class="o">*</span> <span class="n">expr</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span>
        <span class="o">+</span> <span class="n">ell</span><span class="o">**</span><span class="mi">2</span> <span class="o">*</span> <span class="n">expr</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">**</span> <span class="mi">3</span> <span class="o">/</span> <span class="mf">6.0</span>
        <span class="o">+</span> <span class="n">ell</span><span class="o">**</span><span class="mi">3</span> <span class="o">*</span> <span class="n">expr</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">**</span> <span class="mi">4</span> <span class="o">/</span> <span class="mf">24.0</span>
    <span class="p">)</span>
    <span class="n">smooth</span> <span class="o">=</span> <span class="n">expr</span><span class="o">.</span><span class="n">Elem</span><span class="p">({</span><span class="mi">0</span><span class="p">:</span> <span class="n">regular</span><span class="p">,</span> <span class="mi">1</span><span class="p">:</span> <span class="n">mclaurin</span><span class="p">},</span> <span class="n">ell</span> <span class="o">&lt;</span> <span class="n">expr</span><span class="o">.</span><span class="n">Numeric</span><span class="p">(</span><span class="mf">1.0e-5</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">expr</span><span class="o">.</span><span class="n">Elem</span><span class="p">({</span><span class="mi">0</span><span class="p">:</span> <span class="n">smooth</span><span class="p">,</span> <span class="mi">1</span><span class="p">:</span> <span class="n">expr</span><span class="o">.</span><span class="n">Numeric</span><span class="p">(</span><span class="mi">0</span><span class="p">)},</span> <span class="n">x</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span></div>


<div class="viewcode-block" id="piecewise"><a class="viewcode-back" href="../../models.html#biogeme.models.piecewise">[docs]</a><span class="k">def</span> <span class="nf">piecewise</span><span class="p">(</span><span class="n">variable</span><span class="p">,</span> <span class="n">thresholds</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Obsolete function. Present for compatibility only&quot;&quot;&quot;</span>
    <span class="n">errorMsg</span> <span class="o">=</span> <span class="p">(</span>
        <span class="s1">&#39;The function &quot;piecewise&quot; is obsolete and has been replaced &#39;</span>
        <span class="s1">&#39;by &quot;piecewiseVariables&quot;. Its use has changed. Please refer &#39;</span>
        <span class="s1">&#39;to the documentation.&#39;</span>
    <span class="p">)</span>
    <span class="k">raise</span> <span class="n">excep</span><span class="o">.</span><span class="n">biogemeError</span><span class="p">(</span><span class="n">errorMsg</span><span class="p">)</span></div>


<div class="viewcode-block" id="piecewiseVariables"><a class="viewcode-back" href="../../models.html#biogeme.models.piecewiseVariables">[docs]</a><span class="k">def</span> <span class="nf">piecewiseVariables</span><span class="p">(</span><span class="n">variable</span><span class="p">,</span> <span class="n">thresholds</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Generate the variables to include in a piecewise linear specification.</span>

<span class="sd">    If there are K thresholds, K-1 variables are generated. The first</span>
<span class="sd">    and last thresholds can be defined as None, corresponding to</span>
<span class="sd">    :math:`-\\infty` and :math:`+\\infty`,respectively. If :math:`t` is</span>
<span class="sd">    the variable of interest, for each interval :math:`[a:a+b[`, we</span>
<span class="sd">    define a variable defined as:</span>

<span class="sd">    .. math:: x_{Ti} =\\left\\{  \\begin{array}{ll} 0 &amp; \\text{if }</span>
<span class="sd">              t &lt; a \\\\ t-a &amp; \\text{if } a \\leq t &lt; a+b \\\\ b  &amp;</span>
<span class="sd">              \\text{otherwise}  \\end{array}\\right. \\;\\;\\;x_{Ti} =</span>
<span class="sd">              \\max(0, \\min(t-a, b))</span>

<span class="sd">    :param variable: variable for which we need the piecewise linear</span>
<span class="sd">       transform. The expression itself or the name of the variable</span>
<span class="sd">       can be given.</span>
<span class="sd">    :type variable: biogeme.expressions.expr.Expression or str</span>

<span class="sd">    :param thresholds: list of thresholds</span>
<span class="sd">    :type thresholds: list(float)</span>

<span class="sd">    :return: list of variables to for the piecewise linear specification.</span>
<span class="sd">    :rtype: list(biogeme.expressions.expr.Expression)</span>

<span class="sd">    :raise biogemeError: if the thresholds are not defined properly,</span>
<span class="sd">        as only the first and the last thresholds can be set</span>
<span class="sd">        to None.</span>

<span class="sd">    .. seealso:: :meth:`piecewiseFormula`</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">eye</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">thresholds</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">all</span><span class="p">(</span><span class="n">t</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">thresholds</span><span class="p">):</span>
        <span class="n">errorMsg</span> <span class="o">=</span> <span class="p">(</span>
            <span class="s1">&#39;All thresholds for the piecewise linear specification &#39;</span>
            <span class="s1">&#39;are set to None.&#39;</span>
        <span class="p">)</span>
        <span class="k">raise</span> <span class="n">excep</span><span class="o">.</span><span class="n">biogemeError</span><span class="p">(</span><span class="n">errorMsg</span><span class="p">)</span>
    <span class="k">if</span> <span class="kc">None</span> <span class="ow">in</span> <span class="n">thresholds</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
        <span class="n">errorMsg</span> <span class="o">=</span> <span class="p">(</span>
            <span class="s1">&#39;For piecewise linear specification, only the first and &#39;</span>
            <span class="s1">&#39;the last thresholds can be None&#39;</span>
        <span class="p">)</span>
        <span class="k">raise</span> <span class="n">excep</span><span class="o">.</span><span class="n">biogemeError</span><span class="p">(</span><span class="n">errorMsg</span><span class="p">)</span>

    <span class="c1"># If the name of the variable is given, we transform it into an expression.</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">variable</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
        <span class="n">variable</span> <span class="o">=</span> <span class="n">expr</span><span class="o">.</span><span class="n">Variable</span><span class="p">(</span><span class="n">variable</span><span class="p">)</span>

    <span class="c1"># First variable</span>
    <span class="k">if</span> <span class="n">thresholds</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">results</span> <span class="o">=</span> <span class="p">[</span><span class="n">expr</span><span class="o">.</span><span class="n">bioMin</span><span class="p">(</span><span class="n">variable</span><span class="p">,</span> <span class="n">thresholds</span><span class="p">[</span><span class="mi">1</span><span class="p">])]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">b</span> <span class="o">=</span> <span class="n">thresholds</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">thresholds</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">results</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">expr</span><span class="o">.</span><span class="n">bioMax</span><span class="p">(</span>
                <span class="n">expr</span><span class="o">.</span><span class="n">Numeric</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="n">expr</span><span class="o">.</span><span class="n">bioMin</span><span class="p">(</span><span class="n">variable</span> <span class="o">-</span> <span class="n">thresholds</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">b</span><span class="p">)</span>
            <span class="p">)</span>
        <span class="p">]</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">eye</span> <span class="o">-</span> <span class="mi">2</span><span class="p">):</span>
        <span class="n">b</span> <span class="o">=</span> <span class="n">thresholds</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">thresholds</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="n">results</span> <span class="o">+=</span> <span class="p">[</span>
            <span class="n">expr</span><span class="o">.</span><span class="n">bioMax</span><span class="p">(</span>
                <span class="n">expr</span><span class="o">.</span><span class="n">Numeric</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="n">expr</span><span class="o">.</span><span class="n">bioMin</span><span class="p">(</span><span class="n">variable</span> <span class="o">-</span> <span class="n">thresholds</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">b</span><span class="p">)</span>
            <span class="p">)</span>
        <span class="p">]</span>

    <span class="c1"># Last variable</span>
    <span class="k">if</span> <span class="n">thresholds</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">results</span> <span class="o">+=</span> <span class="p">[</span><span class="n">expr</span><span class="o">.</span><span class="n">bioMax</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">variable</span> <span class="o">-</span> <span class="n">thresholds</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">])]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">b</span> <span class="o">=</span> <span class="n">thresholds</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">thresholds</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span>
        <span class="n">results</span> <span class="o">+=</span> <span class="p">[</span>
            <span class="n">expr</span><span class="o">.</span><span class="n">bioMax</span><span class="p">(</span>
                <span class="n">expr</span><span class="o">.</span><span class="n">Numeric</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="n">expr</span><span class="o">.</span><span class="n">bioMin</span><span class="p">(</span><span class="n">variable</span> <span class="o">-</span> <span class="n">thresholds</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">],</span> <span class="n">b</span><span class="p">)</span>
            <span class="p">)</span>
        <span class="p">]</span>
    <span class="k">return</span> <span class="n">results</span></div>


<div class="viewcode-block" id="piecewiseFormula"><a class="viewcode-back" href="../../models.html#biogeme.models.piecewiseFormula">[docs]</a><span class="k">def</span> <span class="nf">piecewiseFormula</span><span class="p">(</span><span class="n">variable</span><span class="p">,</span> <span class="n">thresholds</span><span class="p">,</span> <span class="n">betas</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Generate the formula for a piecewise linear specification.</span>

<span class="sd">    If there are K thresholds, K-1 variables are generated. The first</span>
<span class="sd">    and last thresholds can be defined as None, corresponding to</span>
<span class="sd">    :math:`-\\infty` and :math:`+\\infty`, respectively. If :math:`t` is</span>
<span class="sd">    the variable of interest, for each interval :math:`[a:a+b[`, we</span>
<span class="sd">    define a variable defined as:</span>

<span class="sd">    .. math:: x_{Ti} =\\left\\{  \\begin{array}{ll} 0 &amp; \\text{if }</span>
<span class="sd">              t &lt; a \\\\ t-a &amp; \\text{if } a \\leq t &lt; a+b \\\\ b  &amp;</span>
<span class="sd">              \\text{otherwise}  \\end{array}\\right. \\;\\;\\;x_{Ti} =</span>
<span class="sd">              \\max(0, \\min(t-a, b))</span>

<span class="sd">    New variables and new parameters are automatically created.</span>

<span class="sd">    :param variable: name of the variable for which we need the</span>
<span class="sd">        piecewise linear transform.</span>
<span class="sd">    :type variable: string</span>

<span class="sd">    :param thresholds: list of thresholds</span>
<span class="sd">    :type thresholds: list(float)</span>

<span class="sd">    :param betas: list of beta parameters to be used in the</span>
<span class="sd">        specification.  The number of entries should be the number of</span>
<span class="sd">        thresholds, minus one. If None, for each interval, the</span>
<span class="sd">        parameter Beta(&#39;beta_VAR_interval&#39;,0, None, None, 0) is used,</span>
<span class="sd">        where var is the name of the variable. Default: none.</span>
<span class="sd">    :type betas:</span>
<span class="sd">        list(biogeme.expresssions.Beta)</span>

<span class="sd">    :return: expression of  the piecewise linear specification.</span>
<span class="sd">    :rtype: biogeme.expressions.expr.Expression</span>

<span class="sd">    :raise biogemeError: if the thresholds are not defined properly,</span>
<span class="sd">        which means that only the first and the last threshold can be set</span>
<span class="sd">        to None.</span>

<span class="sd">    :raise biogemeError: if the length of list ``initialexpr.Betas`` is</span>
<span class="sd">        not equal to the length of ``thresholds`` minus one.</span>

<span class="sd">    .. seealso:: :meth:`piecewiseVariables`</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">variable</span><span class="p">,</span> <span class="n">expr</span><span class="o">.</span><span class="n">Variable</span><span class="p">):</span>
        <span class="n">the_variable</span> <span class="o">=</span> <span class="n">variable</span>
        <span class="n">the_name</span> <span class="o">=</span> <span class="n">variable</span><span class="o">.</span><span class="n">name</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">variable</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
        <span class="n">the_name</span> <span class="o">=</span> <span class="n">variable</span>
        <span class="n">the_valiable</span> <span class="o">=</span> <span class="n">expr</span><span class="o">.</span><span class="n">Variable</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">variable</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">errorMsg</span> <span class="o">=</span> <span class="p">(</span>
            <span class="s1">&#39;The first argument of piecewiseFormula must be the &#39;</span>
            <span class="s1">&#39;name of a variable, or the variable itself..&#39;</span>
        <span class="p">)</span>
        <span class="k">raise</span> <span class="n">excep</span><span class="o">.</span><span class="n">biogemeError</span><span class="p">(</span><span class="n">errorMsg</span><span class="p">)</span>

    <span class="n">eye</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">thresholds</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">all</span><span class="p">(</span><span class="n">t</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">thresholds</span><span class="p">):</span>
        <span class="n">errorMsg</span> <span class="o">=</span> <span class="p">(</span>
            <span class="s1">&#39;All thresholds for the piecewise linear specification &#39;</span>
            <span class="s1">&#39;are set to None.&#39;</span>
        <span class="p">)</span>
        <span class="k">raise</span> <span class="n">excep</span><span class="o">.</span><span class="n">biogemeError</span><span class="p">(</span><span class="n">errorMsg</span><span class="p">)</span>
    <span class="k">if</span> <span class="kc">None</span> <span class="ow">in</span> <span class="n">thresholds</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
        <span class="n">errorMsg</span> <span class="o">=</span> <span class="p">(</span>
            <span class="s1">&#39;For piecewise linear specification, only the first and &#39;</span>
            <span class="s1">&#39;the last thresholds can be None&#39;</span>
        <span class="p">)</span>
        <span class="k">raise</span> <span class="n">excep</span><span class="o">.</span><span class="n">biogemeError</span><span class="p">(</span><span class="n">errorMsg</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">betas</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">betas</span><span class="p">)</span> <span class="o">!=</span> <span class="n">eye</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">errorMsg</span> <span class="o">=</span> <span class="p">(</span>
                <span class="sa">f</span><span class="s1">&#39;As there are </span><span class="si">{</span><span class="n">eye</span><span class="si">}</span><span class="s1"> thresholds, a total of </span><span class="si">{</span><span class="n">eye</span><span class="o">-</span><span class="mi">1</span><span class="si">}</span><span class="s1"> &#39;</span>
                <span class="sa">f</span><span class="s1">&#39;Beta parameters are needed, and not </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">betas</span><span class="p">)</span><span class="si">}</span><span class="s1">.&#39;</span>
            <span class="p">)</span>
            <span class="k">raise</span> <span class="n">excep</span><span class="o">.</span><span class="n">biogemeError</span><span class="p">(</span><span class="n">errorMsg</span><span class="p">)</span>

    <span class="n">theVars</span> <span class="o">=</span> <span class="n">piecewiseVariables</span><span class="p">(</span><span class="n">expr</span><span class="o">.</span><span class="n">Variable</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">variable</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">),</span> <span class="n">thresholds</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">betas</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">betas</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">a_threshold</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">thresholds</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]):</span>
            <span class="n">next_threshold</span> <span class="o">=</span> <span class="n">thresholds</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>
            <span class="n">a_name</span> <span class="o">=</span> <span class="s1">&#39;minus_inf&#39;</span> <span class="k">if</span> <span class="n">a_threshold</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">a_threshold</span><span class="si">}</span><span class="s1">&#39;</span>
            <span class="n">next_name</span> <span class="o">=</span> <span class="p">(</span>
                <span class="s1">&#39;inf&#39;</span> <span class="k">if</span> <span class="n">next_threshold</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">next_threshold</span><span class="si">}</span><span class="s1">&#39;</span>
            <span class="p">)</span>
            <span class="n">betas</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                <span class="n">expr</span><span class="o">.</span><span class="n">Beta</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s1">&#39;beta_</span><span class="si">{</span><span class="n">variable</span><span class="si">}</span><span class="s1">_</span><span class="si">{</span><span class="n">a_name</span><span class="si">}</span><span class="s1">_</span><span class="si">{</span><span class="n">next_name</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="mi">0</span>
                <span class="p">)</span>
            <span class="p">)</span>

    <span class="n">terms</span> <span class="o">=</span> <span class="p">[</span><span class="n">beta</span> <span class="o">*</span> <span class="n">theVars</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">beta</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">betas</span><span class="p">)]</span>

    <span class="k">return</span> <span class="n">expr</span><span class="o">.</span><span class="n">bioMultSum</span><span class="p">(</span><span class="n">terms</span><span class="p">)</span></div>


<div class="viewcode-block" id="piecewiseFunction"><a class="viewcode-back" href="../../models.html#biogeme.models.piecewiseFunction">[docs]</a><span class="k">def</span> <span class="nf">piecewiseFunction</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">thresholds</span><span class="p">,</span> <span class="n">betas</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Plot a piecewise linear specification.</span>

<span class="sd">    If there are K thresholds, K-1 variables are generated. The first</span>
<span class="sd">    and last thresholds can be defined as None, corresponding to</span>
<span class="sd">    :math:`-\\infty` and :math:`+\\infty`, respectively. If :math:`t` is</span>
<span class="sd">    the variable of interest, for each interval :math:`[a:a+b[`, we</span>
<span class="sd">    define a variable defined as:</span>

<span class="sd">    .. math:: x_{Ti} =\\left\\{  \\begin{array}{ll} 0 &amp; \\text{if }</span>
<span class="sd">              t &lt; a \\\\ t-a &amp; \\text{if } a \\leq t &lt; a+b \\\\ b  &amp;</span>
<span class="sd">              \\text{otherwise}  \\end{array}\\right. \\;\\;\\;x_{Ti} =</span>
<span class="sd">              \\max(0, \\min(t-a, b))</span>

<span class="sd">    :param x: value at which the piecewise specification must be avaluated</span>
<span class="sd">    :type x: float</span>

<span class="sd">    :param thresholds: list of thresholds</span>
<span class="sd">    :type thresholds: list(float)</span>

<span class="sd">    :param betas: list of the beta parameters.  The number of entries</span>
<span class="sd">                         should be the number of thresholds, plus</span>
<span class="sd">                         one.</span>
<span class="sd">    :type betas: list(float)</span>

<span class="sd">    :return: value of the numpy function</span>
<span class="sd">    :rtype: float</span>

<span class="sd">    :raise biogemeError: if the thresholds are not defined properly,</span>
<span class="sd">        which means that only the first and the last threshold can be set</span>
<span class="sd">        to None.</span>


<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">eye</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">thresholds</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">all</span><span class="p">(</span><span class="n">t</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">thresholds</span><span class="p">):</span>
        <span class="n">errorMsg</span> <span class="o">=</span> <span class="p">(</span>
            <span class="s1">&#39;All thresholds for the piecewise linear specification &#39;</span>
            <span class="s1">&#39;are set to None.&#39;</span>
        <span class="p">)</span>
        <span class="k">raise</span> <span class="n">excep</span><span class="o">.</span><span class="n">biogemeError</span><span class="p">(</span><span class="n">errorMsg</span><span class="p">)</span>
    <span class="k">if</span> <span class="kc">None</span> <span class="ow">in</span> <span class="n">thresholds</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
        <span class="n">errorMsg</span> <span class="o">=</span> <span class="p">(</span>
            <span class="s1">&#39;For piecewise linear specification, only the first and &#39;</span>
            <span class="s1">&#39;the last thresholds can be None&#39;</span>
        <span class="p">)</span>
        <span class="k">raise</span> <span class="n">excep</span><span class="o">.</span><span class="n">biogemeError</span><span class="p">(</span><span class="n">errorMsg</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">betas</span><span class="p">)</span> <span class="o">!=</span> <span class="n">eye</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">errorMsg</span> <span class="o">=</span> <span class="p">(</span>
            <span class="sa">f</span><span class="s1">&#39;As there are </span><span class="si">{</span><span class="n">eye</span><span class="si">}</span><span class="s1"> thresholds, a total of </span><span class="si">{</span><span class="n">eye</span><span class="o">-</span><span class="mi">1</span><span class="si">}</span><span class="s1"> values &#39;</span>
            <span class="sa">f</span><span class="s1">&#39;are needed to initialize the parameters. But &#39;</span>
            <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">betas</span><span class="p">)</span><span class="si">}</span><span class="s1"> are provided&#39;</span>
        <span class="p">)</span>
        <span class="k">raise</span> <span class="n">excep</span><span class="o">.</span><span class="n">biogemeError</span><span class="p">(</span><span class="n">errorMsg</span><span class="p">)</span>

    <span class="c1"># If the first threshold is not -infinity, we need to check if</span>
    <span class="c1"># x is beyond it.</span>
    <span class="k">if</span> <span class="n">thresholds</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="n">thresholds</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
            <span class="k">return</span> <span class="mi">0</span>
    <span class="n">rest</span> <span class="o">=</span> <span class="n">x</span>
    <span class="n">total</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">betas</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">thresholds</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">total</span> <span class="o">+=</span> <span class="n">v</span> <span class="o">*</span> <span class="n">rest</span>
            <span class="k">return</span> <span class="n">total</span>
        <span class="k">if</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="n">thresholds</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]:</span>
            <span class="n">total</span> <span class="o">+=</span> <span class="n">v</span> <span class="o">*</span> <span class="n">rest</span>
            <span class="k">return</span> <span class="n">total</span>
        <span class="n">total</span> <span class="o">+=</span> <span class="n">v</span> <span class="o">*</span> <span class="p">(</span>
            <span class="n">thresholds</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="p">(</span><span class="mi">0</span> <span class="k">if</span> <span class="n">thresholds</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">thresholds</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
        <span class="p">)</span>
        <span class="n">rest</span> <span class="o">=</span> <span class="n">x</span> <span class="o">-</span> <span class="n">thresholds</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">total</span></div>


<div class="viewcode-block" id="logmev"><a class="viewcode-back" href="../../models.html#biogeme.models.logmev">[docs]</a><span class="k">def</span> <span class="nf">logmev</span><span class="p">(</span><span class="n">V</span><span class="p">,</span> <span class="n">logGi</span><span class="p">,</span> <span class="n">av</span><span class="p">,</span> <span class="n">choice</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Log of the choice probability for a MEV model.</span>

<span class="sd">    :param V: dict of objects representing the utility functions of</span>
<span class="sd">              each alternative, indexed by numerical ids.</span>

<span class="sd">    :type V: dict(int:biogeme.expressions.expr.Expression)</span>

<span class="sd">    :param logGi: a dictionary mapping each alternative id with the function</span>

<span class="sd">        .. math:: \\ln \\frac{\\partial G}{\\partial y_i}</span>
<span class="sd">            (e^{V_1},\\ldots,e^{V_J})</span>

<span class="sd">        where :math:`G` is the MEV generating function. If an alternative</span>
<span class="sd">        :math:`i` is not available, then :math:`G_i = 0`.</span>

<span class="sd">    :type logGi: dict(int:biogeme.expressions.expr.Expression)</span>

<span class="sd">    :param av: dict of objects representing the availability of each</span>
<span class="sd">               alternative (:math:`a_i` in the above formula), indexed</span>
<span class="sd">               by numerical ids. Must be consistent with V, or</span>
<span class="sd">               None. In this case, all alternatives are supposed to be</span>
<span class="sd">               always available.</span>

<span class="sd">    :type av: dict(int:biogeme.expressions.expr.Expression)</span>

<span class="sd">    :param choice: id of the alternative for which the probability must be</span>
<span class="sd">              calculated.</span>
<span class="sd">    :type choice: biogeme.expressions.expr.Expression</span>

<span class="sd">    :return: log of the choice probability of the MEV model, given by</span>
<span class="sd">    :rtype: biogeme.expressions.expr.Expression</span>

<span class="sd">    .. math:: V_i + \\ln G_i(e^{V_1},\\ldots,e^{V_J}) -</span>
<span class="sd">              \\ln\\left(\\sum_j e^{V_j + \\ln G_j(e^{V_1},</span>
<span class="sd">              \\ldots,e^{V_J})}\\right)</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">H</span> <span class="o">=</span> <span class="p">{</span><span class="n">i</span><span class="p">:</span> <span class="n">v</span> <span class="o">+</span> <span class="n">logGi</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">V</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>
    <span class="k">if</span> <span class="n">av</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">logP</span> <span class="o">=</span> <span class="n">expr</span><span class="o">.</span><span class="n">_bioLogLogitFullChoiceSet</span><span class="p">(</span><span class="n">H</span><span class="p">,</span> <span class="n">av</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">choice</span><span class="o">=</span><span class="n">choice</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">logP</span> <span class="o">=</span> <span class="n">expr</span><span class="o">.</span><span class="n">_bioLogLogit</span><span class="p">(</span><span class="n">H</span><span class="p">,</span> <span class="n">av</span><span class="p">,</span> <span class="n">choice</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">logP</span></div>


<div class="viewcode-block" id="mev"><a class="viewcode-back" href="../../models.html#biogeme.models.mev">[docs]</a><span class="k">def</span> <span class="nf">mev</span><span class="p">(</span><span class="n">V</span><span class="p">,</span> <span class="n">logGi</span><span class="p">,</span> <span class="n">av</span><span class="p">,</span> <span class="n">choice</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Choice probability for a MEV model.</span>

<span class="sd">    :param V: dict of objects representing the utility functions of</span>
<span class="sd">              each alternative, indexed by numerical ids.</span>

<span class="sd">    :type V: dict(int:biogeme.expressions.expr.Expression)</span>


<span class="sd">    :param logGi: a dictionary mapping each alternative id with the function</span>

<span class="sd">        .. math:: \\ln \\frac{\\partial G}{\\partial y_i}</span>
<span class="sd">              (e^{V_1}, \\ldots, e^{V_J})</span>

<span class="sd">        where :math:`G` is the MEV generating function. If an alternative</span>
<span class="sd">        :math:`i` is not available, then :math:`G_i = 0`.</span>

<span class="sd">    :type logGi: dict(int:biogeme.expressions.expr.Expression)</span>

<span class="sd">    :param av: dict of objects representing the availability of each</span>
<span class="sd">               alternative (:math:`a_i` in the above formula), indexed</span>
<span class="sd">               by numerical ids. Must be consistent with V, or</span>
<span class="sd">               None. In this case, all alternatives are supposed to be</span>
<span class="sd">               always available.</span>

<span class="sd">    :type av: dict(int:biogeme.expressions.expr.Expression)</span>

<span class="sd">    :param choice: id of the alternative for which the probability must be</span>
<span class="sd">              calculated.</span>
<span class="sd">    :type choice: biogeme.expressions.expr.Expression</span>

<span class="sd">    :return: Choice probability of the MEV model, given by</span>

<span class="sd">    .. math:: \\frac{e^{V_i + \\ln G_i(e^{V_1},</span>
<span class="sd">              \\ldots,e^{V_J})}}{\\sum_j e^{V_j +</span>
<span class="sd">              \\ln G_j(e^{V_1},\\ldots,e^{V_J})}}</span>

<span class="sd">    :rtype: biogeme.expressions.expr.Expression</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">expr</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">logmev</span><span class="p">(</span><span class="n">V</span><span class="p">,</span> <span class="n">logGi</span><span class="p">,</span> <span class="n">av</span><span class="p">,</span> <span class="n">choice</span><span class="p">))</span></div>


<div class="viewcode-block" id="logmev_endogenousSampling"><a class="viewcode-back" href="../../models.html#biogeme.models.logmev_endogenousSampling">[docs]</a><span class="k">def</span> <span class="nf">logmev_endogenousSampling</span><span class="p">(</span><span class="n">V</span><span class="p">,</span> <span class="n">logGi</span><span class="p">,</span> <span class="n">av</span><span class="p">,</span> <span class="n">correction</span><span class="p">,</span> <span class="n">choice</span><span class="p">):</span>

    <span class="sd">&quot;&quot;&quot;Log of choice probability for a MEV model, including the</span>
<span class="sd">    correction for endogenous sampling as proposed by `Bierlaire, Bolduc</span>
<span class="sd">    and McFadden (2008)`_.</span>

<span class="sd">    .. _`Bierlaire, Bolduc and McFadden (2008)`:</span>
<span class="sd">       http://dx.doi.org/10.1016/j.trb.2007.09.003</span>

<span class="sd">    :param V: dict of objects representing the utility functions of</span>
<span class="sd">              each alternative, indexed by numerical ids.</span>

<span class="sd">    :type V: dict(int:biogeme.expressions.expr.Expression)</span>

<span class="sd">    :param logGi: a dictionary mapping each alternative id with the function</span>

<span class="sd">        .. math:: \\ln \\frac{\\partial G}{\\partial y_i}</span>
<span class="sd">                  (e^{V_1}, \\ldots, e^{V_J})</span>

<span class="sd">        where :math:`G` is the MEV generating function. If an alternative</span>
<span class="sd">        :math:`i` is not available, then :math:`G_i = 0`.</span>

<span class="sd">    :type logGi: dict(int:biogeme.expressions.expr.Expression)</span>

<span class="sd">    :param av: dict of objects representing the availability of each</span>
<span class="sd">               alternative (:math:`a_i` in the above formula), indexed</span>
<span class="sd">               by numerical ids. Must be consistent with V, or</span>
<span class="sd">               None. In this case, all alternatives are supposed to be</span>
<span class="sd">               always available.</span>

<span class="sd">    :type av: dict(int:biogeme.expressions.expr.Expression)</span>


<span class="sd">    :param correction: a dict of expressions for the correstion terms</span>
<span class="sd">                       of each alternative.</span>
<span class="sd">    :type correction: dict(int:biogeme.expressions.expr.Expression)</span>

<span class="sd">    :param choice: id of the alternative for which the probability must be</span>
<span class="sd">              calculated.</span>
<span class="sd">    :type choice: biogeme.expressions.expr.Expression</span>

<span class="sd">    :return: log of the choice probability of the MEV model, given by</span>

<span class="sd">    .. math:: V_i + \\ln G_i(e^{V_1}, \\ldots,e^{V_J}) + \\omega_i -</span>
<span class="sd">              \\ln\\left(\\sum_j e^{V_j +</span>
<span class="sd">              \\ln G_j(e^{V_1}, \\ldots, e^{V_J})+ \\omega_j}\\right)</span>

<span class="sd">    where :math:`\\omega_i` is the correction term for alternative :math:`i`.</span>

<span class="sd">    :rtype: biogeme.expressions.expr.Expression</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">H</span> <span class="o">=</span> <span class="p">{</span><span class="n">i</span><span class="p">:</span> <span class="n">v</span> <span class="o">+</span> <span class="n">logGi</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">correction</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">V</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>
    <span class="n">logP</span> <span class="o">=</span> <span class="n">expr</span><span class="o">.</span><span class="n">_bioLogLogit</span><span class="p">(</span><span class="n">H</span><span class="p">,</span> <span class="n">av</span><span class="p">,</span> <span class="n">choice</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">logP</span></div>


<div class="viewcode-block" id="mev_endogenousSampling"><a class="viewcode-back" href="../../models.html#biogeme.models.mev_endogenousSampling">[docs]</a><span class="k">def</span> <span class="nf">mev_endogenousSampling</span><span class="p">(</span><span class="n">V</span><span class="p">,</span> <span class="n">logGi</span><span class="p">,</span> <span class="n">av</span><span class="p">,</span> <span class="n">correction</span><span class="p">,</span> <span class="n">choice</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Choice probability for a MEV model, including the correction</span>
<span class="sd">    for endogenous sampling as proposed by</span>
<span class="sd">    `Bierlaire, Bolduc and McFadden (2008)`_.</span>

<span class="sd">    .. _`Bierlaire, Bolduc and McFadden (2008)`:</span>
<span class="sd">           http://dx.doi.org/10.1016/j.trb.2007.09.003</span>

<span class="sd">    :param V: dict of objects representing the utility functions of</span>
<span class="sd">              each alternative, indexed by numerical ids.</span>

<span class="sd">    :type V: dict(int:biogeme.expressions.expr.Expression)</span>

<span class="sd">    :param logGi: a dictionary mapping each alternative id with the function</span>

<span class="sd">        .. math:: \\ln \\frac{\\partial G}{\\partial y_i}</span>
<span class="sd">              (e^{V_1}, \\ldots, e^{V_J})</span>

<span class="sd">        where :math:`G` is the MEV generating function. If an alternative</span>
<span class="sd">        :math:`i` is not available, then :math:`G_i = 0`.</span>

<span class="sd">    :type logGi: dict(int:biogeme.expressions.expr.Expression)</span>

<span class="sd">    :param av: dict of objects representing the availability of each</span>
<span class="sd">               alternative (:math:`a_i` in the above formula), indexed</span>
<span class="sd">               by numerical ids. Must be consistent with V, or</span>
<span class="sd">               None. In this case, all alternatives are supposed to be</span>
<span class="sd">               always available.</span>

<span class="sd">    :type av: dict(int:biogeme.expressions.expr.Expression)</span>


<span class="sd">    :param correction: a dict of expressions for the correstion terms</span>
<span class="sd">                       of each alternative.</span>
<span class="sd">    :type correction: dict(int:biogeme.expressions.expr.Expression)</span>

<span class="sd">    :param choice: id of the alternative for which the probability must be</span>
<span class="sd">              calculated.</span>
<span class="sd">    :type choice: biogeme.expressions.expr.Expression</span>

<span class="sd">    :return: log of the choice probability of the MEV model, given by</span>

<span class="sd">    .. math:: V_i + \\ln G_i(e^{V_1}, \\ldots, e^{V_J}) + \\omega_i -</span>
<span class="sd">              \\ln\\left(\\sum_j e^{V_j + \\ln G_j(e^{V_1},\\ldots,e^{V_J})+</span>
<span class="sd">              \\omega_j}\\right)</span>

<span class="sd">    where :math:`\\omega_i` is the correction term for alternative :math:`i`.</span>

<span class="sd">    :rtype: biogeme.expressions.expr.Expression</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">expr</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span>
        <span class="n">logmev_endogenousSampling</span><span class="p">(</span><span class="n">V</span><span class="p">,</span> <span class="n">logGi</span><span class="p">,</span> <span class="n">av</span><span class="p">,</span> <span class="n">correction</span><span class="p">,</span> <span class="n">choice</span><span class="p">)</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="getMevGeneratingForNested"><a class="viewcode-back" href="../../models.html#biogeme.models.getMevGeneratingForNested">[docs]</a><span class="k">def</span> <span class="nf">getMevGeneratingForNested</span><span class="p">(</span><span class="n">V</span><span class="p">,</span> <span class="n">availability</span><span class="p">,</span> <span class="n">nests</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Implements the  MEV generating function for the nested logit model</span>

<span class="sd">    :param V: dict of objects representing the utility functions of</span>
<span class="sd">              each alternative, indexed by numerical ids.</span>
<span class="sd">    :type V: dict(int:biogeme.expressions.expr.Expression)</span>

<span class="sd">    :param availability: dict of objects representing the availability of each</span>
<span class="sd">               alternative, indexed</span>
<span class="sd">               by numerical ids. Must be consistent with V, or</span>
<span class="sd">               None. In this case, all alternatives are supposed to be</span>
<span class="sd">               always available.</span>

<span class="sd">    :type availability: dict(int:biogeme.expressions.expr.Expression)</span>

<span class="sd">    :param nests: A tuple containing as many items as nests.</span>
<span class="sd">        Each item is also a tuple containing two items:</span>

<span class="sd">        - an object of type biogeme.expressions.expr.Expression representing</span>
<span class="sd">          the nest parameter,</span>
<span class="sd">        - a list containing the list of identifiers of the alternatives</span>
<span class="sd">          belonging to the nest.</span>

<span class="sd">        Example::</span>

<span class="sd">            nesta = MUA ,[1, 2, 3]</span>
<span class="sd">            nestb = MUB ,[4, 5, 6]</span>
<span class="sd">            nests = nesta, nestb</span>

<span class="sd">    :type nests: tuple</span>

<span class="sd">    :return: a dictionary mapping each alternative id with the function</span>

<span class="sd">    .. math:: G(e^{V_1},</span>
<span class="sd">              \\ldots,e^{V_J}) =  \\sum_m \\left( \\sum_{\\ell \\in C_m}</span>
<span class="sd">              y_\\ell^{\\mu_m}\\right)^{\\frac{\\mu}{\\mu_m}}</span>

<span class="sd">    where :math:`G` is the MEV generating function.</span>

<span class="sd">    :rtype: biogeme.expressions.expr.Expression</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">termsForNests</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">nests</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">availability</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">sumdict</span> <span class="o">=</span> <span class="p">[</span><span class="n">expr</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">m</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">V</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">m</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">sumdict</span> <span class="o">=</span> <span class="p">[</span>
                <span class="n">expr</span><span class="o">.</span><span class="n">Elem</span><span class="p">(</span>
                    <span class="p">{</span><span class="mi">0</span><span class="p">:</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mi">1</span><span class="p">:</span> <span class="n">expr</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">m</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">V</span><span class="p">[</span><span class="n">i</span><span class="p">])},</span>
                    <span class="n">availability</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">!=</span> <span class="n">expr</span><span class="o">.</span><span class="n">Numeric</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span>
                <span class="p">)</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">m</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
            <span class="p">]</span>
        <span class="n">theSum</span> <span class="o">=</span> <span class="n">expr</span><span class="o">.</span><span class="n">bioMultSum</span><span class="p">(</span><span class="n">sumdict</span><span class="p">)</span>
        <span class="n">termsForNests</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">theSum</span><span class="o">**</span><span class="mf">1.0</span> <span class="o">/</span> <span class="n">m</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    <span class="k">return</span> <span class="n">expr</span><span class="o">.</span><span class="n">bioMultSum</span><span class="p">(</span><span class="n">termsForNests</span><span class="p">)</span></div>


<div class="viewcode-block" id="getMevForNested"><a class="viewcode-back" href="../../models.html#biogeme.models.getMevForNested">[docs]</a><span class="k">def</span> <span class="nf">getMevForNested</span><span class="p">(</span><span class="n">V</span><span class="p">,</span> <span class="n">availability</span><span class="p">,</span> <span class="n">nests</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Implements the derivatives of MEV generating function for the</span>
<span class="sd">    nested logit model</span>

<span class="sd">    :param V: dict of objects representing the utility functions of</span>
<span class="sd">        each alternative, indexed by numerical ids.</span>
<span class="sd">    :type V: dict(int:biogeme.expressions.expr.Expression)</span>

<span class="sd">    :param availability: dict of objects representing the availability of each</span>
<span class="sd">               alternative, indexed</span>
<span class="sd">               by numerical ids. Must be consistent with V, or</span>
<span class="sd">               None. In this case, all alternatives are supposed to be</span>
<span class="sd">               always available.</span>

<span class="sd">    :type availability: dict(int:biogeme.expressions.expr.Expression)</span>

<span class="sd">    :param nests: A tuple containing as many items as nests.</span>
<span class="sd">        Each item is also a tuple containing two items:</span>

<span class="sd">        - an object of type biogeme.expressions.expr.Expression representing</span>
<span class="sd">          the nest parameter,</span>
<span class="sd">        - a list containing the list of identifiers of the alternatives</span>
<span class="sd">          belonging to the nest.</span>

<span class="sd">        Example::</span>

<span class="sd">            nesta = MUA ,[1, 2, 3]</span>
<span class="sd">            nestb = MUB ,[4, 5, 6]</span>
<span class="sd">            nests = nesta, nestb</span>

<span class="sd">    :type nests: tuple</span>

<span class="sd">    :return: a dictionary mapping each alternative id with the function</span>

<span class="sd">        .. math:: \\ln \\frac{\\partial G}{\\partial y_i}(e^{V_1},</span>
<span class="sd">              \\ldots,e^{V_J}) = e^{(\\mu_m-1)V_i}</span>
<span class="sd">              \\left(\\sum_{i=1}^{J_m} e^{\\mu_m V_i}\\right)^</span>
<span class="sd">              {\\frac{1}{\\mu_m}-1}</span>

<span class="sd">        where :math:`m` is the (only) nest containing alternative :math:`i`,</span>
<span class="sd">        and :math:`G` is the MEV generating function.</span>

<span class="sd">    :rtype: dict(int:biogeme.expressions.expr.Expression)</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">logGi</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">nests</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">availability</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">sumdict</span> <span class="o">=</span> <span class="p">[</span><span class="n">expr</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">m</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">V</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">m</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">sumdict</span> <span class="o">=</span> <span class="p">[</span>
                <span class="n">expr</span><span class="o">.</span><span class="n">Elem</span><span class="p">(</span>
                    <span class="p">{</span><span class="mi">0</span><span class="p">:</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mi">1</span><span class="p">:</span> <span class="n">expr</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">m</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">V</span><span class="p">[</span><span class="n">i</span><span class="p">])},</span>
                    <span class="n">availability</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">!=</span> <span class="n">expr</span><span class="o">.</span><span class="n">Numeric</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span>
                <span class="p">)</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">m</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
            <span class="p">]</span>
        <span class="n">theSum</span> <span class="o">=</span> <span class="n">expr</span><span class="o">.</span><span class="n">bioMultSum</span><span class="p">(</span><span class="n">sumdict</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">m</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
            <span class="n">logGi</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">m</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="mf">1.0</span><span class="p">)</span> <span class="o">*</span> <span class="n">V</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="p">(</span><span class="mf">1.0</span> <span class="o">/</span> <span class="n">m</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="mf">1.0</span><span class="p">)</span> <span class="o">*</span> <span class="n">expr</span><span class="o">.</span><span class="n">log</span><span class="p">(</span>
                <span class="n">theSum</span>
            <span class="p">)</span>
    <span class="k">return</span> <span class="n">logGi</span></div>


<div class="viewcode-block" id="getMevForNestedMu"><a class="viewcode-back" href="../../models.html#biogeme.models.getMevForNestedMu">[docs]</a><span class="k">def</span> <span class="nf">getMevForNestedMu</span><span class="p">(</span><span class="n">V</span><span class="p">,</span> <span class="n">availability</span><span class="p">,</span> <span class="n">nests</span><span class="p">,</span> <span class="n">mu</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Implements the MEV generating function for the nested logit model,</span>
<span class="sd">    including the scale parameter</span>

<span class="sd">    :param V: dict of objects representing the utility functions of</span>
<span class="sd">        each alternative, indexed by numerical ids.</span>

<span class="sd">    :type V: dict(int:biogeme.expressions.expr.Expression)</span>

<span class="sd">    :param availability: dict of objects representing the availability</span>
<span class="sd">        of each alternative, indexed</span>
<span class="sd">        by numerical ids. Must be consistent with V, or</span>
<span class="sd">        None. In this case, all alternatives are supposed to be</span>
<span class="sd">        always available.</span>

<span class="sd">    :type availability: dict(int:biogeme.expressions.expr.Expression)</span>

<span class="sd">    :param nests: A tuple containing as many items as nests.</span>
<span class="sd">        Each item is also a tuple containing two items:</span>

<span class="sd">        - an object of type biogeme.expressions. expr.Expression</span>
<span class="sd">          representing the nest parameter,</span>
<span class="sd">        - a list containing the list of identifiers of the alternatives</span>
<span class="sd">          belonging to the nest.</span>

<span class="sd">        Example::</span>

<span class="sd">            nesta = MUA, [1, 2, 3]</span>
<span class="sd">           nestb = MUB, [4, 5, 6]</span>
<span class="sd">            nests = nesta, nestb</span>

<span class="sd">    :type nests: tuple</span>

<span class="sd">    :param mu: scale parameter</span>
<span class="sd">    :type mu: biogeme.expressions.expr.Expression</span>

<span class="sd">    :return: a dictionary mapping each alternative id with the function</span>

<span class="sd">        .. math:: \\frac{\\partial G}{\\partial y_i}(e^{V_1},\\ldots,e^{V_J}) =</span>
<span class="sd">                  \\mu e^{(\\mu_m-1)V_i} \\left(\\sum_{i=1}^{J_m}</span>
<span class="sd">                  e^{\\mu_m V_i}\\right)^{\\frac{\\mu}{\\mu_m}-1}</span>

<span class="sd">        where :math:`m` is the (only) nest containing alternative :math:`i`,</span>
<span class="sd">        and :math:`G` is the MEV generating function.</span>

<span class="sd">    :rtype: dict(int:biogeme.expressions.expr.Expression)</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">logGi</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">nests</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">availability</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">sumdict</span> <span class="o">=</span> <span class="p">[</span><span class="n">expr</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">m</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">V</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">m</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">sumdict</span> <span class="o">=</span> <span class="p">[</span>
                <span class="n">expr</span><span class="o">.</span><span class="n">Elem</span><span class="p">(</span>
                    <span class="p">{</span><span class="mi">0</span><span class="p">:</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mi">1</span><span class="p">:</span> <span class="n">expr</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">m</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">V</span><span class="p">[</span><span class="n">i</span><span class="p">])},</span> <span class="n">availability</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">0</span>
                <span class="p">)</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">m</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
            <span class="p">]</span>
        <span class="n">theSum</span> <span class="o">=</span> <span class="n">expr</span><span class="o">.</span><span class="n">bioMultSum</span><span class="p">(</span><span class="n">sumdict</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">m</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
            <span class="n">logGi</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">expr</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">mu</span><span class="p">)</span>
                <span class="o">+</span> <span class="p">(</span><span class="n">m</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="mf">1.0</span><span class="p">)</span> <span class="o">*</span> <span class="n">V</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                <span class="o">+</span> <span class="p">(</span><span class="n">mu</span> <span class="o">/</span> <span class="n">m</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="mf">1.0</span><span class="p">)</span> <span class="o">*</span> <span class="n">expr</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">theSum</span><span class="p">)</span>
            <span class="p">)</span>
    <span class="k">return</span> <span class="n">logGi</span></div>


<div class="viewcode-block" id="nested"><a class="viewcode-back" href="../../models.html#biogeme.models.nested">[docs]</a><span class="k">def</span> <span class="nf">nested</span><span class="p">(</span><span class="n">V</span><span class="p">,</span> <span class="n">availability</span><span class="p">,</span> <span class="n">nests</span><span class="p">,</span> <span class="n">choice</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Implements the nested logit model as a MEV model.</span>

<span class="sd">    :param V: dict of objects representing the utility functions of</span>
<span class="sd">              each alternative, indexed by numerical ids.</span>
<span class="sd">    :type V: dict(int:biogeme.expressions.expr.Expression)</span>

<span class="sd">    :param availability: dict of objects representing the availability</span>
<span class="sd">                         of each alternative, indexed by numerical</span>
<span class="sd">                         ids. Must be consistent with V, or None. In</span>
<span class="sd">                         this case, all alternatives are supposed to</span>
<span class="sd">                         be always available.</span>

<span class="sd">    :type availability: dict(int:biogeme.expressions.expr.Expression)</span>

<span class="sd">    :param nests: A tuple containing as many items as nests. Each item is also</span>
<span class="sd">        a tuple containing two items:</span>

<span class="sd">        - an object of type biogeme.expressions. expr.Expression</span>
<span class="sd">          representing the nest parameter,</span>
<span class="sd">        - a list containing the list of identifiers of the</span>
<span class="sd">          alternatives belonging to the nest.</span>

<span class="sd">        Example::</span>

<span class="sd">            nesta = MUA, [1, 2, 3]</span>
<span class="sd">            nestb = MUB, [4, 5, 6]</span>
<span class="sd">            nests = nesta, nestb</span>

<span class="sd">    :type nests: tuple</span>

<span class="sd">    :param choice: id of the alternative for which the probability must be</span>
<span class="sd">              calculated.</span>
<span class="sd">    :type choice: biogeme.expressions.expr.Expression</span>

<span class="sd">    :return: choice probability for the nested logit model,</span>
<span class="sd">             based on the derivatives of the MEV generating function produced</span>
<span class="sd">             by the function getMevForNested</span>

<span class="sd">    :rtype: biogeme.expressions.expr.Expression</span>

<span class="sd">    :raise biogemeError: if the definition of the nests is invalid.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">ok</span><span class="p">,</span> <span class="n">message</span> <span class="o">=</span> <span class="n">checkValidityNestedLogit</span><span class="p">(</span><span class="n">V</span><span class="p">,</span> <span class="n">nests</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">ok</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">excep</span><span class="o">.</span><span class="n">biogemeError</span><span class="p">(</span><span class="n">message</span><span class="p">)</span>

    <span class="n">logGi</span> <span class="o">=</span> <span class="n">getMevForNested</span><span class="p">(</span><span class="n">V</span><span class="p">,</span> <span class="n">availability</span><span class="p">,</span> <span class="n">nests</span><span class="p">)</span>
    <span class="n">P</span> <span class="o">=</span> <span class="n">mev</span><span class="p">(</span><span class="n">V</span><span class="p">,</span> <span class="n">logGi</span><span class="p">,</span> <span class="n">availability</span><span class="p">,</span> <span class="n">choice</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">P</span></div>


<div class="viewcode-block" id="lognested"><a class="viewcode-back" href="../../models.html#biogeme.models.lognested">[docs]</a><span class="k">def</span> <span class="nf">lognested</span><span class="p">(</span><span class="n">V</span><span class="p">,</span> <span class="n">availability</span><span class="p">,</span> <span class="n">nests</span><span class="p">,</span> <span class="n">choice</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Implements the log of a nested logit model as a MEV model.</span>

<span class="sd">    :param V: dict of objects representing the utility functions of</span>
<span class="sd">        each alternative, indexed by numerical ids.</span>

<span class="sd">    :type V: dict(int:biogeme.expressions.expr.Expression)</span>

<span class="sd">    :param availability: dict of objects representing the availability of each</span>
<span class="sd">        alternative (:math:`a_i` in the above formula), indexed</span>
<span class="sd">        by numerical ids. Must be consistent with V, or</span>
<span class="sd">        None. In this case, all alternatives are supposed to be</span>
<span class="sd">        always available.</span>

<span class="sd">    :type availability: dict(int:biogeme.expressions.expr.Expression)</span>

<span class="sd">    :param nests: A tuple containing as many items as nests.</span>
<span class="sd">        Each item is also a tuple containing two items:</span>

<span class="sd">        - an object of type biogeme.expressions. expr.Expression representing</span>
<span class="sd">          the nest parameter,</span>
<span class="sd">        - a list containing the list of identifiers of the alternatives</span>
<span class="sd">          belonging to the nest.</span>

<span class="sd">        Example::</span>

<span class="sd">            nesta = MUA, [1, 2, 3]</span>
<span class="sd">            nestb = MUB, [4, 5, 6]</span>
<span class="sd">            nests = nesta, nestb</span>

<span class="sd">    :type nests: tuple</span>

<span class="sd">    :param choice: id of the alternative for which the probability must be</span>
<span class="sd">              calculated.</span>
<span class="sd">    :type choice: biogeme.expressions.expr.Expression</span>

<span class="sd">    :return: log of choice probability for the nested logit model,</span>
<span class="sd">             based on the derivatives of the MEV generating function produced</span>
<span class="sd">             by the function getMevForNested</span>

<span class="sd">    :rtype: biogeme.expressions.expr.Expression</span>

<span class="sd">    :raise biogemeError: if the definition of the nests is invalid.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">ok</span><span class="p">,</span> <span class="n">message</span> <span class="o">=</span> <span class="n">checkValidityNestedLogit</span><span class="p">(</span><span class="n">V</span><span class="p">,</span> <span class="n">nests</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">ok</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">excep</span><span class="o">.</span><span class="n">biogemeError</span><span class="p">(</span><span class="n">message</span><span class="p">)</span>
    <span class="n">logGi</span> <span class="o">=</span> <span class="n">getMevForNested</span><span class="p">(</span><span class="n">V</span><span class="p">,</span> <span class="n">availability</span><span class="p">,</span> <span class="n">nests</span><span class="p">)</span>
    <span class="n">logP</span> <span class="o">=</span> <span class="n">logmev</span><span class="p">(</span><span class="n">V</span><span class="p">,</span> <span class="n">logGi</span><span class="p">,</span> <span class="n">availability</span><span class="p">,</span> <span class="n">choice</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">logP</span></div>


<div class="viewcode-block" id="nestedMevMu"><a class="viewcode-back" href="../../models.html#biogeme.models.nestedMevMu">[docs]</a><span class="k">def</span> <span class="nf">nestedMevMu</span><span class="p">(</span><span class="n">V</span><span class="p">,</span> <span class="n">availability</span><span class="p">,</span> <span class="n">nests</span><span class="p">,</span> <span class="n">choice</span><span class="p">,</span> <span class="n">mu</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Implements the nested logit model as a MEV model, where mu is also</span>
<span class="sd">    a parameter, if the user wants to test different normalization</span>
<span class="sd">    schemes.</span>

<span class="sd">    :param V: dict of objects representing the utility functions of</span>
<span class="sd">              each alternative, indexed by numerical ids.</span>

<span class="sd">    :type V: dict(int:biogeme.expressions.expr.Expression)</span>

<span class="sd">    :param availability: dict of objects representing the availability of each</span>
<span class="sd">               alternative (:math:`a_i` in the above formula), indexed</span>
<span class="sd">               by numerical ids. Must be consistent with V, or</span>
<span class="sd">               None. In this case, all alternatives are supposed to be</span>
<span class="sd">               always available.</span>

<span class="sd">    :type availability: dict(int:biogeme.expressions.expr.Expression)</span>

<span class="sd">    :param nests: A tuple containing as many items as nests.</span>
<span class="sd">        Each item is also a tuple containing two items:</span>

<span class="sd">        - an object of type biogeme.expressions.expr.Expression  representing</span>
<span class="sd">          the nest parameter,</span>
<span class="sd">        - a list containing the list of identifiers of the alternatives</span>
<span class="sd">          belonging to the nest.</span>

<span class="sd">        Example::</span>

<span class="sd">            nesta = MUA ,[1, 2, 3]</span>
<span class="sd">            nestb = MUB ,[4, 5, 6]</span>
<span class="sd">            nests = nesta, nestb</span>

<span class="sd">    :type nests: tuple</span>

<span class="sd">    :param choice: id of the alternative for which the probability must be</span>
<span class="sd">              calculated.</span>
<span class="sd">    :type choice: biogeme.expressions.expr.Expression</span>

<span class="sd">    :param mu: expression producing the value of the top-level scale parameter.</span>
<span class="sd">    :type mu:  biogeme.expressions.expr.Expression</span>

<span class="sd">    :return: the nested logit choice probability based on the following</span>
<span class="sd">             derivatives of the MEV generating function:</span>

<span class="sd">    .. math:: \\frac{\\partial G}{\\partial y_i}(e^{V_1},\\ldots,e^{V_J}) =</span>
<span class="sd">              \\mu e^{(\\mu_m-1)V_i} \\left(\\sum_{i=1}^{J_m}</span>
<span class="sd">              e^{\\mu_m V_i}\\right)^{\\frac{\\mu}{\\mu_m}-1}</span>

<span class="sd">    Where :math:`m` is the (only) nest containing alternative :math:`i`, and</span>
<span class="sd">    :math:`G` is the MEV generating function.</span>

<span class="sd">    :rtype: biogeme.expressions.expr.Expression</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">expr</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">lognestedMevMu</span><span class="p">(</span><span class="n">V</span><span class="p">,</span> <span class="n">availability</span><span class="p">,</span> <span class="n">nests</span><span class="p">,</span> <span class="n">choice</span><span class="p">,</span> <span class="n">mu</span><span class="p">))</span></div>


<div class="viewcode-block" id="lognestedMevMu"><a class="viewcode-back" href="../../models.html#biogeme.models.lognestedMevMu">[docs]</a><span class="k">def</span> <span class="nf">lognestedMevMu</span><span class="p">(</span><span class="n">V</span><span class="p">,</span> <span class="n">availability</span><span class="p">,</span> <span class="n">nests</span><span class="p">,</span> <span class="n">choice</span><span class="p">,</span> <span class="n">mu</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Implements the log of the nested logit model as a MEV model, where</span>
<span class="sd">    mu is also a parameter, if the user wants to test different</span>
<span class="sd">    normalization schemes.</span>


<span class="sd">    :param V: dict of objects representing the utility functions of</span>
<span class="sd">        each alternative, indexed by numerical ids.</span>

<span class="sd">    :type V: dict(int:biogeme.expressions.expr.Expression)</span>

<span class="sd">    :param availability: dict of objects representing the availability of each</span>
<span class="sd">               alternative (:math:`a_i` in the above formula), indexed</span>
<span class="sd">               by numerical ids. Must be consistent with V, or</span>
<span class="sd">               None. In this case, all alternatives are supposed to be</span>
<span class="sd">               always available.</span>

<span class="sd">    :type availability: dict(int:biogeme.expressions.expr.Expression)</span>

<span class="sd">    :param nests: A tuple containing as many items as nests.</span>
<span class="sd">        Each item is also a tuple containing two items:</span>

<span class="sd">        - an object of type biogeme.expressions.expr.Expression  representing</span>
<span class="sd">          the nest parameter,</span>
<span class="sd">        - a list containing the list of identifiers of the alternatives</span>
<span class="sd">          belonging to the nest.</span>

<span class="sd">        Example::</span>

<span class="sd">            nesta = MUA, [1, 2, 3]</span>
<span class="sd">            nestb = MUB, [4, 5, 6]</span>
<span class="sd">            nests = nesta, nestb</span>

<span class="sd">    :type nests: tuple</span>

<span class="sd">    :param choice: id of the alternative for which the probability must be</span>
<span class="sd">              calculated.</span>
<span class="sd">    :type choice: biogeme.expressions.expr.Expression</span>

<span class="sd">    :param mu: expression producing the value of the top-level scale parameter.</span>
<span class="sd">    :type mu:  biogeme.expressions.expr.Expression</span>

<span class="sd">    :return: the log of the nested logit choice probability based on the</span>
<span class="sd">        following derivatives of the MEV generating function:</span>

<span class="sd">        .. math:: \\frac{\\partial G}{\\partial y_i}(e^{V_1},\\ldots,e^{V_J}) =</span>
<span class="sd">                  \\mu e^{(\\mu_m-1)V_i} \\left(\\sum_{i=1}^{J_m}</span>
<span class="sd">                  e^{\\mu_m V_i}\\right)^{\\frac{\\mu}{\\mu_m}-1}</span>

<span class="sd">        where :math:`m` is the (only) nest containing alternative :math:`i`,</span>
<span class="sd">        and :math:`G` is the MEV generating function.</span>

<span class="sd">    :rtype: biogeme.expressions.expr.Expression</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">logGi</span> <span class="o">=</span> <span class="n">getMevForNestedMu</span><span class="p">(</span><span class="n">V</span><span class="p">,</span> <span class="n">availability</span><span class="p">,</span> <span class="n">nests</span><span class="p">,</span> <span class="n">mu</span><span class="p">)</span>
    <span class="n">logP</span> <span class="o">=</span> <span class="n">logmev</span><span class="p">(</span><span class="n">V</span><span class="p">,</span> <span class="n">logGi</span><span class="p">,</span> <span class="n">availability</span><span class="p">,</span> <span class="n">choice</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">logP</span></div>


<div class="viewcode-block" id="cnl_avail"><a class="viewcode-back" href="../../models.html#biogeme.models.cnl_avail">[docs]</a><span class="k">def</span> <span class="nf">cnl_avail</span><span class="p">(</span><span class="n">V</span><span class="p">,</span> <span class="n">availability</span><span class="p">,</span> <span class="n">nests</span><span class="p">,</span> <span class="n">choice</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Same as cnl. Maintained for backward compatibility</span>

<span class="sd">    :param V: dict of objects representing the utility functions of</span>
<span class="sd">              each alternative, indexed by numerical ids.</span>
<span class="sd">    :type V: dict(int:biogeme.expressions.expr.Expression)</span>

<span class="sd">    :param availability: dict of objects representing the availability of each</span>
<span class="sd">               alternative, indexed</span>
<span class="sd">               by numerical ids. Must be consistent with V, or</span>
<span class="sd">               None. In this case, all alternatives are supposed to be</span>
<span class="sd">               always available.</span>

<span class="sd">    :type availability: dict(int:biogeme.expressions.expr.Expression)</span>

<span class="sd">    :param nests: a tuple containing as many items as nests. Each item is</span>
<span class="sd">        also a tuple containing two items</span>

<span class="sd">        - an object of type biogeme.expressions.expr.Expression  representing</span>
<span class="sd">          the nest parameter,</span>
<span class="sd">        - a dictionary mapping the alternative ids with the cross-nested</span>
<span class="sd">          parameters for the corresponding nest. If an alternative is</span>
<span class="sd">          missing in the dictionary, the corresponding alpha is set to zero.</span>

<span class="sd">        Example::</span>

<span class="sd">            alphaA = {1: alpha1a,</span>
<span class="sd">                      2: alpha2a,</span>
<span class="sd">                      3: alpha3a,</span>
<span class="sd">                      4: alpha4a,</span>
<span class="sd">                      5: alpha5a,</span>
<span class="sd">                      6: alpha6a}</span>
<span class="sd">            alphaB = {1: alpha1b,</span>
<span class="sd">                      2: alpha2b,</span>
<span class="sd">                      3: alpha3b,</span>
<span class="sd">                      4: alpha4b,</span>
<span class="sd">                      5: alpha5b,</span>
<span class="sd">                      6: alpha6b}</span>
<span class="sd">            nesta = MUA, alphaA</span>
<span class="sd">            nestb = MUB, alphaB</span>
<span class="sd">            nests = nesta, nestb</span>

<span class="sd">    :type nests: tuple</span>

<span class="sd">    :param choice: id of the alternative for which the probability must be</span>
<span class="sd">              calculated.</span>
<span class="sd">    :type choice: biogeme.expressions.expr.Expression</span>

<span class="sd">    :return: choice probability for the cross-nested logit model.</span>
<span class="sd">    :rtype: biogeme.expressions.expr.Expression</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">cnl</span><span class="p">(</span><span class="n">V</span><span class="p">,</span> <span class="n">availability</span><span class="p">,</span> <span class="n">nests</span><span class="p">,</span> <span class="n">choice</span><span class="p">)</span></div>


<div class="viewcode-block" id="cnl"><a class="viewcode-back" href="../../models.html#biogeme.models.cnl">[docs]</a><span class="k">def</span> <span class="nf">cnl</span><span class="p">(</span><span class="n">V</span><span class="p">,</span> <span class="n">availability</span><span class="p">,</span> <span class="n">nests</span><span class="p">,</span> <span class="n">choice</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Implements the cross-nested logit model as a MEV model.</span>

<span class="sd">    :param V: dict of objects representing the utility functions of</span>
<span class="sd">              each alternative, indexed by numerical ids.</span>
<span class="sd">    :type V: dict(int:biogeme.expressions.expr.Expression)</span>

<span class="sd">    :param availability: dict of objects representing the availability of each</span>
<span class="sd">               alternative, indexed</span>
<span class="sd">               by numerical ids. Must be consistent with V, or</span>
<span class="sd">               None. In this case, all alternatives are supposed to be</span>
<span class="sd">               always available.</span>

<span class="sd">    :type availability: dict(int:biogeme.expressions.expr.Expression)</span>

<span class="sd">    :param nests: a tuple containing as many items as nests.</span>
<span class="sd">        Each item is also a tuple containing two items:</span>

<span class="sd">        - an object of type biogeme.expressions. expr.Expression</span>
<span class="sd">          representing the nest parameter,</span>
<span class="sd">        - a dictionary mapping the alternative ids with the cross-nested</span>
<span class="sd">          parameters for the corresponding nest. If an alternative is</span>
<span class="sd">          missing in the dictionary, the corresponding alpha is set to zero.</span>

<span class="sd">        Example::</span>

<span class="sd">            alphaA = {1: alpha1a,</span>
<span class="sd">                      2: alpha2a,</span>
<span class="sd">                      3: alpha3a,</span>
<span class="sd">                      4: alpha4a,</span>
<span class="sd">                      5: alpha5a,</span>
<span class="sd">                      6: alpha6a}</span>
<span class="sd">            alphaB = {1: alpha1b,</span>
<span class="sd">                      2: alpha2b,</span>
<span class="sd">                      3: alpha3b,</span>
<span class="sd">                      4: alpha4b,</span>
<span class="sd">                      5: alpha5b,</span>
<span class="sd">                      6: alpha6b}</span>
<span class="sd">            nesta = MUA, alphaA</span>
<span class="sd">            nestb = MUB, alphaB</span>
<span class="sd">            nests = nesta, nestb</span>

<span class="sd">    :type nests: tuple</span>

<span class="sd">    :param choice: id of the alternative for which the probability must be</span>
<span class="sd">              calculated.</span>
<span class="sd">    :type choice: biogeme.expressions.expr.Expression</span>

<span class="sd">    :return: choice probability for the cross-nested logit model.</span>
<span class="sd">    :rtype: biogeme.expressions.expr.Expression</span>


<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">expr</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">logcnl</span><span class="p">(</span><span class="n">V</span><span class="p">,</span> <span class="n">availability</span><span class="p">,</span> <span class="n">nests</span><span class="p">,</span> <span class="n">choice</span><span class="p">))</span></div>


<div class="viewcode-block" id="logcnl_avail"><a class="viewcode-back" href="../../models.html#biogeme.models.logcnl_avail">[docs]</a><span class="k">def</span> <span class="nf">logcnl_avail</span><span class="p">(</span><span class="n">V</span><span class="p">,</span> <span class="n">availability</span><span class="p">,</span> <span class="n">nests</span><span class="p">,</span> <span class="n">choice</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Same as logcnl. Maintained for backward compatibility</span>

<span class="sd">    :param V: dict of objects representing the utility functions of</span>
<span class="sd">              each alternative, indexed by numerical ids.</span>
<span class="sd">    :type V: dict(int:biogeme.expressions.expr.Expression)</span>

<span class="sd">    :param availability: dict of objects representing the availability of each</span>
<span class="sd">               alternative, indexed</span>
<span class="sd">               by numerical ids. Must be consistent with V, or</span>
<span class="sd">               None. In this case, all alternatives are supposed to be</span>
<span class="sd">               always available.</span>

<span class="sd">    :type availability: dict(int:biogeme.expressions.expr.Expression)</span>

<span class="sd">    :param nests: a tuple containing as many items as nests.</span>
<span class="sd">        Each item is also a tuple containing two items:</span>

<span class="sd">        - an object of type biogeme.expressions. expr.Expression</span>
<span class="sd">          representing the nest parameter,</span>
<span class="sd">        - a dictionary mapping the alternative ids with the cross-nested</span>
<span class="sd">          parameters for the corresponding nest. If an alternative is</span>
<span class="sd">          missing in the dictionary, the corresponding alpha is set to zero.</span>

<span class="sd">        Example::</span>

<span class="sd">            alphaA = {1: alpha1a,</span>
<span class="sd">                      2: alpha2a,</span>
<span class="sd">                      3: alpha3a,</span>
<span class="sd">                      4: alpha4a,</span>
<span class="sd">                      5: alpha5a,</span>
<span class="sd">                      6: alpha6a}</span>
<span class="sd">            alphaB = {1: alpha1b,</span>
<span class="sd">                      2: alpha2b,</span>
<span class="sd">                      3: alpha3b,</span>
<span class="sd">                      4: alpha4b,</span>
<span class="sd">                      5: alpha5b,</span>
<span class="sd">                      6: alpha6b}</span>
<span class="sd">            nesta = MUA, alphaA</span>
<span class="sd">            nestb = MUB, alphaB</span>
<span class="sd">            nests = nesta, nestb</span>

<span class="sd">    :type nests: tuple</span>

<span class="sd">    :param choice: id of the alternative for which the probability must be</span>
<span class="sd">              calculated.</span>
<span class="sd">    :type choice: biogeme.expressions.expr.Expression</span>

<span class="sd">    :return: log of choice probability for the cross-nested logit model.</span>
<span class="sd">    :rtype: biogeme.expressions.expr.Expression</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">logcnl</span><span class="p">(</span><span class="n">V</span><span class="p">,</span> <span class="n">availability</span><span class="p">,</span> <span class="n">nests</span><span class="p">,</span> <span class="n">choice</span><span class="p">)</span></div>


<div class="viewcode-block" id="getMevForCrossNested"><a class="viewcode-back" href="../../models.html#biogeme.models.getMevForCrossNested">[docs]</a><span class="k">def</span> <span class="nf">getMevForCrossNested</span><span class="p">(</span><span class="n">V</span><span class="p">,</span> <span class="n">availability</span><span class="p">,</span> <span class="n">nests</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Implements the MEV generating function for the cross nested logit</span>
<span class="sd">    model as a MEV model.</span>

<span class="sd">    :param V: dict of objects representing the utility functions of</span>
<span class="sd">              each alternative, indexed by numerical ids.</span>
<span class="sd">    :type V: dict(int: biogeme.expressions.expr.Expression)</span>

<span class="sd">    :param availability: dict of objects representing the availability of each</span>
<span class="sd">        alternative, indexed</span>
<span class="sd">        by numerical ids. Must be consistent with V, or</span>
<span class="sd">        None. In this case, all alternatives are supposed to be</span>
<span class="sd">        always available.</span>

<span class="sd">    :type availability: dict(int: biogeme.expressions.expr.Expression)</span>

<span class="sd">    :param nests: a tuple containing as many items as nests.</span>
<span class="sd">        Each item is also a tuple containing two items:</span>

<span class="sd">        - an object of type biogeme.expressions. expr.Expression</span>
<span class="sd">          representing the nest parameter,</span>
<span class="sd">        - a dictionary mapping the alternative ids with the cross-nested</span>
<span class="sd">          parameters for the corresponding nest. If an alternative is</span>
<span class="sd">          missing in the dictionary, the corresponding alpha is set to zero.</span>

<span class="sd">        Example::</span>

<span class="sd">            alphaA = {1: alpha1a,</span>
<span class="sd">                      2: alpha2a,</span>
<span class="sd">                      3: alpha3a,</span>
<span class="sd">                      4: alpha4a,</span>
<span class="sd">                      5: alpha5a,</span>
<span class="sd">                      6: alpha6a}</span>
<span class="sd">            alphaB = {1: alpha1b,</span>
<span class="sd">                      2: alpha2b,</span>
<span class="sd">                      3: alpha3b,</span>
<span class="sd">                      4: alpha4b,</span>
<span class="sd">                      5: alpha5b,</span>
<span class="sd">                      6: alpha6b}</span>
<span class="sd">            nesta = MUA, alphaA</span>
<span class="sd">            nestb = MUB, alphaB</span>
<span class="sd">            nests = nesta, nestb</span>

<span class="sd">    :type nests: tuple</span>

<span class="sd">    :return: log of the choice probability for the cross-nested logit model.</span>
<span class="sd">    :rtype: biogeme.expressions.expr.Expression</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">Gi_terms</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="n">logGi</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">V</span><span class="p">:</span>
        <span class="n">Gi_terms</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">biosum</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">nests</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">availability</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">biosum</span> <span class="o">=</span> <span class="n">expr</span><span class="o">.</span><span class="n">bioMultSum</span><span class="p">(</span>
                <span class="p">[</span>
                    <span class="n">a</span> <span class="o">**</span> <span class="p">(</span><span class="n">m</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">*</span> <span class="n">expr</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">m</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="n">V</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span>
                    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">m</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
                <span class="p">]</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">biosum</span> <span class="o">=</span> <span class="n">expr</span><span class="o">.</span><span class="n">bioMultSum</span><span class="p">(</span>
                <span class="p">[</span>
                    <span class="n">availability</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="n">a</span> <span class="o">**</span> <span class="p">(</span><span class="n">m</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">*</span> <span class="n">expr</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">m</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="n">V</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span>
                    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">m</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
                <span class="p">]</span>
            <span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">m</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">Gi_terms</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+=</span> <span class="p">[</span>
                <span class="n">a</span> <span class="o">**</span> <span class="p">(</span><span class="n">m</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
                <span class="o">*</span> <span class="n">expr</span><span class="o">.</span><span class="n">exp</span><span class="p">((</span><span class="n">m</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">V</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span>
                <span class="o">*</span> <span class="n">biosum</span> <span class="o">**</span> <span class="p">((</span><span class="mf">1.0</span> <span class="o">/</span> <span class="n">m</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">-</span> <span class="mf">1.0</span><span class="p">)</span>
            <span class="p">]</span>
    <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">V</span><span class="p">:</span>
        <span class="n">logGi</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">expr</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">expr</span><span class="o">.</span><span class="n">bioMultSum</span><span class="p">(</span><span class="n">Gi_terms</span><span class="p">[</span><span class="n">k</span><span class="p">]))</span>
    <span class="k">return</span> <span class="n">logGi</span></div>


<div class="viewcode-block" id="logcnl"><a class="viewcode-back" href="../../models.html#biogeme.models.logcnl">[docs]</a><span class="k">def</span> <span class="nf">logcnl</span><span class="p">(</span><span class="n">V</span><span class="p">,</span> <span class="n">availability</span><span class="p">,</span> <span class="n">nests</span><span class="p">,</span> <span class="n">choice</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Implements the log of the cross-nested logit model as a MEV model.</span>

<span class="sd">    :param V: dict of objects representing the utility functions of</span>
<span class="sd">              each alternative, indexed by numerical ids.</span>
<span class="sd">    :type V: dict(int:biogeme.expressions.expr.Expression)</span>

<span class="sd">    :param availability: dict of objects representing the availability of each</span>
<span class="sd">               alternative, indexed</span>
<span class="sd">               by numerical ids. Must be consistent with V, or</span>
<span class="sd">               None. In this case, all alternatives are supposed to be</span>
<span class="sd">               always available.</span>

<span class="sd">    :type availability: dict(int:biogeme.expressions.expr.Expression)</span>

<span class="sd">    :param nests: a tuple containing as many items as nests.</span>
<span class="sd">        Each item is also a tuple containing two items:</span>

<span class="sd">        - an object of type biogeme.expressions. expr.Expression</span>
<span class="sd">          representing the nest parameter,</span>
<span class="sd">        - a dictionary mapping the alternative ids with the cross-nested</span>
<span class="sd">          parameters for the corresponding nest. If an alternative is</span>
<span class="sd">          missing in the dictionary, the corresponding alpha is set to zero.</span>

<span class="sd">        Example::</span>

<span class="sd">            alphaA = {1: alpha1a,</span>
<span class="sd">                      2: alpha2a,</span>
<span class="sd">                      3: alpha3a,</span>
<span class="sd">                      4: alpha4a,</span>
<span class="sd">                      5: alpha5a,</span>
<span class="sd">                      6: alpha6a}</span>
<span class="sd">            alphaB = {1: alpha1b,</span>
<span class="sd">                      2: alpha2b,</span>
<span class="sd">                      3: alpha3b,</span>
<span class="sd">                      4: alpha4b,</span>
<span class="sd">                      5: alpha5b,</span>
<span class="sd">                      6: alpha6b}</span>
<span class="sd">            nesta = MUA , alphaA</span>
<span class="sd">            nestb = MUB , alphaB</span>
<span class="sd">            nests = nesta, nestb</span>

<span class="sd">    :type nests: tuple</span>

<span class="sd">    :param choice: id of the alternative for which the probability must be</span>
<span class="sd">              calculated.</span>
<span class="sd">    :type choice: biogeme.expressions.expr.Expression</span>

<span class="sd">    :return: log of the choice probability for the cross-nested logit model.</span>
<span class="sd">    :rtype: biogeme.expressions.expr.Expression</span>

<span class="sd">    :raise biogemeError: if the definition of the nests is invalid.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">ok</span><span class="p">,</span> <span class="n">message</span> <span class="o">=</span> <span class="n">checkValidityCNL</span><span class="p">(</span><span class="n">V</span><span class="p">,</span> <span class="n">nests</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">ok</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">excep</span><span class="o">.</span><span class="n">biogemeError</span><span class="p">(</span><span class="n">message</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">message</span> <span class="o">!=</span> <span class="s1">&#39;&#39;</span><span class="p">:</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;CNL: </span><span class="si">{</span><span class="n">message</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
    <span class="n">logGi</span> <span class="o">=</span> <span class="n">getMevForCrossNested</span><span class="p">(</span><span class="n">V</span><span class="p">,</span> <span class="n">availability</span><span class="p">,</span> <span class="n">nests</span><span class="p">)</span>
    <span class="n">logP</span> <span class="o">=</span> <span class="n">logmev</span><span class="p">(</span><span class="n">V</span><span class="p">,</span> <span class="n">logGi</span><span class="p">,</span> <span class="n">availability</span><span class="p">,</span> <span class="n">choice</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">logP</span></div>


<div class="viewcode-block" id="cnlmu"><a class="viewcode-back" href="../../models.html#biogeme.models.cnlmu">[docs]</a><span class="k">def</span> <span class="nf">cnlmu</span><span class="p">(</span><span class="n">V</span><span class="p">,</span> <span class="n">availability</span><span class="p">,</span> <span class="n">nests</span><span class="p">,</span> <span class="n">choice</span><span class="p">,</span> <span class="n">mu</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Implements the cross-nested logit model as a MEV model with</span>
<span class="sd">    the homogeneity parameters is explicitly involved</span>

<span class="sd">    :param V: dict of objects representing the utility functions of</span>
<span class="sd">              each alternative, indexed by numerical ids.</span>
<span class="sd">    :type V: dict(int:biogeme.expressions.expr.Expression)</span>

<span class="sd">    :param availability: dict of objects representing the availability of each</span>
<span class="sd">               alternative, indexed</span>
<span class="sd">               by numerical ids. Must be consistent with V, or</span>
<span class="sd">               None. In this case, all alternatives are supposed to be</span>
<span class="sd">               always available.</span>

<span class="sd">    :type availability: dict(int:biogeme.expressions.expr.Expression)</span>

<span class="sd">    :param nests: a tuple containing as many items as nests. Each</span>
<span class="sd">        item is also a tuple containing two items:</span>

<span class="sd">        - an object of type biogeme.expressions. expr.Expression representing</span>
<span class="sd">          the nest parameter,</span>
<span class="sd">        - a dictionary mapping the alternative ids with the cross-nested</span>
<span class="sd">          parameters for the corresponding nest. If an alternative is</span>
<span class="sd">          missing in the dictionary, the corresponding alpha is set to zero.</span>

<span class="sd">        Example::</span>

<span class="sd">            alphaA = {1: alpha1a,</span>
<span class="sd">                      2: alpha2a,</span>
<span class="sd">                      3: alpha3a,</span>
<span class="sd">                      4: alpha4a,</span>
<span class="sd">                      5: alpha5a,</span>
<span class="sd">                      6: alpha6a}</span>
<span class="sd">            alphaB = {1: alpha1b,</span>
<span class="sd">                      2: alpha2b,</span>
<span class="sd">                      3: alpha3b,</span>
<span class="sd">                      4: alpha4b,</span>
<span class="sd">                      5: alpha5b,</span>
<span class="sd">                      6: alpha6b}</span>
<span class="sd">            nesta = MUA, alphaA</span>
<span class="sd">            nestb = MUB, alphaB</span>
<span class="sd">            nests = nesta, nestb</span>

<span class="sd">    :type nests: tuple</span>

<span class="sd">    :param choice: id of the alternative for which the probability must be</span>
<span class="sd">              calculated.</span>
<span class="sd">    :type choice: biogeme.expressions.expr.Expression</span>

<span class="sd">    :param mu: Homogeneity parameter :math:`\\mu`.</span>
<span class="sd">    :type mu: biogeme.expressions.expr.Expression</span>

<span class="sd">    :return: choice probability for the cross-nested logit model.</span>
<span class="sd">    :rtype: biogeme.expressions.expr.Expression</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">expr</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">logcnlmu</span><span class="p">(</span><span class="n">V</span><span class="p">,</span> <span class="n">availability</span><span class="p">,</span> <span class="n">nests</span><span class="p">,</span> <span class="n">choice</span><span class="p">,</span> <span class="n">mu</span><span class="p">))</span></div>


<div class="viewcode-block" id="getMevForCrossNestedMu"><a class="viewcode-back" href="../../models.html#biogeme.models.getMevForCrossNestedMu">[docs]</a><span class="k">def</span> <span class="nf">getMevForCrossNestedMu</span><span class="p">(</span><span class="n">V</span><span class="p">,</span> <span class="n">availability</span><span class="p">,</span> <span class="n">nests</span><span class="p">,</span> <span class="n">mu</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Implements the MEV generating function for the cross-nested logit</span>
<span class="sd">    model as a MEV model with the homogeneity parameters is explicitly</span>
<span class="sd">    involved.</span>

<span class="sd">    :param V: dict of objects representing the utility functions of</span>
<span class="sd">              each alternative, indexed by numerical ids.</span>
<span class="sd">    :type V: dict(int:biogeme.expressions.expr.Expression)</span>

<span class="sd">    :param availability: dict of objects representing the availability of each</span>
<span class="sd">               alternative, indexed</span>
<span class="sd">               by numerical ids. Must be consistent with V, or</span>
<span class="sd">               None. In this case, all alternatives are supposed to be</span>
<span class="sd">               always available.</span>

<span class="sd">    :type availability: dict(int:biogeme.expressions.expr.Expression)</span>

<span class="sd">    :param nests: a tuple containing as many items as nests.</span>
<span class="sd">        Each item is also a tuple containing two items:</span>

<span class="sd">        - an object of type biogeme.expressions. expr.Expression representing</span>
<span class="sd">          the nest parameter,</span>
<span class="sd">        - a dictionary mapping the alternative ids with the cross-nested</span>
<span class="sd">          parameters for the corresponding nest. If an alternative is</span>
<span class="sd">          missing in the dictionary, the corresponding alpha is set to zero.</span>

<span class="sd">        Example::</span>

<span class="sd">            alphaA = {1: alpha1a,</span>
<span class="sd">                      2: alpha2a,</span>
<span class="sd">                      3: alpha3a,</span>
<span class="sd">                      4: alpha4a,</span>
<span class="sd">                      5: alpha5a,</span>
<span class="sd">                      6: alpha6a}</span>
<span class="sd">            alphaB = {1: alpha1b,</span>
<span class="sd">                      2: alpha2b,</span>
<span class="sd">                      3: alpha3b,</span>
<span class="sd">                      4: alpha4b,</span>
<span class="sd">                      5: alpha5b,</span>
<span class="sd">                      6: alpha6b}</span>
<span class="sd">            nesta = MUA, alphaA</span>
<span class="sd">            nestb = MUB, alphaB</span>
<span class="sd">            nests = nesta, nestb</span>

<span class="sd">    :type nests: tuple</span>

<span class="sd">    :param mu: Homogeneity parameter :math:`\\mu`.</span>
<span class="sd">    :type mu: biogeme.expressions.expr.Expression</span>

<span class="sd">    :return: log of the choice probability for the cross-nested logit model.</span>
<span class="sd">    :rtype: biogeme.expressions.expr.Expression</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">Gi_terms</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="n">logGi</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">V</span><span class="p">:</span>
        <span class="n">Gi_terms</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">biosum</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">nests</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">availability</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">biosum</span> <span class="o">=</span> <span class="n">expr</span><span class="o">.</span><span class="n">bioMultSum</span><span class="p">(</span>
                <span class="p">[</span>
                    <span class="n">a</span> <span class="o">**</span> <span class="p">(</span><span class="n">m</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">/</span> <span class="n">mu</span><span class="p">)</span> <span class="o">*</span> <span class="n">expr</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">m</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="n">V</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span>
                    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">m</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
                <span class="p">]</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">biosum</span> <span class="o">=</span> <span class="n">expr</span><span class="o">.</span><span class="n">bioMultSum</span><span class="p">(</span>
                <span class="p">[</span>
                    <span class="n">availability</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                    <span class="o">*</span> <span class="n">a</span> <span class="o">**</span> <span class="p">(</span><span class="n">m</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">/</span> <span class="n">mu</span><span class="p">)</span>
                    <span class="o">*</span> <span class="n">expr</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">m</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="n">V</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span>
                    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">m</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
                <span class="p">]</span>
            <span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">m</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">Gi_terms</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+=</span> <span class="p">[</span>
                <span class="n">a</span> <span class="o">**</span> <span class="p">(</span><span class="n">m</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">/</span> <span class="n">mu</span><span class="p">)</span>
                <span class="o">*</span> <span class="n">expr</span><span class="o">.</span><span class="n">exp</span><span class="p">((</span><span class="n">m</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">V</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span>
                <span class="o">*</span> <span class="n">biosum</span> <span class="o">**</span> <span class="p">((</span><span class="n">mu</span> <span class="o">/</span> <span class="n">m</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">-</span> <span class="mf">1.0</span><span class="p">)</span>
            <span class="p">]</span>
    <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">V</span><span class="p">:</span>
        <span class="n">logGi</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">expr</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">mu</span> <span class="o">*</span> <span class="n">expr</span><span class="o">.</span><span class="n">bioMultSum</span><span class="p">(</span><span class="n">Gi_terms</span><span class="p">[</span><span class="n">k</span><span class="p">]))</span>
    <span class="k">return</span> <span class="n">logGi</span></div>


<div class="viewcode-block" id="logcnlmu"><a class="viewcode-back" href="../../models.html#biogeme.models.logcnlmu">[docs]</a><span class="k">def</span> <span class="nf">logcnlmu</span><span class="p">(</span><span class="n">V</span><span class="p">,</span> <span class="n">availability</span><span class="p">,</span> <span class="n">nests</span><span class="p">,</span> <span class="n">choice</span><span class="p">,</span> <span class="n">mu</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Implements the log of the cross-nested logit model as a MEV model</span>
<span class="sd">    with the homogeneity parameters is explicitly involved.</span>


<span class="sd">    :param V: dict of objects representing the utility functions of</span>
<span class="sd">              each alternative, indexed by numerical ids.</span>
<span class="sd">    :type V: dict(int:biogeme.expressions.expr.Expression)</span>

<span class="sd">    :param availability: dict of objects representing the availability of each</span>
<span class="sd">               alternative, indexed</span>
<span class="sd">               by numerical ids. Must be consistent with V, or</span>
<span class="sd">               None. In this case, all alternatives are supposed to be</span>
<span class="sd">               always available.</span>

<span class="sd">    :type availability: dict(int:biogeme.expressions.expr.Expression)</span>

<span class="sd">    :param nests: a tuple containing as many items as nests. Each item is</span>
<span class="sd">        also a tuple containing two items</span>

<span class="sd">        - an object of type biogeme.expressions. expr.Expression representing</span>
<span class="sd">          the nest parameter,</span>
<span class="sd">        - a dictionary mapping the alternative ids with the cross-nested</span>
<span class="sd">          parameters for the corresponding nest. If an alternative is</span>
<span class="sd">          missing in the dictionary, the corresponding alpha is set to zero.</span>

<span class="sd">        Example::</span>

<span class="sd">            alphaA = {1: alpha1a,</span>
<span class="sd">                      2: alpha2a,</span>
<span class="sd">                      3: alpha3a,</span>
<span class="sd">                      4: alpha4a,</span>
<span class="sd">                      5: alpha5a,</span>
<span class="sd">                      6: alpha6a}</span>
<span class="sd">            alphaB = {1: alpha1b,</span>
<span class="sd">                      2: alpha2b,</span>
<span class="sd">                      3: alpha3b,</span>
<span class="sd">                      4: alpha4b,</span>
<span class="sd">                      5: alpha5b,</span>
<span class="sd">                      6: alpha6b}</span>
<span class="sd">            nesta = MUA , alphaA</span>
<span class="sd">            nestb = MUB , alphaB</span>
<span class="sd">            nests = nesta, nestb</span>

<span class="sd">    :type nests: tuple</span>

<span class="sd">    :param choice: id of the alternative for which the probability must be</span>
<span class="sd">              calculated.</span>
<span class="sd">    :type choice: biogeme.expressions.expr.Expression</span>

<span class="sd">    :param mu: Homogeneity parameter :math:`\\mu`.</span>
<span class="sd">    :type mu: biogeme.expressions.expr.Expression</span>

<span class="sd">    :return: log of the choice probability for the cross-nested logit model.</span>
<span class="sd">    :rtype: biogeme.expressions.expr.Expression</span>

<span class="sd">    :raise biogemeError: if the definition of the nests is invalid.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">ok</span><span class="p">,</span> <span class="n">message</span> <span class="o">=</span> <span class="n">checkValidityCNL</span><span class="p">(</span><span class="n">V</span><span class="p">,</span> <span class="n">nests</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">ok</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">excep</span><span class="o">.</span><span class="n">biogemeError</span><span class="p">(</span><span class="n">message</span><span class="p">)</span>
    <span class="n">logGi</span> <span class="o">=</span> <span class="n">getMevForCrossNestedMu</span><span class="p">(</span><span class="n">V</span><span class="p">,</span> <span class="n">availability</span><span class="p">,</span> <span class="n">nests</span><span class="p">,</span> <span class="n">mu</span><span class="p">)</span>
    <span class="n">logP</span> <span class="o">=</span> <span class="n">logmev</span><span class="p">(</span><span class="n">V</span><span class="p">,</span> <span class="n">logGi</span><span class="p">,</span> <span class="n">availability</span><span class="p">,</span> <span class="n">choice</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">logP</span></div>


<div class="viewcode-block" id="checkValidityNestedLogit"><a class="viewcode-back" href="../../models.html#biogeme.models.checkValidityNestedLogit">[docs]</a><span class="k">def</span> <span class="nf">checkValidityNestedLogit</span><span class="p">(</span><span class="n">V</span><span class="p">,</span> <span class="n">nests</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Verifies if the nested logit model is indeed based on a partition</span>
<span class="sd">    of the choice set.</span>

<span class="sd">    :param V: dict of objects representing the utility functions of</span>
<span class="sd">              each alternative, indexed by numerical ids.</span>
<span class="sd">    :type V: dict(int:biogeme.expressions.expr.Expression)</span>
<span class="sd">    :param nests: A tuple containing as many items as nests. Each item is also</span>
<span class="sd">        a tuple containing two items:</span>

<span class="sd">        - an object of type biogeme.expressions. expr.Expression</span>
<span class="sd">          representing the nest parameter,</span>
<span class="sd">        - a list containing the list of identifiers of the alternatives</span>
<span class="sd">          belonging to the nest.</span>

<span class="sd">        Example::</span>

<span class="sd">          nesta = MUA, [1, 2, 3]</span>
<span class="sd">          nestb = MUB, [4, 5, 6]</span>
<span class="sd">          nests = nesta, nestb</span>

<span class="sd">    :type nests: tuple</span>


<span class="sd">    :return: a tuple ok, message, where the message explains the</span>
<span class="sd">             problem is the nested structure is not OK.</span>
<span class="sd">    :rtype: tuple(bool, str)</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">ok</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="n">message</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span>

    <span class="n">fullChoiceSet</span> <span class="o">=</span> <span class="p">{</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">V</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>
    <span class="n">unionOfNests</span> <span class="o">=</span> <span class="nb">set</span><span class="o">.</span><span class="n">union</span><span class="p">(</span><span class="o">*</span><span class="p">[</span><span class="nb">set</span><span class="p">(</span><span class="n">n</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">nests</span><span class="p">])</span>
    <span class="k">if</span> <span class="n">fullChoiceSet</span> <span class="o">!=</span> <span class="n">unionOfNests</span><span class="p">:</span>
        <span class="n">ok</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="n">d1</span> <span class="o">=</span> <span class="n">fullChoiceSet</span><span class="o">.</span><span class="n">difference</span><span class="p">(</span><span class="n">unionOfNests</span><span class="p">)</span>
        <span class="n">d2</span> <span class="o">=</span> <span class="n">unionOfNests</span><span class="o">.</span><span class="n">difference</span><span class="p">(</span><span class="n">fullChoiceSet</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">d1</span><span class="p">:</span>
            <span class="n">message</span> <span class="o">+=</span> <span class="p">(</span>
                <span class="sa">f</span><span class="s1">&#39;Alternative(s) in the choice set, but not in any nest:&#39;</span>
                <span class="sa">f</span><span class="s1">&#39; </span><span class="si">{</span><span class="n">d1</span><span class="si">}</span><span class="se">\n</span><span class="s1">&#39;</span>
            <span class="p">)</span>
        <span class="k">if</span> <span class="n">d2</span><span class="p">:</span>
            <span class="n">message</span> <span class="o">+=</span> <span class="p">(</span>
                <span class="sa">f</span><span class="s1">&#39;Alternative(s) in a nest, but not in the choice set: &#39;</span>
                <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">d2</span><span class="si">}</span><span class="se">\n</span><span class="s1">&#39;</span>
            <span class="p">)</span>

    <span class="c1"># Consider all pairs of nests and verify that the intersection is empty</span>

    <span class="n">allPairs</span> <span class="o">=</span> <span class="p">[(</span><span class="n">n1</span><span class="p">,</span> <span class="n">n2</span><span class="p">)</span> <span class="k">for</span> <span class="n">n1</span> <span class="ow">in</span> <span class="n">nests</span> <span class="k">for</span> <span class="n">n2</span> <span class="ow">in</span> <span class="n">nests</span> <span class="k">if</span> <span class="n">n1</span> <span class="o">!=</span> <span class="n">n2</span><span class="p">]</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">n1</span><span class="p">,</span> <span class="n">n2</span><span class="p">)</span> <span class="ow">in</span> <span class="n">allPairs</span><span class="p">:</span>
        <span class="n">inter</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">n1</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="n">n2</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">inter</span><span class="p">:</span>
            <span class="n">ok</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="n">message</span> <span class="o">+=</span> <span class="p">(</span>
                <span class="sa">f</span><span class="s1">&#39;Two nests contain the following alternative(s): &#39;</span>
                <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">inter</span><span class="si">}</span><span class="se">\n</span><span class="s1">&#39;</span>
            <span class="p">)</span>

    <span class="k">if</span> <span class="n">ok</span><span class="p">:</span>
        <span class="n">message</span> <span class="o">=</span> <span class="s1">&#39;The nested logit model is based on a partition. &#39;</span>

    <span class="k">return</span> <span class="n">ok</span><span class="p">,</span> <span class="n">message</span></div>


<div class="viewcode-block" id="checkValidityCNL"><a class="viewcode-back" href="../../models.html#biogeme.models.checkValidityCNL">[docs]</a><span class="k">def</span> <span class="nf">checkValidityCNL</span><span class="p">(</span><span class="n">V</span><span class="p">,</span> <span class="n">nests</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Verifies if the cross-nested logit specifciation is valid</span>

<span class="sd">    :param V: dict of objects representing the utility functions of</span>
<span class="sd">              each alternative, indexed by numerical ids.</span>
<span class="sd">    :type V: dict(int:biogeme.expressions.expr.Expression)</span>

<span class="sd">    :param nests: a tuple containing as many items as nests.</span>
<span class="sd">        Each item is also a tuple containing two items</span>

<span class="sd">        - an object of type biogeme.expressions.expr.Expression  representing</span>
<span class="sd">          the nest parameter,</span>
<span class="sd">        - a dictionary mapping the alternative ids with the cross-nested</span>
<span class="sd">          parameters for the corresponding nest. If an alternative is</span>
<span class="sd">          missing in the dictionary, the corresponding alpha is set to zero.</span>

<span class="sd">        Example::</span>

<span class="sd">            alphaA = {1: alpha1a,</span>
<span class="sd">                      2: alpha2a,</span>
<span class="sd">                      3: alpha3a,</span>
<span class="sd">                      4: alpha4a,</span>
<span class="sd">                      5: alpha5a,</span>
<span class="sd">                      6: alpha6a}</span>
<span class="sd">            alphaB = {1: alpha1b,</span>
<span class="sd">                      2: alpha2b,</span>
<span class="sd">                      3: alpha3b,</span>
<span class="sd">                      4: alpha4b,</span>
<span class="sd">                      5: alpha5b,</span>
<span class="sd">                      6: alpha6b}</span>
<span class="sd">            nesta = MUA, alphaA</span>
<span class="sd">            nestb = MUB, alphaB</span>
<span class="sd">            nests = nesta, nestb</span>

<span class="sd">    :type nests: tuple</span>

<span class="sd">    :return: a tuple ok, message, where the message explains the</span>
<span class="sd">             problem is the nested structure is not OK.</span>
<span class="sd">    :rtype: tuple(bool, str)</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">ok</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="n">message</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span>

    <span class="n">alt</span> <span class="o">=</span> <span class="p">{</span><span class="n">i</span><span class="p">:</span> <span class="p">[]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">V</span><span class="p">}</span>
    <span class="n">number</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">mu</span><span class="p">,</span> <span class="n">alpha</span> <span class="ow">in</span> <span class="n">nests</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">alpha</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">a</span> <span class="o">!=</span> <span class="mf">0.0</span><span class="p">:</span>
                <span class="n">alt</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
        <span class="n">number</span> <span class="o">+=</span> <span class="mi">1</span>

    <span class="n">problems_zero</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">problems_one</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">ell</span> <span class="ow">in</span> <span class="n">alt</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">ell</span><span class="p">:</span>
            <span class="n">problems_zero</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
            <span class="n">ok</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">ell</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">ell</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">expr</span><span class="o">.</span><span class="n">Expression</span><span class="p">):</span>
            <span class="n">problems_one</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">problems_zero</span><span class="p">:</span>
        <span class="n">message</span> <span class="o">+=</span> <span class="sa">f</span><span class="s1">&#39;Alternative(s) not in any nest: </span><span class="si">{</span><span class="n">problems_zero</span><span class="si">}</span><span class="s1">&#39;</span>

    <span class="k">if</span> <span class="n">problems_one</span><span class="p">:</span>
        <span class="n">message</span> <span class="o">+=</span> <span class="p">(</span>
            <span class="sa">f</span><span class="s1">&#39; Alternative in exactly one nest, &#39;</span>
            <span class="sa">f</span><span class="s1">&#39;and parameter alpha is defined by an &#39;</span>
            <span class="sa">f</span><span class="s1">&#39;expression, and may not be constant: </span><span class="si">{</span><span class="n">problems_one</span><span class="si">}</span><span class="s1">&#39;</span>
        <span class="p">)</span>

    <span class="k">return</span> <span class="n">ok</span><span class="p">,</span> <span class="n">message</span></div>
</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2022, Michel Bierlaire.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>