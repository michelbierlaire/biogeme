<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>biogeme.algorithms &mdash; Biogeme 3.2.9 documentation</title>
      <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="../../" id="documentation_options" src="../../_static/documentation_options.js"></script>
        <script src="../../_static/jquery.js"></script>
        <script src="../../_static/underscore.js"></script>
        <script src="../../_static/_sphinx_javascript_frameworks_compat.js"></script>
        <script src="../../_static/doctools.js"></script>
    <script src="../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="../../index.html" class="icon icon-home"> Biogeme
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../algorithms.html">Algorithms</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../assisted.html">Assisted specification</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../biogeme.html">Biogeme</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../database.html">Database</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../distributions.html">Distributions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../draws.html">Draws</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../exceptions.html">Exceptions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../expressions.html">Expressions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../filenames.html">Filenames</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../idmanager.html">ID manager</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../loglikelihood.html">Log likelihood</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../messaging.html">Messaging</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../models.html">Models</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../optimization.html">Optimization</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../results.html">Results</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../segmentation.html">Segmentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../singleton.html">Singleton</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../tools.html">Tools</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../version.html">Version</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../vns.html">Variable Neighborhood Search</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">Biogeme</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../index.html" class="icon icon-home"></a> &raquo;</li>
          <li><a href="../index.html">Module code</a> &raquo;</li>
      <li>biogeme.algorithms</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for biogeme.algorithms</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Optimization algorithms.</span>

<span class="sd">:author: Michel Bierlaire</span>
<span class="sd">:date: Sun Apr  5 16:48:54 2020</span>

<span class="sd">&quot;&quot;&quot;</span>

<span class="c1"># There seems to be a bug in PyLint.</span>
<span class="c1"># pylint: disable=invalid-unary-operand-type, no-member</span>

<span class="c1"># Too constraining</span>
<span class="c1"># pylint: disable=invalid-name</span>
<span class="c1"># pylint: disable=too-many-lines, too-many-locals</span>
<span class="c1"># pylint: disable=too-many-arguments, too-many-branches</span>
<span class="c1"># pylint: disable=too-many-statements, too-many-return-statements</span>
<span class="c1"># pylint: disable=bare-except</span>


<span class="kn">from</span> <span class="nn">abc</span> <span class="kn">import</span> <span class="n">abstractmethod</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">scipy.linalg</span> <span class="k">as</span> <span class="nn">la</span>
<span class="kn">import</span> <span class="nn">biogeme.exceptions</span> <span class="k">as</span> <span class="nn">excep</span>
<span class="kn">import</span> <span class="nn">biogeme.messaging</span> <span class="k">as</span> <span class="nn">msg</span>


<span class="n">logger</span> <span class="o">=</span> <span class="n">msg</span><span class="o">.</span><span class="n">bioMessage</span><span class="p">()</span>


<div class="viewcode-block" id="functionToMinimize"><a class="viewcode-back" href="../../algorithms.html#biogeme.algorithms.functionToMinimize">[docs]</a><span class="k">class</span> <span class="nc">functionToMinimize</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;This is an abstract class. The actual function to minimize</span>
<span class="sd">    must be implemented in a concrete class deriving from this one.</span>

<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="functionToMinimize.setVariables"><a class="viewcode-back" href="../../algorithms.html#biogeme.algorithms.functionToMinimize.setVariables">[docs]</a>    <span class="nd">@abstractmethod</span>
    <span class="k">def</span> <span class="nf">setVariables</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>

        <span class="sd">&quot;&quot;&quot;Set the values of the variables for which the function</span>
<span class="sd">        has to be calculated.</span>

<span class="sd">        :param x: values</span>
<span class="sd">        :type x: numpy.array</span>
<span class="sd">        &quot;&quot;&quot;</span></div>

<div class="viewcode-block" id="functionToMinimize.f"><a class="viewcode-back" href="../../algorithms.html#biogeme.algorithms.functionToMinimize.f">[docs]</a>    <span class="nd">@abstractmethod</span>
    <span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">batch</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Calculate the value of the function</span>

<span class="sd">        :param batch: for data driven functions (such as a log</span>
<span class="sd">                      likelikood function), it is possible to</span>
<span class="sd">                      approximate the value of the function using a</span>
<span class="sd">                      sample of the data called a batch. This argument</span>
<span class="sd">                      is a value between 0 and 1 representing the</span>
<span class="sd">                      percentage of the data that should be used for</span>
<span class="sd">                      thre random batch. If None, the full data set is</span>
<span class="sd">                      used. Default: None pass</span>
<span class="sd">        :type batch: float</span>

<span class="sd">        :return: value of the function</span>
<span class="sd">        :rtype: float</span>
<span class="sd">        &quot;&quot;&quot;</span></div>

<div class="viewcode-block" id="functionToMinimize.f_g"><a class="viewcode-back" href="../../algorithms.html#biogeme.algorithms.functionToMinimize.f_g">[docs]</a>    <span class="nd">@abstractmethod</span>
    <span class="k">def</span> <span class="nf">f_g</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">batch</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Calculate the value of the function and the gradient</span>

<span class="sd">        :param batch: for data driven functions (such as a log</span>
<span class="sd">                      likelikood function), it is possible to</span>
<span class="sd">                      approximate the value of the function using a</span>
<span class="sd">                      sample of the data called a batch. This argument</span>
<span class="sd">                      is a value between 0 and 1 representing the</span>
<span class="sd">                      percentage of the data that should be used for</span>
<span class="sd">                      the random batch. If None, the full data set is</span>
<span class="sd">                      used. Default: None pass</span>
<span class="sd">        :type batch: float</span>

<span class="sd">        :return: value of the function and the gradient</span>
<span class="sd">        :rtype: tuple float, numpy.array</span>
<span class="sd">        &quot;&quot;&quot;</span></div>

<div class="viewcode-block" id="functionToMinimize.f_g_h"><a class="viewcode-back" href="../../algorithms.html#biogeme.algorithms.functionToMinimize.f_g_h">[docs]</a>    <span class="nd">@abstractmethod</span>
    <span class="k">def</span> <span class="nf">f_g_h</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">batch</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Calculate the value of the function, the gradient and the Hessian</span>

<span class="sd">        :param batch: for data driven functions (such as a log</span>
<span class="sd">                      likelikood function), it is possible to</span>
<span class="sd">                      approximate the value of the function using a</span>
<span class="sd">                      sample of the data called a batch. This argument</span>
<span class="sd">                      is a value between 0 and 1 representing the</span>
<span class="sd">                      percentage of the data that should be used for</span>
<span class="sd">                      the random batch. If None, the full data set is</span>
<span class="sd">                      used. Default: None pass</span>
<span class="sd">        :type batch: float</span>

<span class="sd">        :return: value of the function, the gradient and the Hessian</span>
<span class="sd">        :rtype: tuple float, numpy.array, numpy.array</span>
<span class="sd">        &quot;&quot;&quot;</span></div>

<div class="viewcode-block" id="functionToMinimize.f_g_bhhh"><a class="viewcode-back" href="../../algorithms.html#biogeme.algorithms.functionToMinimize.f_g_bhhh">[docs]</a>    <span class="nd">@abstractmethod</span>
    <span class="k">def</span> <span class="nf">f_g_bhhh</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">batch</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Calculate the value of the function, the gradient and</span>
<span class="sd">        the BHHH matrix</span>

<span class="sd">        :param batch: for data driven functions (such as a log</span>
<span class="sd">                      likelikood function), it is possible to</span>
<span class="sd">                      approximate the value of the function using a</span>
<span class="sd">                      sample of the data called a batch. This argument</span>
<span class="sd">                      is a value between 0 and 1 representing the</span>
<span class="sd">                      percentage of the data that should be used for</span>
<span class="sd">                      the random batch. If None, the full data set is</span>
<span class="sd">                      used. Default: None pass</span>
<span class="sd">        :type batch: float</span>

<span class="sd">        :return: value of the function, the gradient and the BHHH</span>
<span class="sd">        :rtype: tuple float, numpy.array, numpy.array</span>
<span class="sd">        &quot;&quot;&quot;</span></div></div>


<div class="viewcode-block" id="bioBounds"><a class="viewcode-back" href="../../algorithms.html#biogeme.algorithms.bioBounds">[docs]</a><span class="k">class</span> <span class="nc">bioBounds</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;This class is designed for the management of simple bound constraints&quot;&quot;&quot;</span>

<div class="viewcode-block" id="bioBounds.__init__"><a class="viewcode-back" href="../../algorithms.html#biogeme.algorithms.bioBounds.__init__">[docs]</a>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>

<span class="sd">        :param b: list of tuples (ell,u) containing the lower and</span>
<span class="sd">                  upper bounds for each free parameter.</span>

<span class="sd">        :type b: list(tuple)</span>

<span class="sd">        :raises biogeme.exceptions.biogemeError: if the bounds are incompatible</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">def</span> <span class="nf">noneToMinusInfinity</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">x</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">return</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span>

            <span class="k">return</span> <span class="n">x</span>

        <span class="k">def</span> <span class="nf">noneToPlusInfinity</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">x</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span>

            <span class="k">return</span> <span class="n">x</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">bounds</span> <span class="o">=</span> <span class="n">b</span>
        <span class="sd">&quot;&quot;&quot;list of tuples (ell,u) containing the lower and upper bounds for</span>
<span class="sd">        each free parameter.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>  <span class="c1">#: number of optimization variables</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">lowerBounds</span> <span class="o">=</span> <span class="p">[</span><span class="n">noneToMinusInfinity</span><span class="p">(</span><span class="n">bb</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="k">for</span> <span class="n">bb</span> <span class="ow">in</span> <span class="n">b</span><span class="p">]</span>
        <span class="sd">&quot;&quot;&quot; List of lower bounds &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">upperBounds</span> <span class="o">=</span> <span class="p">[</span><span class="n">noneToPlusInfinity</span><span class="p">(</span><span class="n">bb</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="k">for</span> <span class="n">bb</span> <span class="ow">in</span> <span class="n">b</span><span class="p">]</span>
        <span class="sd">&quot;&quot;&quot; List of upper bounds &quot;&quot;&quot;</span>

        <span class="n">wrongBounds</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
            <span class="p">[</span>
                <span class="n">bb</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">bb</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                <span class="k">for</span> <span class="n">bb</span> <span class="ow">in</span> <span class="n">b</span>
                <span class="k">if</span> <span class="n">bb</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">bb</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
            <span class="p">]</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="n">wrongBounds</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
            <span class="n">errorMsg</span> <span class="o">=</span> <span class="p">(</span>
                <span class="sa">f</span><span class="s1">&#39;Incompatible bounds for indice(s) &#39;</span>
                <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">np</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span><span class="n">wrongBounds</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s1">: &#39;</span>
                <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="p">[</span><span class="n">b</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span><span class="n">wrongBounds</span><span class="p">)[</span><span class="mi">0</span><span class="p">]]</span><span class="si">}</span><span class="s1">&#39;</span>
            <span class="p">)</span>
            <span class="k">raise</span> <span class="n">excep</span><span class="o">.</span><span class="n">biogemeError</span><span class="p">(</span><span class="n">errorMsg</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">bounds</span><span class="o">.</span><span class="fm">__str__</span><span class="p">()</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">bounds</span><span class="o">.</span><span class="fm">__repr__</span><span class="p">()</span>

<div class="viewcode-block" id="bioBounds.project"><a class="viewcode-back" href="../../algorithms.html#biogeme.algorithms.bioBounds.project">[docs]</a>    <span class="k">def</span> <span class="nf">project</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>

        <span class="sd">&quot;&quot;&quot;Project a point onto the feasible domain defined by the bounds.</span>

<span class="sd">        :param x: point to project</span>
<span class="sd">        :type x: numpy.array</span>


<span class="sd">        :return: projected point</span>
<span class="sd">        :rtype: numpy.array</span>

<span class="sd">        :raises biogeme.exceptions.biogemeError: if the dimensions</span>
<span class="sd">                are inconsistent</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">excep</span><span class="o">.</span><span class="n">biogemeError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s1">&#39;Incompatible size: </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="si">}</span><span class="s1">&#39;</span> <span class="sa">f</span><span class="s1">&#39; and </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="si">}</span><span class="s1">&#39;</span>
            <span class="p">)</span>

        <span class="n">y</span> <span class="o">=</span> <span class="n">x</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">):</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">lowerBounds</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">lowerBounds</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
                <span class="n">y</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">lowerBounds</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">upperBounds</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">upperBounds</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
                <span class="n">y</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">upperBounds</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">y</span></div>

<div class="viewcode-block" id="bioBounds.intersect"><a class="viewcode-back" href="../../algorithms.html#biogeme.algorithms.bioBounds.intersect">[docs]</a>    <span class="k">def</span> <span class="nf">intersect</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">otherBounds</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create a bounds object representing the intersection of two regions.</span>

<span class="sd">        :param otherBounds: other bound object that must be intersected.</span>
<span class="sd">        :type otherBounds: class bioBounds</span>

<span class="sd">        :return:  bound object, intersection of the two.</span>
<span class="sd">        :rtype: class bioBounds</span>

<span class="sd">        :raises biogeme.exceptions.biogemeError: if the dimensions</span>
<span class="sd">              are inconsistent</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">otherBounds</span><span class="o">.</span><span class="n">n</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">excep</span><span class="o">.</span><span class="n">biogemeError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s1">&#39;Incompatible size: </span><span class="si">{</span><span class="n">otherBounds</span><span class="o">.</span><span class="n">n</span><span class="si">}</span><span class="s1"> &#39;</span> <span class="sa">f</span><span class="s1">&#39;and </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="si">}</span><span class="s1">&#39;</span>
            <span class="p">)</span>

        <span class="n">newBounds</span> <span class="o">=</span> <span class="p">[</span>
            <span class="p">(</span>
                <span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lowerBounds</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">otherBounds</span><span class="o">.</span><span class="n">lowerBounds</span><span class="p">[</span><span class="n">i</span><span class="p">]),</span>
                <span class="n">np</span><span class="o">.</span><span class="n">minimum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">upperBounds</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">otherBounds</span><span class="o">.</span><span class="n">upperBounds</span><span class="p">[</span><span class="n">i</span><span class="p">]),</span>
            <span class="p">)</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">)</span>
        <span class="p">]</span>

        <span class="c1"># Note that an exception with be raised at the creation of the</span>
        <span class="c1"># new &#39;bioBounds&#39; object is the bounds are incompatible.</span>

        <span class="n">result</span> <span class="o">=</span> <span class="n">bioBounds</span><span class="p">(</span><span class="n">newBounds</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">result</span></div>

<div class="viewcode-block" id="bioBounds.intersectionWithTrustRegion"><a class="viewcode-back" href="../../algorithms.html#biogeme.algorithms.bioBounds.intersectionWithTrustRegion">[docs]</a>    <span class="k">def</span> <span class="nf">intersectionWithTrustRegion</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">delta</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Create a bioBounds object representing the intersection</span>
<span class="sd">        between the feasible domain and the trust region.</span>

<span class="sd">        :param x: center of the trust region</span>
<span class="sd">        :type x: numpy.array</span>

<span class="sd">        :param delta: radius of the tust region (infinity norm)</span>
<span class="sd">        :type delta: float</span>

<span class="sd">        :return: intersection between the feasible region and the trus region</span>
<span class="sd">        :rtype: class bioBounds</span>

<span class="sd">        :raises biogeme.exceptions.biogemeError: if the dimensions</span>
<span class="sd">                are inconsistent</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">excep</span><span class="o">.</span><span class="n">biogemeError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s1">&#39;Incompatible size: </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="si">}</span><span class="s1">&#39;</span> <span class="sa">f</span><span class="s1">&#39; and </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="si">}</span><span class="s1">&#39;</span>
            <span class="p">)</span>

        <span class="n">trustRegion</span> <span class="o">=</span> <span class="n">bioBounds</span><span class="p">([(</span><span class="n">xk</span> <span class="o">-</span> <span class="n">delta</span><span class="p">,</span> <span class="n">xk</span> <span class="o">+</span> <span class="n">delta</span><span class="p">)</span> <span class="k">for</span> <span class="n">xk</span> <span class="ow">in</span> <span class="n">x</span><span class="p">])</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">intersect</span><span class="p">(</span><span class="n">trustRegion</span><span class="p">)</span></div>

<div class="viewcode-block" id="bioBounds.subspace"><a class="viewcode-back" href="../../algorithms.html#biogeme.algorithms.bioBounds.subspace">[docs]</a>    <span class="k">def</span> <span class="nf">subspace</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">selectedVariables</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Generate a bioBounds object for selected variables</span>

<span class="sd">        :param selectedVariables: boolean vector. If an entry is True,</span>
<span class="sd">                   the corresponding variables is considered.</span>
<span class="sd">        :type selectedVariables: numpy.array(bool)</span>

<span class="sd">        :return: bound object</span>
<span class="sd">        :rtype: class bioBounds</span>

<span class="sd">        :raises biogeme.exceptions.biogemeError: if the dimensions</span>
<span class="sd">                are inconsistent</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">selectedVariables</span><span class="p">)</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">excep</span><span class="o">.</span><span class="n">biogemeError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s1">&#39;Incompatible size: &#39;</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">selectedVariables</span><span class="p">)</span><span class="si">}</span><span class="s1"> and </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="si">}</span><span class="s1">&#39;</span>
            <span class="p">)</span>

        <span class="k">return</span> <span class="n">bioBounds</span><span class="p">(</span>
            <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">bounds</span><span class="p">,</span> <span class="n">selectedVariables</span><span class="p">)</span> <span class="k">if</span> <span class="n">j</span><span class="p">]</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="bioBounds.feasible"><a class="viewcode-back" href="../../algorithms.html#biogeme.algorithms.bioBounds.feasible">[docs]</a>    <span class="k">def</span> <span class="nf">feasible</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Check if point verifies the bound constraints</span>

<span class="sd">        :param x: point to project</span>
<span class="sd">        :type x: numpy.array</span>

<span class="sd">        :return: True if x is feasible, False otherwise.</span>
<span class="sd">        :rtype: bool</span>

<span class="sd">        :raises biogeme.exceptions.biogemeError: if the dimensions</span>
<span class="sd">                 are inconsistent</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">excep</span><span class="o">.</span><span class="n">biogemeError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s1">&#39;Incompatible size: &#39;</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="si">}</span><span class="s1"> and </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="si">}</span><span class="s1">&#39;</span>
            <span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">):</span>
            <span class="k">if</span> <span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">lowerBounds</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
                <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">lowerBounds</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">finfo</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span><span class="o">.</span><span class="n">eps</span>
            <span class="p">):</span>
                <span class="k">return</span> <span class="kc">False</span>
            <span class="k">if</span> <span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">upperBounds</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
                <span class="ow">and</span> <span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">upperBounds</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">finfo</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span><span class="o">.</span><span class="n">eps</span>
            <span class="p">):</span>
                <span class="k">return</span> <span class="kc">False</span>
        <span class="k">return</span> <span class="kc">True</span></div>

<div class="viewcode-block" id="bioBounds.maximumStep"><a class="viewcode-back" href="../../algorithms.html#biogeme.algorithms.bioBounds.maximumStep">[docs]</a>    <span class="k">def</span> <span class="nf">maximumStep</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">d</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Calculates the maximum step that can be performed</span>
<span class="sd">        along a direction while staying feasible.</span>

<span class="sd">        :param x: reference point</span>
<span class="sd">        :type x: numpy.array</span>

<span class="sd">        :param d: direction</span>
<span class="sd">        :type d: numpy.array</span>

<span class="sd">        :return: the largest alpha such that x + alpha * d is feasible</span>
<span class="sd">                 and the list of indices achieving this value.</span>
<span class="sd">        :rtype: float, int</span>

<span class="sd">        :raises biogeme.exceptions.biogemeError: if the point is infeasible</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">feasible</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
            <span class="k">raise</span> <span class="n">excep</span><span class="o">.</span><span class="n">biogemeError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Infeasible point: </span><span class="si">{</span><span class="n">x</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>

        <span class="n">alpha</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
            <span class="p">[</span>
                <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">upperBounds</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">/</span> <span class="n">d</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">d</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">finfo</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span><span class="o">.</span><span class="n">eps</span>
                <span class="k">else</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lowerBounds</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">/</span> <span class="n">d</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">d</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">finfo</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span><span class="o">.</span><span class="n">eps</span>
                <span class="k">else</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">)</span>
            <span class="p">]</span>
        <span class="p">)</span>
        <span class="n">m</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">amin</span><span class="p">(</span><span class="n">alpha</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">m</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">alpha</span> <span class="o">==</span> <span class="n">m</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span></div>

<div class="viewcode-block" id="bioBounds.activity"><a class="viewcode-back" href="../../algorithms.html#biogeme.algorithms.bioBounds.activity">[docs]</a>    <span class="k">def</span> <span class="nf">activity</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">epsilon</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">finfo</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span><span class="o">.</span><span class="n">eps</span><span class="p">):</span>

        <span class="sd">&quot;&quot;&quot;Determines the activity status of each variable.</span>

<span class="sd">        :param x: point for which the activity must be determined.</span>
<span class="sd">        :type x: numpy.array</span>

<span class="sd">        :param epsilon: a bound is considered active if the distance</span>
<span class="sd">                        to it is less rhan epsilon.</span>
<span class="sd">        :type epsilon: float</span>

<span class="sd">        :return: a vector, same length as x, where each entry reports</span>
<span class="sd">            the activity of the corresponding variable:</span>

<span class="sd">            - 0 if no bound is active</span>
<span class="sd">            - -1 if the lower bound is active</span>
<span class="sd">            - 1 if the upper bound is active</span>

<span class="sd">        :rtype: numpy.array</span>

<span class="sd">        :raises biogeme.exceptions.biogemeError: if the vector x is</span>
<span class="sd">                    not feasible</span>

<span class="sd">        :raises biogeme.exceptions.biogemeError: if the dimensions</span>
<span class="sd">                    of x and bounds do not match.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">excep</span><span class="o">.</span><span class="n">biogemeError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s1">&#39;Incompatible size: </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="si">}</span><span class="s1">&#39;</span> <span class="sa">f</span><span class="s1">&#39; and </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="si">}</span><span class="s1">&#39;</span>
            <span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">feasible</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
            <span class="k">raise</span> <span class="n">excep</span><span class="o">.</span><span class="n">biogemeError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">x</span><span class="si">}</span><span class="s1"> is not feasible for the &#39;</span> <span class="sa">f</span><span class="s1">&#39;bounds </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">bounds</span><span class="si">}</span><span class="s1">&#39;</span>
            <span class="p">)</span>

        <span class="n">activity</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">):</span>
            <span class="k">if</span> <span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">lowerBounds</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">!=</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span>
                <span class="ow">and</span> <span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">lowerBounds</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">epsilon</span>
            <span class="p">):</span>
                <span class="n">activity</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
            <span class="k">elif</span> <span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">upperBounds</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">!=</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span>
                <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">upperBounds</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">epsilon</span>
            <span class="p">):</span>
                <span class="n">activity</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">return</span> <span class="n">activity</span></div>

<div class="viewcode-block" id="bioBounds.breakpoints"><a class="viewcode-back" href="../../algorithms.html#biogeme.algorithms.bioBounds.breakpoints">[docs]</a>    <span class="k">def</span> <span class="nf">breakpoints</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">d</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Projects the direction d, starting from x,</span>
<span class="sd">        on the intersection of the bound constraints</span>

<span class="sd">        :param x: current point</span>
<span class="sd">        :type x: numpy.array</span>

<span class="sd">        :param d: search direction</span>
<span class="sd">        :type d: numpy.array</span>

<span class="sd">        :return: list of tuple (index, value), where index is the index</span>
<span class="sd">                 of the variable, and value the value of the corresponding</span>
<span class="sd">                 breakpoint.</span>
<span class="sd">        :rtype: list(tuple(int,float))</span>

<span class="sd">        :raises biogeme.exceptions.biogemeError: if the dimensions</span>
<span class="sd">                are inconsistent</span>

<span class="sd">        :raises biogeme.exceptions.biogemeError: if x is infeasible</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">d</span><span class="p">)</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">excep</span><span class="o">.</span><span class="n">biogemeError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s1">&#39;Incompatible size: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="si">}</span><span class="s1">&#39;</span> <span class="sa">f</span><span class="s1">&#39; and </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">d</span><span class="p">)</span><span class="si">}</span><span class="s1">&#39;</span>
            <span class="p">)</span>
        <span class="n">bp</span> <span class="o">=</span> <span class="p">[</span>
            <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">upperBounds</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">/</span> <span class="n">d</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">d</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">finfo</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span><span class="o">.</span><span class="n">eps</span>
            <span class="k">else</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lowerBounds</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">/</span> <span class="n">d</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">d</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">finfo</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span><span class="o">.</span><span class="n">eps</span>
            <span class="k">else</span> <span class="mi">0</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">)</span>
        <span class="p">]</span>

        <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">b</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">bp</span><span class="p">):</span>
            <span class="k">raise</span> <span class="n">excep</span><span class="o">.</span><span class="n">biogemeError</span><span class="p">(</span><span class="s1">&#39;Infeasible point&#39;</span><span class="p">)</span>

        <span class="k">return</span> <span class="nb">sorted</span><span class="p">(</span><span class="nb">enumerate</span><span class="p">(</span><span class="n">bp</span><span class="p">),</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span></div>

<div class="viewcode-block" id="bioBounds.generalizedCauchyPoint"><a class="viewcode-back" href="../../algorithms.html#biogeme.algorithms.bioBounds.generalizedCauchyPoint">[docs]</a>    <span class="k">def</span> <span class="nf">generalizedCauchyPoint</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">xk</span><span class="p">,</span> <span class="n">gk</span><span class="p">,</span> <span class="n">H</span><span class="p">,</span> <span class="n">direction</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Implementation of Step 2 of the Specific Algorithm by</span>
<span class="sd">        `Conn et al. (1988)`_.</span>

<span class="sd">        .. _`Conn et al. (1988)`: https://www.ams.org/journals/mcom/1988-50-182/S0025-5718-1988-0929544-3/S0025-5718-1988-0929544-3.pdf</span>

<span class="sd">        The quadratic model is defined as</span>

<span class="sd">        .. math:: m(x) = f(x_k) + (x - x_k)^T g_k +</span>
<span class="sd">                  \\frac{1}{2} (x-x_k)^T H (x-x_k).</span>

<span class="sd">        :param xk: current point</span>
<span class="sd">        :type xk: numpy.array. Dimension n.</span>

<span class="sd">        :param gk: vector g involved in the quadratic model definition.</span>
<span class="sd">        :type gk: numpy.array. Dimension n.</span>

<span class="sd">        :param H: matrix H involved in the quadratic model definition.</span>
<span class="sd">        :type H: numpy.array. Dimension n x n.</span>

<span class="sd">        :param direction: direction along which the GCP is searched.</span>
<span class="sd">        :type direction: numpy.array. Dimension n.</span>

<span class="sd">        :return: generalized Cauchy point based on inexact line search.</span>
<span class="sd">        :rtype: numpy.array. Dimension n.</span>

<span class="sd">        :raises biogeme.exceptions.biogemeError: if the dimensions are</span>
<span class="sd">               inconsistent</span>
<span class="sd">        :raises biogeme.exceptions.biogemeError: if xk is infeasible</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">xk</span><span class="p">)</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">excep</span><span class="o">.</span><span class="n">biogemeError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s1">&#39;Incompatible size: </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">xk</span><span class="p">)</span><span class="si">}</span><span class="s1">&#39;</span> <span class="sa">f</span><span class="s1">&#39; and </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="si">}</span><span class="s1">&#39;</span>
            <span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">gk</span><span class="p">)</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">excep</span><span class="o">.</span><span class="n">biogemeError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s1">&#39;Incompatible size: </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">gk</span><span class="p">)</span><span class="si">}</span><span class="s1">&#39;</span> <span class="sa">f</span><span class="s1">&#39; and </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="si">}</span><span class="s1">&#39;</span>
            <span class="p">)</span>
        <span class="k">if</span> <span class="n">H</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">n</span> <span class="ow">or</span> <span class="n">H</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">excep</span><span class="o">.</span><span class="n">biogemeError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s1">&#39;Incompatible size: </span><span class="si">{</span><span class="n">H</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s1">&#39;</span> <span class="sa">f</span><span class="s1">&#39; and </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="si">}</span><span class="s1">&#39;</span>
            <span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">feasible</span><span class="p">(</span><span class="n">xk</span><span class="p">):</span>
            <span class="k">raise</span> <span class="n">excep</span><span class="o">.</span><span class="n">biogemeError</span><span class="p">(</span><span class="s1">&#39;Infeasible iterate&#39;</span><span class="p">)</span>

        <span class="n">x</span> <span class="o">=</span> <span class="n">xk</span>
        <span class="n">g</span> <span class="o">=</span> <span class="n">gk</span> <span class="o">-</span> <span class="n">H</span> <span class="o">@</span> <span class="n">xk</span>
        <span class="n">d</span> <span class="o">=</span> <span class="n">direction</span>

        <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">xk</span><span class="p">)</span>

        <span class="n">J</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>

        <span class="n">fprime</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">inner</span><span class="p">(</span><span class="n">gk</span><span class="p">,</span> <span class="n">d</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">fprime</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">n</span> <span class="o">&lt;=</span> <span class="mi">10</span><span class="p">:</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s1">&#39;GCP: direction </span><span class="si">{</span><span class="n">d</span><span class="si">}</span><span class="s1"> is not a descent &#39;</span>
                    <span class="sa">f</span><span class="s1">&#39;direction at </span><span class="si">{</span><span class="n">x</span><span class="si">}</span><span class="s1">.&#39;</span>
                <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s1">&#39;GCP: not a descent direction.&#39;</span><span class="p">)</span>

        <span class="n">fsecond</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">inner</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">H</span> <span class="o">@</span> <span class="n">d</span><span class="p">)</span>

        <span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="n">J</span><span class="p">)</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">:</span>
            <span class="n">delta_t</span><span class="p">,</span> <span class="n">ind</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">maximumStep</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">d</span><span class="p">)</span>
            <span class="c1"># J is the set of active variables</span>
            <span class="n">J</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">ind</span><span class="p">)</span>

            <span class="c1"># Test whether the GCP has been found</span>
            <span class="n">ratio</span> <span class="o">=</span> <span class="o">-</span><span class="n">fprime</span> <span class="o">/</span> <span class="n">fsecond</span>
            <span class="k">if</span> <span class="n">fsecond</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="mi">0</span> <span class="o">&lt;</span> <span class="n">ratio</span> <span class="o">&lt;</span> <span class="n">delta_t</span><span class="p">:</span>
                <span class="n">x</span> <span class="o">=</span> <span class="n">x</span> <span class="o">+</span> <span class="n">ratio</span> <span class="o">*</span> <span class="n">d</span>
                <span class="k">return</span> <span class="n">x</span>

            <span class="c1"># Update line derivatives</span>
            <span class="n">bd</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>
            <span class="n">bd</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span> <span class="o">=</span> <span class="n">d</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span>
            <span class="n">b</span> <span class="o">=</span> <span class="n">H</span> <span class="o">@</span> <span class="n">bd</span>

            <span class="c1"># In theory, x + delta_t * d must be feasible. However,</span>
            <span class="c1"># there may be some numerical problem. Therefore, we</span>
            <span class="c1"># project it on the feasible domain to make sure to obtain</span>
            <span class="c1"># a feasible point.</span>
            <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">project</span><span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="n">delta_t</span> <span class="o">*</span> <span class="n">d</span><span class="p">)</span>

            <span class="n">dg</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">([</span><span class="n">d</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="n">g</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">ind</span><span class="p">])</span>
            <span class="n">fprime</span> <span class="o">+=</span> <span class="n">delta_t</span> <span class="o">*</span> <span class="n">fsecond</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">inner</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span> <span class="o">-</span> <span class="n">dg</span>
            <span class="n">fsecond</span> <span class="o">+=</span> <span class="n">np</span><span class="o">.</span><span class="n">inner</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">bd</span> <span class="o">-</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">d</span><span class="p">)</span>
            <span class="n">d</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0</span>

            <span class="k">if</span> <span class="n">fprime</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">x</span>

        <span class="k">return</span> <span class="n">x</span></div></div>


<div class="viewcode-block" id="schnabelEskow"><a class="viewcode-back" href="../../algorithms.html#biogeme.algorithms.schnabelEskow">[docs]</a><span class="k">def</span> <span class="nf">schnabelEskow</span><span class="p">(</span>
    <span class="n">A</span><span class="p">,</span>
    <span class="n">tau</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">finfo</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span><span class="o">.</span><span class="n">eps</span> <span class="o">**</span> <span class="mf">0.3333</span><span class="p">,</span>
    <span class="n">taubar</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">finfo</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span><span class="o">.</span><span class="n">eps</span> <span class="o">**</span> <span class="mf">0.6666</span><span class="p">,</span>
    <span class="n">mu</span><span class="o">=</span><span class="mf">0.1</span><span class="p">,</span>
<span class="p">):</span>

    <span class="sd">&quot;&quot;&quot;Modified Cholesky factorization by `Schnabel and Eskow (1999)`_.</span>

<span class="sd">    .. _`Schnabel and Eskow (1999)`: https://doi.org/10.1137/s105262349833266x</span>

<span class="sd">    If the matrix is &#39;safely&#39; positive definite, the output is the</span>
<span class="sd">    classical Cholesky factor. If not, the diagonal elements are</span>
<span class="sd">    inflated in order to make it positive definite. The factor :math:`L`</span>
<span class="sd">    is such that :math:`A + E = PLL^TP^T`, where :math:`E` is a diagonal</span>
<span class="sd">    matrix contaninig the terms added to the diagonal, :math:`P` is a</span>
<span class="sd">    permutation matrix, and :math:`L` is w lower triangular matrix.</span>

<span class="sd">    :param A: matrix to factorize. Must be square and symmetric.</span>
<span class="sd">    :type A: numpy.array</span>
<span class="sd">    :param tau: tolerance factor.</span>
<span class="sd">                Default: :math:`\\varepsilon^{\\frac{1}{3}}`.</span>
<span class="sd">                See `Schnabel and Eskow (1999)`_</span>
<span class="sd">    :type tau: float</span>
<span class="sd">    :param taubar: tolerance factor.</span>
<span class="sd">                   Default: :math:`\\varepsilon^{\\frac{2}{3}}`.</span>
<span class="sd">                   See `Schnabel and Eskow (1999)`_</span>
<span class="sd">    :type taubar: float</span>
<span class="sd">    :param mu: tolerance factor.</span>
<span class="sd">               Default: 0.1.  See `Schnabel and Eskow (1999)`_</span>
<span class="sd">    :type mu: float</span>

<span class="sd">    :return: tuple :math:`L`, :math:`E`, :math:`P`,</span>
<span class="sd">                    where :math:`A + E = PLL^TP^T`.</span>
<span class="sd">    :rtype: numpy.array, numpy.array, numpy.array</span>

<span class="sd">    :raises biogeme.exceptions.biogemeError: if the matrix A is not square.</span>
<span class="sd">    :raises biogeme.exceptions.biogemeError: if the matrix A is not symmetric.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">pivot</span><span class="p">(</span><span class="n">j</span><span class="p">):</span>
        <span class="n">A</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">A</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="n">j</span><span class="p">])</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">dim</span><span class="p">):</span>
            <span class="n">A</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">/</span> <span class="n">A</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span>
            <span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="o">+</span> <span class="mi">1</span> <span class="p">:</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">-=</span> <span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">*</span> <span class="n">A</span><span class="p">[</span><span class="n">j</span> <span class="o">+</span> <span class="mi">1</span> <span class="p">:</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span>
            <span class="n">A</span><span class="p">[</span><span class="n">j</span> <span class="o">+</span> <span class="mi">1</span> <span class="p">:</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="o">+</span> <span class="mi">1</span> <span class="p">:</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">permute</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">):</span>
        <span class="n">A</span><span class="p">[[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]]</span> <span class="o">=</span> <span class="n">A</span><span class="p">[[</span><span class="n">j</span><span class="p">,</span> <span class="n">i</span><span class="p">]]</span>
        <span class="n">E</span><span class="p">[[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]]</span> <span class="o">=</span> <span class="n">E</span><span class="p">[[</span><span class="n">j</span><span class="p">,</span> <span class="n">i</span><span class="p">]]</span>
        <span class="n">A</span><span class="p">[:,</span> <span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]]</span> <span class="o">=</span> <span class="n">A</span><span class="p">[:,</span> <span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="n">i</span><span class="p">]]</span>
        <span class="n">P</span><span class="p">[:,</span> <span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]]</span> <span class="o">=</span> <span class="n">P</span><span class="p">[:,</span> <span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="n">i</span><span class="p">]]</span>

    <span class="n">A</span> <span class="o">=</span> <span class="n">A</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
    <span class="n">dim</span> <span class="o">=</span> <span class="n">A</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">A</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="n">dim</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">excep</span><span class="o">.</span><span class="n">biogemeError</span><span class="p">(</span><span class="s1">&#39;The matrix must be square&#39;</span><span class="p">)</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">A</span> <span class="o">-</span> <span class="n">A</span><span class="o">.</span><span class="n">T</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">finfo</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span><span class="o">.</span><span class="n">eps</span><span class="p">)):</span>
        <span class="k">raise</span> <span class="n">excep</span><span class="o">.</span><span class="n">biogemeError</span><span class="p">(</span><span class="s1">&#39;The matrix must be symmetric&#39;</span><span class="p">)</span>

    <span class="n">E</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">dim</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
    <span class="n">P</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">identity</span><span class="p">(</span><span class="n">dim</span><span class="p">)</span>
    <span class="n">phaseOne</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="n">gamma</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">A</span><span class="o">.</span><span class="n">diagonal</span><span class="p">())</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>
    <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">while</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">dim</span> <span class="ow">and</span> <span class="n">phaseOne</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
        <span class="n">a_max</span> <span class="o">=</span> <span class="n">A</span><span class="o">.</span><span class="n">diagonal</span><span class="p">()[</span><span class="n">j</span><span class="p">:]</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>
        <span class="n">a_min</span> <span class="o">=</span> <span class="n">A</span><span class="o">.</span><span class="n">diagonal</span><span class="p">()[</span><span class="n">j</span><span class="p">:]</span><span class="o">.</span><span class="n">min</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">a_max</span> <span class="o">&lt;</span> <span class="n">taubar</span> <span class="o">*</span> <span class="n">gamma</span> <span class="ow">or</span> <span class="n">a_min</span> <span class="o">&lt;</span> <span class="o">-</span><span class="n">mu</span> <span class="o">*</span> <span class="n">a_max</span><span class="p">:</span>
            <span class="n">phaseOne</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="k">break</span>

        <span class="c1"># Pivot on maximum diagonal of remaining submatrix</span>
        <span class="n">i</span> <span class="o">=</span> <span class="n">j</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">A</span><span class="o">.</span><span class="n">diagonal</span><span class="p">()[</span><span class="n">j</span><span class="p">:])</span>
        <span class="k">if</span> <span class="n">i</span> <span class="o">!=</span> <span class="n">j</span><span class="p">:</span>
            <span class="c1"># Switch rows and columns of i and j of A</span>
            <span class="n">permute</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">dim</span> <span class="o">-</span> <span class="mi">1</span> <span class="ow">and</span> <span class="p">(</span>
            <span class="p">(</span>
                <span class="n">A</span><span class="o">.</span><span class="n">diagonal</span><span class="p">()[</span><span class="n">j</span> <span class="o">+</span> <span class="mi">1</span> <span class="p">:]</span> <span class="o">-</span> <span class="n">A</span><span class="p">[</span><span class="n">j</span> <span class="o">+</span> <span class="mi">1</span> <span class="p">:,</span> <span class="n">j</span><span class="p">]</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">/</span> <span class="n">A</span><span class="o">.</span><span class="n">diagonal</span><span class="p">()[</span><span class="n">j</span><span class="p">]</span>
            <span class="p">)</span><span class="o">.</span><span class="n">min</span><span class="p">()</span>
            <span class="o">&lt;</span> <span class="o">-</span><span class="n">mu</span> <span class="o">*</span> <span class="n">gamma</span>
        <span class="p">):</span>
            <span class="n">phaseOne</span> <span class="o">=</span> <span class="kc">False</span>  <span class="c1"># go to phase two</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># perform jth iteration of factorization</span>
            <span class="n">pivot</span><span class="p">(</span><span class="n">j</span><span class="p">)</span>
            <span class="n">j</span> <span class="o">+=</span> <span class="mi">1</span>

    <span class="c1"># Phase two, A not positive-definite</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">phaseOne</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">j</span> <span class="o">==</span> <span class="n">dim</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">E</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">delta</span> <span class="o">=</span> <span class="o">-</span><span class="n">A</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="nb">max</span><span class="p">(</span>
                <span class="n">tau</span> <span class="o">*</span> <span class="p">(</span><span class="o">-</span><span class="n">A</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="o">/</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">tau</span><span class="p">),</span> <span class="n">taubar</span> <span class="o">*</span> <span class="n">gamma</span>
            <span class="p">)</span>
            <span class="n">A</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+=</span> <span class="n">delta</span>
            <span class="n">A</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">A</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">deltaPrev</span> <span class="o">=</span> <span class="mf">0.0</span>
            <span class="n">g</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">dim</span><span class="p">)</span>
            <span class="n">k</span> <span class="o">=</span> <span class="n">j</span> <span class="o">-</span> <span class="mi">1</span>  <span class="c1"># k = number of iterations performed in phase one</span>
            <span class="c1"># Calculate lower Gerschgorin bounds of A[k+1]</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">k</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">dim</span><span class="p">):</span>
                <span class="n">g</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span>
                    <span class="o">-</span> <span class="nb">abs</span><span class="p">(</span><span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">k</span> <span class="o">+</span> <span class="mi">1</span> <span class="p">:</span> <span class="n">i</span><span class="p">])</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
                    <span class="o">-</span> <span class="nb">abs</span><span class="p">(</span><span class="n">A</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span> <span class="p">:</span> <span class="n">dim</span><span class="p">,</span> <span class="n">i</span><span class="p">])</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
                <span class="p">)</span>
            <span class="c1"># Modified Cholesky Decomposition</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">k</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">dim</span> <span class="o">-</span> <span class="mi">2</span><span class="p">):</span>
                <span class="c1"># Pivot on maximum lower Gerschgorin bound estimate</span>
                <span class="n">i</span> <span class="o">=</span> <span class="n">j</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">g</span><span class="p">[</span><span class="n">j</span><span class="p">:])</span>
                <span class="k">if</span> <span class="n">i</span> <span class="o">!=</span> <span class="n">j</span><span class="p">:</span>
                    <span class="c1"># Switch rows and columns of i and j of A</span>
                    <span class="n">permute</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">)</span>
                <span class="c1"># Calculate E[j, j] and add to diagonal</span>
                <span class="n">norm_j</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">A</span><span class="p">[</span><span class="n">j</span> <span class="o">+</span> <span class="mi">1</span> <span class="p">:</span> <span class="n">dim</span><span class="p">,</span> <span class="n">j</span><span class="p">])</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
                <span class="n">E</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">delta</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span>
                    <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="n">A</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">+</span> <span class="nb">max</span><span class="p">(</span><span class="n">norm_j</span><span class="p">,</span> <span class="n">taubar</span> <span class="o">*</span> <span class="n">gamma</span><span class="p">),</span> <span class="n">deltaPrev</span>
                <span class="p">)</span>
                <span class="k">if</span> <span class="n">delta</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">A</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">+=</span> <span class="n">delta</span>
                    <span class="n">deltaPrev</span> <span class="o">=</span> <span class="n">delta</span>  <span class="c1"># deltaPrev will contain E_inf</span>
                <span class="c1"># Update Gerschgorin bound estimates</span>
                <span class="k">if</span> <span class="n">A</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">!=</span> <span class="n">norm_j</span><span class="p">:</span>
                    <span class="n">temp</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">-</span> <span class="n">norm_j</span> <span class="o">/</span> <span class="n">A</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span>
                    <span class="n">g</span><span class="p">[</span><span class="n">j</span> <span class="o">+</span> <span class="mi">1</span> <span class="p">:]</span> <span class="o">+=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">A</span><span class="p">[</span><span class="n">j</span> <span class="o">+</span> <span class="mi">1</span> <span class="p">:,</span> <span class="n">j</span><span class="p">])</span> <span class="o">*</span> <span class="n">temp</span>
                <span class="c1"># perform jth iteration of factorization</span>
                <span class="n">pivot</span><span class="p">(</span><span class="n">j</span><span class="p">)</span>

            <span class="c1"># Final 2 by 2 submatrix</span>
            <span class="n">e</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">eigvalsh</span><span class="p">(</span><span class="n">A</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">:,</span> <span class="o">-</span><span class="mi">2</span><span class="p">:])</span>
            <span class="n">e</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>
            <span class="n">E</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">E</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">delta</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span>
                <span class="mi">0</span><span class="p">,</span>
                <span class="o">-</span><span class="n">e</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="nb">max</span><span class="p">(</span><span class="n">tau</span> <span class="o">*</span> <span class="p">(</span><span class="n">e</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">e</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">/</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">tau</span><span class="p">),</span> <span class="n">taubar</span> <span class="o">*</span> <span class="n">gamma</span><span class="p">),</span>
                <span class="n">deltaPrev</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="k">if</span> <span class="n">delta</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">A</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">]</span> <span class="o">+=</span> <span class="n">delta</span>
                <span class="n">A</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+=</span> <span class="n">delta</span>
                <span class="n">deltaPrev</span> <span class="o">=</span> <span class="n">delta</span>
            <span class="n">A</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">A</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">])</span>  <span class="c1"># overwrites A[-2, -2]</span>
            <span class="n">A</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">A</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">]</span> <span class="o">/</span> <span class="n">A</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">]</span>  <span class="c1"># overwrites A[-1, -2]</span>
            <span class="n">A</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">A</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">]</span>
            <span class="c1"># overwrites A[-1, -1]</span>
            <span class="n">A</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">A</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">A</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">]</span> <span class="o">*</span> <span class="n">A</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">])</span>

    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">tril</span><span class="p">(</span><span class="n">A</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">P</span> <span class="o">@</span> <span class="n">E</span><span class="p">),</span> <span class="n">P</span></div>


<div class="viewcode-block" id="lineSearch"><a class="viewcode-back" href="../../algorithms.html#biogeme.algorithms.lineSearch">[docs]</a><span class="k">def</span> <span class="nf">lineSearch</span><span class="p">(</span><span class="n">fct</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">g</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">alpha0</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">beta1</span><span class="o">=</span><span class="mf">1.0e-4</span><span class="p">,</span> <span class="n">beta2</span><span class="o">=</span><span class="mf">0.99</span><span class="p">,</span> <span class="n">lbd</span><span class="o">=</span><span class="mf">2.0</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculate a step along a direction that satisfies both Wolfe conditions</span>


<span class="sd">    :param fct: object to calculate the objective function and its derivatives.</span>
<span class="sd">    :type fct: optimization.functionToMinimize</span>

<span class="sd">    :param x: current iterate.</span>
<span class="sd">    :type x: numpy.array</span>

<span class="sd">    :param f: value of the objective function at the current iterate.</span>
<span class="sd">    :type f: float</span>

<span class="sd">    :param g: value of the gradient at the current iterate.</span>
<span class="sd">    :type g: numpy.array</span>

<span class="sd">    :param d: descent direction.</span>
<span class="sd">    :type d: numpy.array</span>

<span class="sd">    :param alpha0: first step to test.</span>
<span class="sd">    :type alpha0: float</span>

<span class="sd">    :param beta1: parameter of the first Wolfe condition.</span>
<span class="sd">    :type beta1: float</span>

<span class="sd">    :param beta2: parameter of the second Wolfe condition.</span>
<span class="sd">    :type beta2: float</span>

<span class="sd">    :param lbd: expansion factor for a short step.</span>
<span class="sd">    :type lbd: float</span>

<span class="sd">    :return: a step verifing both Wolfe conditions</span>
<span class="sd">    :rtype: float</span>

<span class="sd">    :raises biogeme.exceptions.biogemeError: if ``lbd`` :math:`\\leq` 1</span>
<span class="sd">    :raises biogeme.exceptions.biogemeError: if ``alpha0`` :math:`\\leq` 0</span>
<span class="sd">    :raises biogeme.exceptions.biogemeError: if ``beta1`` :math:`\\geq` beta2</span>
<span class="sd">    :raises biogeme.exceptions.biogemeError: if ``d`` is not a descent</span>
<span class="sd">                                             direction</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">lbd</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">excep</span><span class="o">.</span><span class="n">biogemeError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;lambda is </span><span class="si">{</span><span class="n">lbd</span><span class="si">}</span><span class="s1"> and must be &gt; 1&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">alpha0</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">excep</span><span class="o">.</span><span class="n">biogemeError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;alpha0 is </span><span class="si">{</span><span class="n">alpha0</span><span class="si">}</span><span class="s1"> and must be &gt; 0&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">beta1</span> <span class="o">&gt;=</span> <span class="n">beta2</span><span class="p">:</span>
        <span class="n">errorMsg</span> <span class="o">=</span> <span class="p">(</span>
            <span class="sa">f</span><span class="s1">&#39;Incompatible Wolfe cond. parameters: &#39;</span>
            <span class="sa">f</span><span class="s1">&#39;beta1= </span><span class="si">{</span><span class="n">beta1</span><span class="si">}</span><span class="s1"> is greater than &#39;</span>
            <span class="sa">f</span><span class="s1">&#39;beta2=</span><span class="si">{</span><span class="n">beta2</span><span class="si">}</span><span class="s1">&#39;</span>
        <span class="p">)</span>
        <span class="k">raise</span> <span class="n">excep</span><span class="o">.</span><span class="n">biogemeError</span><span class="p">(</span><span class="n">errorMsg</span><span class="p">)</span>

    <span class="n">nfev</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="n">deriv</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">inner</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">d</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">deriv</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">excep</span><span class="o">.</span><span class="n">biogemeError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;d is not a descent direction: </span><span class="si">{</span><span class="n">deriv</span><span class="si">}</span><span class="s1"> &gt;= 0&#39;</span><span class="p">)</span>

    <span class="n">alpha</span> <span class="o">=</span> <span class="n">alpha0</span>
    <span class="n">alphal</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">alphar</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">finfo</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span><span class="o">.</span><span class="n">max</span>
    <span class="n">finished</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="k">while</span> <span class="ow">not</span> <span class="n">finished</span><span class="p">:</span>
        <span class="n">xnew</span> <span class="o">=</span> <span class="n">x</span> <span class="o">+</span> <span class="n">alpha</span> <span class="o">*</span> <span class="n">d</span>
        <span class="n">fct</span><span class="o">.</span><span class="n">setVariables</span><span class="p">(</span><span class="n">xnew</span><span class="p">)</span>
        <span class="n">fnew</span><span class="p">,</span> <span class="n">gnew</span> <span class="o">=</span> <span class="n">fct</span><span class="o">.</span><span class="n">f_g</span><span class="p">()</span>
        <span class="n">nfev</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="n">finished</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="c1"># First Wolfe condition violated?</span>
        <span class="k">if</span> <span class="n">fnew</span> <span class="o">&gt;</span> <span class="n">f</span> <span class="o">+</span> <span class="n">alpha</span> <span class="o">*</span> <span class="n">beta1</span> <span class="o">*</span> <span class="n">deriv</span><span class="p">:</span>
            <span class="n">alphar</span> <span class="o">=</span> <span class="n">alpha</span>
            <span class="n">alpha</span> <span class="o">=</span> <span class="p">(</span><span class="n">alphal</span> <span class="o">+</span> <span class="n">alphar</span><span class="p">)</span> <span class="o">/</span> <span class="mf">2.0</span>
            <span class="n">finished</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">elif</span> <span class="n">np</span><span class="o">.</span><span class="n">inner</span><span class="p">(</span><span class="n">gnew</span><span class="p">,</span> <span class="n">d</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">beta2</span> <span class="o">*</span> <span class="n">deriv</span><span class="p">:</span>
            <span class="n">alphal</span> <span class="o">=</span> <span class="n">alpha</span>
            <span class="k">if</span> <span class="n">alphar</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">finfo</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span><span class="o">.</span><span class="n">max</span><span class="p">:</span>
                <span class="n">alpha</span> <span class="o">=</span> <span class="n">lbd</span> <span class="o">*</span> <span class="n">alpha</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">alpha</span> <span class="o">=</span> <span class="p">(</span><span class="n">alphal</span> <span class="o">+</span> <span class="n">alphar</span><span class="p">)</span> <span class="o">/</span> <span class="mf">2.0</span>
            <span class="n">finished</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="k">return</span> <span class="n">alpha</span><span class="p">,</span> <span class="n">nfev</span></div>


<div class="viewcode-block" id="relativeGradient"><a class="viewcode-back" href="../../algorithms.html#biogeme.algorithms.relativeGradient">[docs]</a><span class="k">def</span> <span class="nf">relativeGradient</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">g</span><span class="p">,</span> <span class="n">typx</span><span class="p">,</span> <span class="n">typf</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Calculates the relative gradients.</span>

<span class="sd">    It is typically used as stopping criterion.</span>

<span class="sd">    :param x: current iterate.</span>
<span class="sd">    :type x: numpy.array</span>
<span class="sd">    :param f: value of f(x)</span>
<span class="sd">    :type f: float</span>
<span class="sd">    :param g: :math:`\\nabla f(x)`, gradient of f at x</span>
<span class="sd">    :type g: numpy.array</span>
<span class="sd">    :param typx: typical value for x.</span>
<span class="sd">    :type typx: numpy.array</span>
<span class="sd">    :param typf: typical value for f.</span>
<span class="sd">    :type typf: float</span>

<span class="sd">    :return: relative gradient</span>

<span class="sd">    .. math:: \\max_{i=1,\\ldots,n}\\frac{(\\nabla f(x))_i</span>
<span class="sd">              \\max(x_i,\\text{typx}_i)}</span>
<span class="sd">              {\\max(|f(x)|, \\text{typf})}</span>

<span class="sd">    :rtype: float</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">relgrad</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
        <span class="p">[</span>
            <span class="n">g</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="nb">max</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">]),</span> <span class="n">typx</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">/</span> <span class="nb">max</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">f</span><span class="p">),</span> <span class="n">typf</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
        <span class="p">]</span>
    <span class="p">)</span>
    <span class="n">result</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">relgrad</span><span class="p">)</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">result</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">result</span>

    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">finfo</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span><span class="o">.</span><span class="n">max</span></div>


<div class="viewcode-block" id="newtonLineSearch"><a class="viewcode-back" href="../../algorithms.html#biogeme.algorithms.newtonLineSearch">[docs]</a><span class="k">def</span> <span class="nf">newtonLineSearch</span><span class="p">(</span>
    <span class="n">fct</span><span class="p">,</span> <span class="n">x0</span><span class="p">,</span> <span class="n">eps</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">finfo</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span><span class="o">.</span><span class="n">eps</span> <span class="o">**</span> <span class="mf">0.3333</span><span class="p">,</span> <span class="n">maxiter</span><span class="o">=</span><span class="mi">100</span>
<span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Newton method with inexact line search (Wolfe conditions)</span>

<span class="sd">    :param fct: object to calculate the objective function and its derivatives.</span>
<span class="sd">    :type fct: optimization.functionToMinimize</span>

<span class="sd">    :param x0: starting point</span>
<span class="sd">    :type x0: numpy.array</span>

<span class="sd">    :param eps: the algorithm stops when this precision is reached.</span>
<span class="sd">                 Default: :math:`\\varepsilon^{\\frac{1}{3}}`</span>
<span class="sd">    :type eps: float</span>

<span class="sd">    :param maxiter: the algorithm stops if this number of iterations</span>
<span class="sd">                    is reached. Defaut: 100</span>
<span class="sd">    :type maxiter: int</span>

<span class="sd">    :return: x, messages</span>

<span class="sd">        - x is the solution generated by the algorithm,</span>
<span class="sd">        - messages is a dictionary describing information about the lagorithm</span>

<span class="sd">    :rtype: numpay.array, dict(str:object)</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">xk</span> <span class="o">=</span> <span class="n">x0</span>
    <span class="n">fct</span><span class="o">.</span><span class="n">setVariables</span><span class="p">(</span><span class="n">xk</span><span class="p">)</span>
    <span class="n">f</span><span class="p">,</span> <span class="n">g</span><span class="p">,</span> <span class="n">H</span> <span class="o">=</span> <span class="n">fct</span><span class="o">.</span><span class="n">f_g_h</span><span class="p">()</span>
    <span class="n">nfev</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="n">ngev</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="n">nhev</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="n">typx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">xk</span><span class="p">)</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
    <span class="n">typf</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">f</span><span class="p">),</span> <span class="mf">1.0</span><span class="p">)</span>
    <span class="n">relgrad</span> <span class="o">=</span> <span class="n">relativeGradient</span><span class="p">(</span><span class="n">xk</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">g</span><span class="p">,</span> <span class="n">typx</span><span class="p">,</span> <span class="n">typf</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">relgrad</span> <span class="o">&lt;=</span> <span class="n">eps</span><span class="p">:</span>
        <span class="n">message</span> <span class="o">=</span> <span class="sa">f</span><span class="s1">&#39;Relative gradient = </span><span class="si">{</span><span class="n">relgrad</span><span class="si">:</span><span class="s1">.3g</span><span class="si">}</span><span class="s1"> &lt;= </span><span class="si">{</span><span class="n">eps</span><span class="si">:</span><span class="s1">.2g</span><span class="si">}</span><span class="s1">&#39;</span>
        <span class="n">messages</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s1">&#39;Algorithm&#39;</span><span class="p">:</span> <span class="s1">&#39;Unconstrained Newton with line search&#39;</span><span class="p">,</span>
            <span class="s1">&#39;Relative gradient&#39;</span><span class="p">:</span> <span class="n">relgrad</span><span class="p">,</span>
            <span class="s1">&#39;Number of iterations&#39;</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span>
            <span class="s1">&#39;Number of function evaluations&#39;</span><span class="p">:</span> <span class="n">nfev</span><span class="p">,</span>
            <span class="s1">&#39;Number of gradient evaluations&#39;</span><span class="p">:</span> <span class="n">ngev</span><span class="p">,</span>
            <span class="s1">&#39;Number of hessian evaluations&#39;</span><span class="p">:</span> <span class="n">nhev</span><span class="p">,</span>
            <span class="s1">&#39;Cause of termination&#39;</span><span class="p">:</span> <span class="n">message</span><span class="p">,</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="n">xk</span><span class="p">,</span> <span class="n">messages</span>

    <span class="n">k</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">cont</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="k">while</span> <span class="n">cont</span><span class="p">:</span>
        <span class="n">L</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">P</span> <span class="o">=</span> <span class="n">schnabelEskow</span><span class="p">(</span><span class="n">H</span><span class="p">)</span>
        <span class="n">y3</span> <span class="o">=</span> <span class="o">-</span><span class="n">P</span><span class="o">.</span><span class="n">T</span> <span class="o">@</span> <span class="n">g</span>
        <span class="n">y2</span> <span class="o">=</span> <span class="n">la</span><span class="o">.</span><span class="n">solve_triangular</span><span class="p">(</span><span class="n">L</span><span class="p">,</span> <span class="n">y3</span><span class="p">,</span> <span class="n">lower</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">y1</span> <span class="o">=</span> <span class="n">la</span><span class="o">.</span><span class="n">solve_triangular</span><span class="p">(</span><span class="n">L</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">y2</span><span class="p">,</span> <span class="n">lower</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">d</span> <span class="o">=</span> <span class="n">P</span> <span class="o">@</span> <span class="n">y1</span>
        <span class="n">alpha</span><span class="p">,</span> <span class="n">nfls</span> <span class="o">=</span> <span class="n">lineSearch</span><span class="p">(</span><span class="n">fct</span><span class="p">,</span> <span class="n">xk</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">g</span><span class="p">,</span> <span class="n">d</span><span class="p">)</span>
        <span class="n">nfev</span> <span class="o">+=</span> <span class="n">nfls</span>
        <span class="n">ngev</span> <span class="o">+=</span> <span class="n">nfls</span>
        <span class="n">xk</span> <span class="o">=</span> <span class="n">xk</span> <span class="o">+</span> <span class="n">alpha</span> <span class="o">*</span> <span class="n">d</span>
        <span class="n">fct</span><span class="o">.</span><span class="n">setVariables</span><span class="p">(</span><span class="n">xk</span><span class="p">)</span>
        <span class="n">f</span><span class="p">,</span> <span class="n">g</span><span class="p">,</span> <span class="n">H</span> <span class="o">=</span> <span class="n">fct</span><span class="o">.</span><span class="n">f_g_h</span><span class="p">()</span>
        <span class="n">nfev</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="n">ngev</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="n">nhev</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="n">k</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="n">typf</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">f</span><span class="p">),</span> <span class="mf">1.0</span><span class="p">)</span>
        <span class="n">relgrad</span> <span class="o">=</span> <span class="n">relativeGradient</span><span class="p">(</span><span class="n">xk</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">g</span><span class="p">,</span> <span class="n">typx</span><span class="p">,</span> <span class="n">typf</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">relgrad</span> <span class="o">&lt;=</span> <span class="n">eps</span><span class="p">:</span>
            <span class="n">message</span> <span class="o">=</span> <span class="sa">f</span><span class="s1">&#39;Relative gradient = </span><span class="si">{</span><span class="n">relgrad</span><span class="si">:</span><span class="s1">.2g</span><span class="si">}</span><span class="s1"> &lt;= </span><span class="si">{</span><span class="n">eps</span><span class="si">:</span><span class="s1">.2g</span><span class="si">}</span><span class="s1">&#39;</span>
            <span class="n">cont</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="n">k</span> <span class="o">==</span> <span class="n">maxiter</span><span class="p">:</span>
            <span class="n">message</span> <span class="o">=</span> <span class="sa">f</span><span class="s1">&#39;Maximum number of iterations reached: </span><span class="si">{</span><span class="n">maxiter</span><span class="si">}</span><span class="s1">&#39;</span>
            <span class="n">cont</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">detailed</span><span class="p">(</span>
            <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">k</span><span class="si">}</span><span class="s1"> f=</span><span class="si">{</span><span class="n">f</span><span class="si">:</span><span class="s1">10.7g</span><span class="si">}</span><span class="s1"> relgrad=</span><span class="si">{</span><span class="n">relgrad</span><span class="si">:</span><span class="s1">6.2g</span><span class="si">}</span><span class="s1">&#39;</span> <span class="sa">f</span><span class="s1">&#39; alpha=</span><span class="si">{</span><span class="n">alpha</span><span class="si">:</span><span class="s1">6.2g</span><span class="si">}</span><span class="s1">&#39;</span>
        <span class="p">)</span>

    <span class="n">messages</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s1">&#39;Algorithm&#39;</span><span class="p">:</span> <span class="s1">&#39;Unconstrained Newton with line search&#39;</span><span class="p">,</span>
        <span class="s1">&#39;Relative gradient&#39;</span><span class="p">:</span> <span class="n">relgrad</span><span class="p">,</span>
        <span class="s1">&#39;Number of iterations&#39;</span><span class="p">:</span> <span class="n">k</span><span class="p">,</span>
        <span class="s1">&#39;Number of function evaluations&#39;</span><span class="p">:</span> <span class="n">nfev</span><span class="p">,</span>
        <span class="s1">&#39;Number of gradient evaluations&#39;</span><span class="p">:</span> <span class="n">ngev</span><span class="p">,</span>
        <span class="s1">&#39;Number of hessian evaluations&#39;</span><span class="p">:</span> <span class="n">nhev</span><span class="p">,</span>
        <span class="s1">&#39;Cause of termination&#39;</span><span class="p">:</span> <span class="n">message</span><span class="p">,</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="n">xk</span><span class="p">,</span> <span class="n">messages</span></div>


<div class="viewcode-block" id="trustRegionIntersection"><a class="viewcode-back" href="../../algorithms.html#biogeme.algorithms.trustRegionIntersection">[docs]</a><span class="k">def</span> <span class="nf">trustRegionIntersection</span><span class="p">(</span><span class="n">dc</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">delta</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Calculates the intersection with the boundary of the trust region.</span>

<span class="sd">    Consider a trust region of radius :math:`\\delta`, centered at</span>
<span class="sd">    :math:`\\hat{x}`. Let :math:`x_c` be in the trust region, and</span>
<span class="sd">    :math:`d_c = x_c - \\hat{x}`, so that :math:`\\|d_c\\| \\leq</span>
<span class="sd">    \\delta`. Let :math:`x_d` be out of the trust region, and</span>
<span class="sd">    :math:`d_d = x_d - \\hat{x}`, so that :math:`\\|d_d\\| \\geq</span>
<span class="sd">    \\delta`.  We calculate :math:`\\lambda` such that</span>

<span class="sd">    .. math:: \\| d_c + \\lambda (d_d - d_c)\\| = \\delta</span>

<span class="sd">    :param dc: xc - xhat.</span>
<span class="sd">    :type dc: numpy.array</span>
<span class="sd">    :param d: dd - dc.</span>
<span class="sd">    :type d: numpy.array</span>
<span class="sd">    :param delta: radius of the trust region.</span>
<span class="sd">    :type delta: float</span>

<span class="sd">    :return: :math:`\\lambda` such that :math:`\\| d_c +</span>
<span class="sd">              \\lambda (d_d - d_c)\\| = \\delta`</span>

<span class="sd">    :rtype: float</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">inner</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">d</span><span class="p">)</span>
    <span class="n">b</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">inner</span><span class="p">(</span><span class="n">dc</span><span class="p">,</span> <span class="n">d</span><span class="p">)</span>
    <span class="n">c</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">inner</span><span class="p">(</span><span class="n">dc</span><span class="p">,</span> <span class="n">dc</span><span class="p">)</span> <span class="o">-</span> <span class="n">delta</span><span class="o">**</span><span class="mi">2</span>
    <span class="n">discriminant</span> <span class="o">=</span> <span class="n">b</span> <span class="o">*</span> <span class="n">b</span> <span class="o">-</span> <span class="mf">4.0</span> <span class="o">*</span> <span class="n">a</span> <span class="o">*</span> <span class="n">c</span>
    <span class="k">return</span> <span class="p">(</span><span class="o">-</span><span class="n">b</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">discriminant</span><span class="p">))</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">a</span><span class="p">)</span></div>


<div class="viewcode-block" id="cauchyNewtonDogleg"><a class="viewcode-back" href="../../algorithms.html#biogeme.algorithms.cauchyNewtonDogleg">[docs]</a><span class="k">def</span> <span class="nf">cauchyNewtonDogleg</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">H</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Calculate the Cauchy, the Newton and the dogleg points.</span>

<span class="sd">    The Cauchy point is defined as</span>

<span class="sd">    .. math:: d_c = - \\frac{\\nabla f(x)^T \\nabla f(x)}</span>
<span class="sd">                    {\\nabla f(x)^T \\nabla^2 f(x)</span>
<span class="sd">                    \\nabla f(x)} \\nabla f(x)</span>

<span class="sd">    The Newton point :math:`d_n` verifies Newton equation:</span>

<span class="sd">    .. math:: H_s d_n = - \\nabla f(x)</span>

<span class="sd">    where :math:`H_s` is a positive definite matrix generated with the</span>
<span class="sd">    method by `Schnabel and Eskow (1999)`_.</span>

<span class="sd">    The Dogleg point is</span>

<span class="sd">    .. math:: d_d = \\eta d_n</span>

<span class="sd">    where</span>

<span class="sd">    .. math:: \\eta = 0.2 + 0.8 \\frac{\\alpha^2}{\\beta |\\nabla f(x)^T d_n|}</span>

<span class="sd">    and :math:`\\alpha= \\nabla f(x)^T \\nabla f(x)`,</span>
<span class="sd">    :math:`\\beta=\\nabla f(x)^T \\nabla^2 f(x)\\nabla f(x).`</span>

<span class="sd">    :param g: gradient :math:`\\nabla f(x)`</span>

<span class="sd">    :type g: numpy.array</span>

<span class="sd">    :param H: hessian :math:`\\nabla^2 f(x)`</span>

<span class="sd">    :type H: numpy.array</span>

<span class="sd">    :return: tuple with Cauchy point, Newton point, Dogleg point</span>
<span class="sd">    :rtype: numpy.array, numpy.array, numpy.array</span>

<span class="sd">    :raises biogeme.exceptions.biogemeError: if the quadratic model is</span>
<span class="sd">        not convex.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">alpha</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">inner</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">g</span><span class="p">)</span>
    <span class="n">beta</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">inner</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">H</span> <span class="o">@</span> <span class="n">g</span><span class="p">)</span>
    <span class="n">dc</span> <span class="o">=</span> <span class="o">-</span><span class="p">(</span><span class="n">alpha</span> <span class="o">/</span> <span class="n">beta</span><span class="p">)</span> <span class="o">*</span> <span class="n">g</span>
    <span class="n">L</span><span class="p">,</span> <span class="n">E</span><span class="p">,</span> <span class="n">P</span> <span class="o">=</span> <span class="n">schnabelEskow</span><span class="p">(</span><span class="n">H</span><span class="p">)</span>
    <span class="n">negativeEigenvalue</span> <span class="o">=</span> <span class="n">E</span> <span class="o">&lt;</span> <span class="mi">0</span>
    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">negativeEigenvalue</span><span class="p">):</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">E</span><span class="p">)</span>
        <span class="k">raise</span> <span class="n">excep</span><span class="o">.</span><span class="n">biogemeError</span><span class="p">(</span>
            <span class="s1">&#39;The dogleg method requires a &#39;</span> <span class="s1">&#39;convex optimization problem.&#39;</span>
        <span class="p">)</span>

    <span class="n">y3</span> <span class="o">=</span> <span class="o">-</span><span class="n">P</span><span class="o">.</span><span class="n">T</span> <span class="o">@</span> <span class="n">g</span>
    <span class="n">y2</span> <span class="o">=</span> <span class="n">la</span><span class="o">.</span><span class="n">solve_triangular</span><span class="p">(</span><span class="n">L</span><span class="p">,</span> <span class="n">y3</span><span class="p">,</span> <span class="n">lower</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">y1</span> <span class="o">=</span> <span class="n">la</span><span class="o">.</span><span class="n">solve_triangular</span><span class="p">(</span><span class="n">L</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">y2</span><span class="p">,</span> <span class="n">lower</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="n">dn</span> <span class="o">=</span> <span class="n">P</span> <span class="o">@</span> <span class="n">y1</span>
    <span class="n">eta</span> <span class="o">=</span> <span class="mf">0.2</span> <span class="o">+</span> <span class="p">(</span><span class="mf">0.8</span> <span class="o">*</span> <span class="n">alpha</span> <span class="o">*</span> <span class="n">alpha</span> <span class="o">/</span> <span class="p">(</span><span class="n">beta</span> <span class="o">*</span> <span class="nb">abs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">inner</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">dn</span><span class="p">))))</span>
    <span class="k">return</span> <span class="n">dc</span><span class="p">,</span> <span class="n">dn</span><span class="p">,</span> <span class="n">eta</span> <span class="o">*</span> <span class="n">dn</span></div>


<div class="viewcode-block" id="dogleg"><a class="viewcode-back" href="../../algorithms.html#biogeme.algorithms.dogleg">[docs]</a><span class="k">def</span> <span class="nf">dogleg</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">H</span><span class="p">,</span> <span class="n">delta</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Find an approximation of the trust region subproblem using</span>
<span class="sd">    the dogleg method</span>

<span class="sd">    :param g: gradient of the quadratic model.</span>
<span class="sd">    :type g: numpy.array</span>
<span class="sd">    :param H: hessian of the quadratic model.</span>
<span class="sd">    :type H: numpy.array</span>
<span class="sd">    :param delta: radius of the trust region.</span>
<span class="sd">    :type delta: float</span>

<span class="sd">    :return: d, diagnostic where</span>

<span class="sd">          - d is an approximate solution of the trust region subproblem</span>
<span class="sd">          - diagnostic is the nature of the solution:</span>

<span class="sd">             * -2 if negative curvature along Newton direction</span>
<span class="sd">             * -1 if negative curvature along Cauchy direction</span>
<span class="sd">               (i.e. along the gradient)</span>
<span class="sd">             * 1 if partial Cauchy step</span>
<span class="sd">             * 2 if Newton step</span>
<span class="sd">             * 3 if partial Newton step</span>
<span class="sd">             * 4 if Dogleg</span>

<span class="sd">    :rtype: numpy.array, int</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">dc</span><span class="p">,</span> <span class="n">dn</span><span class="p">,</span> <span class="n">dl</span> <span class="o">=</span> <span class="n">cauchyNewtonDogleg</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">H</span><span class="p">)</span>

    <span class="c1"># Check if the model is convex along the gradient direction</span>

    <span class="n">alpha</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">inner</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">g</span><span class="p">)</span>
    <span class="n">beta</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">inner</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">H</span> <span class="o">@</span> <span class="n">g</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">beta</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">dstar</span> <span class="o">=</span> <span class="o">-</span><span class="n">delta</span> <span class="o">*</span> <span class="n">g</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">alpha</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">dstar</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span>

    <span class="c1"># Compute the Cauchy point</span>

    <span class="n">normdc</span> <span class="o">=</span> <span class="n">alpha</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">alpha</span><span class="p">)</span> <span class="o">/</span> <span class="n">beta</span>
    <span class="k">if</span> <span class="n">normdc</span> <span class="o">&gt;=</span> <span class="n">delta</span><span class="p">:</span>
        <span class="c1"># The Cauchy point is outside the trust</span>
        <span class="c1"># region. We move along the Cauchy</span>
        <span class="c1"># direction until the border of the trust</span>
        <span class="c1"># region.</span>

        <span class="n">dstar</span> <span class="o">=</span> <span class="p">(</span><span class="n">delta</span> <span class="o">/</span> <span class="n">normdc</span><span class="p">)</span> <span class="o">*</span> <span class="n">dc</span>
        <span class="k">return</span> <span class="n">dstar</span><span class="p">,</span> <span class="mi">1</span>

    <span class="c1"># Compute Newton point</span>

    <span class="n">normdn</span> <span class="o">=</span> <span class="n">la</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">dn</span><span class="p">)</span>

    <span class="c1"># Check the convexity of the model along Newton direction</span>

    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">inner</span><span class="p">(</span><span class="n">dn</span><span class="p">,</span> <span class="n">H</span> <span class="o">@</span> <span class="n">dn</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mf">0.0</span><span class="p">:</span>
        <span class="c1"># Return the Cauchy point</span>
        <span class="k">return</span> <span class="n">dc</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span>

    <span class="k">if</span> <span class="n">normdn</span> <span class="o">&lt;=</span> <span class="n">delta</span><span class="p">:</span>
        <span class="c1"># Newton point is inside the trust region</span>
        <span class="k">return</span> <span class="n">dn</span><span class="p">,</span> <span class="mi">2</span>

    <span class="c1"># Compute the dogleg point</span>

    <span class="n">eta</span> <span class="o">=</span> <span class="mf">0.2</span> <span class="o">+</span> <span class="p">(</span><span class="mf">0.8</span> <span class="o">*</span> <span class="n">alpha</span> <span class="o">*</span> <span class="n">alpha</span> <span class="o">/</span> <span class="p">(</span><span class="n">beta</span> <span class="o">*</span> <span class="nb">abs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">inner</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">dn</span><span class="p">))))</span>

    <span class="n">partieldn</span> <span class="o">=</span> <span class="n">eta</span> <span class="o">*</span> <span class="n">la</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">dn</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">partieldn</span> <span class="o">&lt;=</span> <span class="n">delta</span><span class="p">:</span>
        <span class="c1"># Dogleg point is inside the trust region</span>
        <span class="n">dstar</span> <span class="o">=</span> <span class="p">(</span><span class="n">delta</span> <span class="o">/</span> <span class="n">normdn</span><span class="p">)</span> <span class="o">*</span> <span class="n">dn</span>
        <span class="k">return</span> <span class="n">dstar</span><span class="p">,</span> <span class="mi">3</span>

    <span class="c1"># Between Cauchy and dogleg</span>
    <span class="n">nu</span> <span class="o">=</span> <span class="n">dl</span> <span class="o">-</span> <span class="n">dc</span>
    <span class="n">lbd</span> <span class="o">=</span> <span class="n">trustRegionIntersection</span><span class="p">(</span><span class="n">dc</span><span class="p">,</span> <span class="n">nu</span><span class="p">,</span> <span class="n">delta</span><span class="p">)</span>
    <span class="n">dstar</span> <span class="o">=</span> <span class="n">dc</span> <span class="o">+</span> <span class="n">lbd</span> <span class="o">*</span> <span class="n">nu</span>
    <span class="k">return</span> <span class="n">dstar</span><span class="p">,</span> <span class="mi">4</span></div>


<div class="viewcode-block" id="truncatedConjugateGradient"><a class="viewcode-back" href="../../algorithms.html#biogeme.algorithms.truncatedConjugateGradient">[docs]</a><span class="k">def</span> <span class="nf">truncatedConjugateGradient</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">H</span><span class="p">,</span> <span class="n">delta</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Find an approximation of the trust region subproblem using the</span>
<span class="sd">    truncated conjugate gradient method</span>

<span class="sd">    :param g: gradient of the quadratic model.</span>
<span class="sd">    :type g: numpy.array</span>
<span class="sd">    :param H: hessian of the quadrartic model.</span>
<span class="sd">    :type H: numpy.array</span>
<span class="sd">    :param delta: radius of the trust region.</span>
<span class="sd">    :type delta: float</span>

<span class="sd">    :return: d, diagnostic, where</span>

<span class="sd">          - d is the approximate solution of the trust region subproblem,</span>
<span class="sd">          - diagnostic is the nature of the solution:</span>

<span class="sd">            * 1 for convergence,</span>
<span class="sd">            * 2 if out of the trust region,</span>
<span class="sd">            * 3 if negative curvature detected.</span>
<span class="sd">            * 4 if a numerical problem has been encountered</span>

<span class="sd">    :rtype: numpy.array, int</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">tol</span> <span class="o">=</span> <span class="mf">1.0e-6</span>
    <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">g</span><span class="p">)</span>
    <span class="n">xk</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
    <span class="n">gk</span> <span class="o">=</span> <span class="n">g</span>
    <span class="n">dk</span> <span class="o">=</span> <span class="o">-</span><span class="n">gk</span>
    <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">curv</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">inner</span><span class="p">(</span><span class="n">dk</span><span class="p">,</span> <span class="n">H</span> <span class="o">@</span> <span class="n">dk</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">curv</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
                <span class="c1"># Negative curvature has been detected</span>
                <span class="n">diagnostic</span> <span class="o">=</span> <span class="mi">3</span>
                <span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">inner</span><span class="p">(</span><span class="n">dk</span><span class="p">,</span> <span class="n">dk</span><span class="p">)</span>
                <span class="n">b</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">inner</span><span class="p">(</span><span class="n">xk</span><span class="p">,</span> <span class="n">dk</span><span class="p">)</span>
                <span class="n">c</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">inner</span><span class="p">(</span><span class="n">xk</span><span class="p">,</span> <span class="n">xk</span><span class="p">)</span> <span class="o">-</span> <span class="n">delta</span> <span class="o">*</span> <span class="n">delta</span>
                <span class="n">rho</span> <span class="o">=</span> <span class="n">b</span> <span class="o">*</span> <span class="n">b</span> <span class="o">-</span> <span class="mi">4</span> <span class="o">*</span> <span class="n">a</span> <span class="o">*</span> <span class="n">c</span>
                <span class="n">step</span> <span class="o">=</span> <span class="n">xk</span> <span class="o">+</span> <span class="p">((</span><span class="o">-</span><span class="n">b</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">rho</span><span class="p">))</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">a</span><span class="p">))</span> <span class="o">*</span> <span class="n">dk</span>
                <span class="k">return</span> <span class="n">step</span><span class="p">,</span> <span class="n">diagnostic</span>
            <span class="n">alphak</span> <span class="o">=</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">inner</span><span class="p">(</span><span class="n">dk</span><span class="p">,</span> <span class="n">gk</span><span class="p">)</span> <span class="o">/</span> <span class="n">curv</span>
            <span class="n">xkp1</span> <span class="o">=</span> <span class="n">xk</span> <span class="o">+</span> <span class="n">alphak</span> <span class="o">*</span> <span class="n">dk</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">xkp1</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">()</span> <span class="ow">or</span> <span class="n">la</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">xkp1</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">delta</span><span class="p">:</span>
                <span class="c1"># Out of the trust region</span>
                <span class="n">diagnostic</span> <span class="o">=</span> <span class="mi">2</span>
                <span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">inner</span><span class="p">(</span><span class="n">dk</span><span class="p">,</span> <span class="n">dk</span><span class="p">)</span>
                <span class="n">b</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">inner</span><span class="p">(</span><span class="n">xk</span><span class="p">,</span> <span class="n">dk</span><span class="p">)</span>
                <span class="n">c</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">inner</span><span class="p">(</span><span class="n">xk</span><span class="p">,</span> <span class="n">xk</span><span class="p">)</span> <span class="o">-</span> <span class="n">delta</span> <span class="o">*</span> <span class="n">delta</span>
                <span class="n">rho</span> <span class="o">=</span> <span class="n">b</span> <span class="o">*</span> <span class="n">b</span> <span class="o">-</span> <span class="mi">4</span> <span class="o">*</span> <span class="n">a</span> <span class="o">*</span> <span class="n">c</span>
                <span class="n">step</span> <span class="o">=</span> <span class="n">xk</span> <span class="o">+</span> <span class="p">((</span><span class="o">-</span><span class="n">b</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">rho</span><span class="p">))</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">a</span><span class="p">))</span> <span class="o">*</span> <span class="n">dk</span>
                <span class="k">return</span> <span class="n">step</span><span class="p">,</span> <span class="n">diagnostic</span>
            <span class="n">xk</span> <span class="o">=</span> <span class="n">xkp1</span>
            <span class="n">gkp1</span> <span class="o">=</span> <span class="n">H</span> <span class="o">@</span> <span class="n">xk</span> <span class="o">+</span> <span class="n">g</span>
            <span class="n">betak</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">inner</span><span class="p">(</span><span class="n">gkp1</span><span class="p">,</span> <span class="n">gkp1</span><span class="p">)</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">inner</span><span class="p">(</span><span class="n">gk</span><span class="p">,</span> <span class="n">gk</span><span class="p">)</span>
            <span class="n">dk</span> <span class="o">=</span> <span class="o">-</span><span class="n">gkp1</span> <span class="o">+</span> <span class="n">betak</span> <span class="o">*</span> <span class="n">dk</span>
            <span class="n">gk</span> <span class="o">=</span> <span class="n">gkp1</span>
            <span class="k">if</span> <span class="n">la</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">gkp1</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">tol</span><span class="p">:</span>
                <span class="n">diagnostic</span> <span class="o">=</span> <span class="mi">1</span>
                <span class="n">step</span> <span class="o">=</span> <span class="n">xk</span>
                <span class="k">return</span> <span class="n">step</span><span class="p">,</span> <span class="n">diagnostic</span>
        <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
            <span class="c1"># Numerical problem</span>
            <span class="n">diagnostic</span> <span class="o">=</span> <span class="mi">4</span>
            <span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">inner</span><span class="p">(</span><span class="n">dk</span><span class="p">,</span> <span class="n">dk</span><span class="p">)</span>
            <span class="n">b</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">inner</span><span class="p">(</span><span class="n">xk</span><span class="p">,</span> <span class="n">dk</span><span class="p">)</span>
            <span class="n">c</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">inner</span><span class="p">(</span><span class="n">xk</span><span class="p">,</span> <span class="n">xk</span><span class="p">)</span> <span class="o">-</span> <span class="n">delta</span> <span class="o">*</span> <span class="n">delta</span>
            <span class="n">rho</span> <span class="o">=</span> <span class="n">b</span> <span class="o">*</span> <span class="n">b</span> <span class="o">-</span> <span class="mi">4</span> <span class="o">*</span> <span class="n">a</span> <span class="o">*</span> <span class="n">c</span>
            <span class="n">step</span> <span class="o">=</span> <span class="n">xk</span> <span class="o">+</span> <span class="p">((</span><span class="o">-</span><span class="n">b</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">rho</span><span class="p">))</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">a</span><span class="p">))</span> <span class="o">*</span> <span class="n">dk</span>
            <span class="k">return</span> <span class="n">step</span><span class="p">,</span> <span class="n">diagnostic</span>
    <span class="n">diagnostic</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="n">step</span> <span class="o">=</span> <span class="n">xk</span>
    <span class="k">return</span> <span class="n">step</span><span class="p">,</span> <span class="n">diagnostic</span></div>


<div class="viewcode-block" id="newtonTrustRegion"><a class="viewcode-back" href="../../algorithms.html#biogeme.algorithms.newtonTrustRegion">[docs]</a><span class="k">def</span> <span class="nf">newtonTrustRegion</span><span class="p">(</span>
    <span class="n">fct</span><span class="p">,</span>
    <span class="n">x0</span><span class="p">,</span>
    <span class="n">delta0</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span>
    <span class="n">eps</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">finfo</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span><span class="o">.</span><span class="n">eps</span> <span class="o">**</span> <span class="mf">0.3333</span><span class="p">,</span>
    <span class="n">dl</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">maxiter</span><span class="o">=</span><span class="mi">1000</span><span class="p">,</span>
    <span class="n">eta1</span><span class="o">=</span><span class="mf">0.01</span><span class="p">,</span>
    <span class="n">eta2</span><span class="o">=</span><span class="mf">0.9</span><span class="p">,</span>
<span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Newton method with trust region</span>

<span class="sd">    :param fct: object to calculate the objective function and its derivatives.</span>
<span class="sd">    :type fct: optimization.functionToMinimize</span>

<span class="sd">    :param x0: starting point</span>
<span class="sd">    :type x0: numpy.array</span>

<span class="sd">    :param delta0: initial radius of the trust region. Default: 100.</span>
<span class="sd">    :type delta0: float</span>

<span class="sd">    :param eps: the algorithm stops when this precision is reached.</span>
<span class="sd">              Default: :math:`\\varepsilon^{\\frac{1}{3}}`</span>
<span class="sd">    :type eps: float</span>

<span class="sd">    :param dl: If True, the Dogleg method is used to solve the</span>
<span class="sd">       trut region subproblem. If False, the truncated conjugate</span>
<span class="sd">       gradient is used. Default: False.</span>
<span class="sd">    :type dl: bool</span>

<span class="sd">    :param maxiter: the algorithm stops if this number of iterations</span>
<span class="sd">                    is reached. Default: 1000.</span>

<span class="sd">    :type maxiter: int</span>

<span class="sd">    :param eta1: threshold for failed iterations. Default: 0.01.</span>
<span class="sd">    :type eta1: float</span>

<span class="sd">    :param eta2: threshold for very successful iterations. Default 0.9.</span>
<span class="sd">    :type eta2: float</span>

<span class="sd">    :return: tuple x, messages, where</span>

<span class="sd">            - x is the solution found,</span>
<span class="sd">            - messages is a dictionary reporting various aspects</span>
<span class="sd">              related to the run of the algorithm.</span>

<span class="sd">    :rtype: numpy.array, dict(str:object)</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">k</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">xk</span> <span class="o">=</span> <span class="n">x0</span>
    <span class="n">fct</span><span class="o">.</span><span class="n">setVariables</span><span class="p">(</span><span class="n">xk</span><span class="p">)</span>
    <span class="n">f</span><span class="p">,</span> <span class="n">g</span><span class="p">,</span> <span class="n">H</span> <span class="o">=</span> <span class="n">fct</span><span class="o">.</span><span class="n">f_g_h</span><span class="p">()</span>
    <span class="n">nfev</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="n">ngev</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="n">nhev</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="n">typx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">xk</span><span class="p">)</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
    <span class="n">typf</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">f</span><span class="p">),</span> <span class="mf">1.0</span><span class="p">)</span>
    <span class="n">relgrad</span> <span class="o">=</span> <span class="n">relativeGradient</span><span class="p">(</span><span class="n">xk</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">g</span><span class="p">,</span> <span class="n">typx</span><span class="p">,</span> <span class="n">typf</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">relgrad</span> <span class="o">&lt;=</span> <span class="n">eps</span><span class="p">:</span>
        <span class="n">message</span> <span class="o">=</span> <span class="sa">f</span><span class="s1">&#39;Relative gradient = </span><span class="si">{</span><span class="n">relgrad</span><span class="si">:</span><span class="s1">.2g</span><span class="si">}</span><span class="s1"> &lt;= </span><span class="si">{</span><span class="n">eps</span><span class="si">:</span><span class="s1">.2g</span><span class="si">}</span><span class="s1">&#39;</span>
        <span class="n">messages</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s1">&#39;Algorithm&#39;</span><span class="p">:</span> <span class="s1">&#39;Unconstrained Newton with trust region&#39;</span><span class="p">,</span>
            <span class="s1">&#39;Relative gradient&#39;</span><span class="p">:</span> <span class="n">relgrad</span><span class="p">,</span>
            <span class="s1">&#39;Cause of termination&#39;</span><span class="p">:</span> <span class="n">message</span><span class="p">,</span>
            <span class="s1">&#39;Number of iterations&#39;</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span>
            <span class="s1">&#39;Number of function evaluations&#39;</span><span class="p">:</span> <span class="n">nfev</span><span class="p">,</span>
            <span class="s1">&#39;Number of gradient evaluations&#39;</span><span class="p">:</span> <span class="n">ngev</span><span class="p">,</span>
            <span class="s1">&#39;Number of hessian evaluations&#39;</span><span class="p">:</span> <span class="n">nhev</span><span class="p">,</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="n">xk</span><span class="p">,</span> <span class="n">messages</span>
    <span class="n">delta</span> <span class="o">=</span> <span class="n">delta0</span>
    <span class="n">nfev</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">cont</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="n">maxDelta</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">finfo</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span><span class="o">.</span><span class="n">max</span>
    <span class="n">minDelta</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">finfo</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span><span class="o">.</span><span class="n">eps</span>
    <span class="n">rho</span> <span class="o">=</span> <span class="mf">0.0</span>
    <span class="k">while</span> <span class="n">cont</span><span class="p">:</span>
        <span class="n">k</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">if</span> <span class="n">dl</span><span class="p">:</span>
            <span class="n">step</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">dogleg</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">H</span><span class="p">,</span> <span class="n">delta</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">step</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">truncatedConjugateGradient</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">H</span><span class="p">,</span> <span class="n">delta</span><span class="p">)</span>
        <span class="n">xc</span> <span class="o">=</span> <span class="n">xk</span> <span class="o">+</span> <span class="n">step</span>
        <span class="n">fct</span><span class="o">.</span><span class="n">setVariables</span><span class="p">(</span><span class="n">xc</span><span class="p">)</span>
        <span class="c1"># Calculate the value of the function</span>
        <span class="n">fc</span> <span class="o">=</span> <span class="n">fct</span><span class="o">.</span><span class="n">f</span><span class="p">()</span>
        <span class="n">nfev</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="n">num</span> <span class="o">=</span> <span class="n">f</span> <span class="o">-</span> <span class="n">fc</span>
        <span class="n">denom</span> <span class="o">=</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">inner</span><span class="p">(</span><span class="n">step</span><span class="p">,</span> <span class="n">g</span><span class="p">)</span> <span class="o">-</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">inner</span><span class="p">(</span><span class="n">step</span><span class="p">,</span> <span class="n">H</span> <span class="o">@</span> <span class="n">step</span><span class="p">)</span>
        <span class="n">rho</span> <span class="o">=</span> <span class="n">num</span> <span class="o">/</span> <span class="n">denom</span>
        <span class="k">if</span> <span class="n">rho</span> <span class="o">&lt;</span> <span class="n">eta1</span><span class="p">:</span>
            <span class="c1"># Failure: reduce the trust region</span>
            <span class="n">delta</span> <span class="o">=</span> <span class="n">la</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">step</span><span class="p">)</span> <span class="o">/</span> <span class="mf">2.0</span>
            <span class="n">status</span> <span class="o">=</span> <span class="s1">&#39;-&#39;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Candidate accepted</span>
            <span class="n">fc</span><span class="p">,</span> <span class="n">gc</span><span class="p">,</span> <span class="n">Hc</span> <span class="o">=</span> <span class="n">fct</span><span class="o">.</span><span class="n">f_g_h</span><span class="p">()</span>
            <span class="n">nfev</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">ngev</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">nhev</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">xk</span> <span class="o">=</span> <span class="n">xc</span>
            <span class="n">f</span> <span class="o">=</span> <span class="n">fc</span>
            <span class="n">g</span> <span class="o">=</span> <span class="n">gc</span>
            <span class="n">H</span> <span class="o">=</span> <span class="n">Hc</span>
            <span class="k">if</span> <span class="n">rho</span> <span class="o">&gt;=</span> <span class="n">eta2</span><span class="p">:</span>
                <span class="c1"># Enlarge the trust region</span>
                <span class="n">delta</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">delta</span><span class="p">,</span> <span class="n">maxDelta</span><span class="p">)</span>
                <span class="n">status</span> <span class="o">=</span> <span class="s1">&#39;++&#39;</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">status</span> <span class="o">=</span> <span class="s1">&#39;+&#39;</span>
            <span class="n">relgrad</span> <span class="o">=</span> <span class="n">relativeGradient</span><span class="p">(</span><span class="n">xk</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">g</span><span class="p">,</span> <span class="n">typx</span><span class="p">,</span> <span class="n">typf</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">relgrad</span> <span class="o">&lt;=</span> <span class="n">eps</span><span class="p">:</span>
                <span class="n">message</span> <span class="o">=</span> <span class="sa">f</span><span class="s1">&#39;Relative gradient = </span><span class="si">{</span><span class="n">relgrad</span><span class="si">:</span><span class="s1">.2g</span><span class="si">}</span><span class="s1"> &lt;= </span><span class="si">{</span><span class="n">eps</span><span class="si">:</span><span class="s1">.2g</span><span class="si">}</span><span class="s1">&#39;</span>
                <span class="n">cont</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="n">delta</span> <span class="o">&lt;=</span> <span class="n">minDelta</span><span class="p">:</span>
            <span class="n">message</span> <span class="o">=</span> <span class="sa">f</span><span class="s1">&#39;Trust region is too small: </span><span class="si">{</span><span class="n">delta</span><span class="si">}</span><span class="s1">&#39;</span>
            <span class="n">cont</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="n">k</span> <span class="o">==</span> <span class="n">maxiter</span><span class="p">:</span>
            <span class="n">message</span> <span class="o">=</span> <span class="sa">f</span><span class="s1">&#39;Maximum number of iterations reached: </span><span class="si">{</span><span class="n">maxiter</span><span class="si">}</span><span class="s1">&#39;</span>
            <span class="n">cont</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">detailed</span><span class="p">(</span>
            <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">k</span><span class="si">}</span><span class="s1"> f=</span><span class="si">{</span><span class="n">f</span><span class="si">:</span><span class="s1">10.7g</span><span class="si">}</span><span class="s1"> relgrad=</span><span class="si">{</span><span class="n">relgrad</span><span class="si">:</span><span class="s1">6.2g</span><span class="si">}</span><span class="s1"> &#39;</span>
            <span class="sa">f</span><span class="s1">&#39;delta=</span><span class="si">{</span><span class="n">delta</span><span class="si">:</span><span class="s1">6.2g</span><span class="si">}</span><span class="s1"> &#39;</span>
            <span class="sa">f</span><span class="s1">&#39;rho=</span><span class="si">{</span><span class="n">rho</span><span class="si">:</span><span class="s1">6.2g</span><span class="si">}</span><span class="s1"> </span><span class="si">{</span><span class="n">status</span><span class="si">}</span><span class="s1">&#39;</span>
        <span class="p">)</span>

    <span class="n">messages</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s1">&#39;Algorithm&#39;</span><span class="p">:</span> <span class="s1">&#39;Unconstrained Newton with trust region&#39;</span><span class="p">,</span>
        <span class="s1">&#39;Relative gradient&#39;</span><span class="p">:</span> <span class="n">relgrad</span><span class="p">,</span>
        <span class="s1">&#39;Cause of termination&#39;</span><span class="p">:</span> <span class="n">message</span><span class="p">,</span>
        <span class="s1">&#39;Number of iterations&#39;</span><span class="p">:</span> <span class="n">k</span><span class="p">,</span>
        <span class="s1">&#39;Number of function evaluations&#39;</span><span class="p">:</span> <span class="n">nfev</span><span class="p">,</span>
        <span class="s1">&#39;Number of gradient evaluations&#39;</span><span class="p">:</span> <span class="n">ngev</span><span class="p">,</span>
        <span class="s1">&#39;Number of hessian evaluations&#39;</span><span class="p">:</span> <span class="n">nhev</span><span class="p">,</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="n">xk</span><span class="p">,</span> <span class="n">messages</span></div>


<div class="viewcode-block" id="bfgs"><a class="viewcode-back" href="../../algorithms.html#biogeme.algorithms.bfgs">[docs]</a><span class="k">def</span> <span class="nf">bfgs</span><span class="p">(</span><span class="n">H</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Update the BFGS matrix. Formula (13.12) of `Bierlaire (2015)`_</span>
<span class="sd">    where the method proposed by `Powell (1977)`_ is applied</span>

<span class="sd">    .. _`Bierlaire (2015)`: http://optimizationprinciplesalgorithms.com/</span>
<span class="sd">    .. _`Powell (1977)`: https://link.springer.com/content/pdf/10.1007/BFb0067703.pdf</span>

<span class="sd">    :param H: current approximation of the inverse of the Hessian</span>
<span class="sd">    :type H: numpy.array (2D)</span>

<span class="sd">    :param d: difference between two consecutive iterates.</span>
<span class="sd">    :type d: numpy.array (1D)</span>

<span class="sd">    :param y: difference between two consecutive gradients.</span>
<span class="sd">    :type y: numpy.array (1D)</span>

<span class="sd">    :return: updated approximation of the inverse of the Hessian.</span>
<span class="sd">    :rtype: numpy.array (2D)</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">Hd</span> <span class="o">=</span> <span class="n">H</span> <span class="o">@</span> <span class="n">d</span>
    <span class="n">dHd</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">inner</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">Hd</span><span class="p">)</span>
    <span class="n">denom</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">inner</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">denom</span> <span class="o">&gt;=</span> <span class="mf">0.2</span> <span class="o">*</span> <span class="n">dHd</span><span class="p">:</span>
        <span class="n">eta</span> <span class="o">=</span> <span class="n">y</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">theta</span> <span class="o">=</span> <span class="mf">0.8</span> <span class="o">*</span> <span class="n">dHd</span> <span class="o">/</span> <span class="p">(</span><span class="n">dHd</span> <span class="o">-</span> <span class="n">denom</span><span class="p">)</span>
        <span class="n">eta</span> <span class="o">=</span> <span class="n">theta</span> <span class="o">*</span> <span class="n">y</span> <span class="o">+</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">theta</span><span class="p">)</span> <span class="o">*</span> <span class="n">Hd</span>

    <span class="k">return</span> <span class="n">H</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">outer</span><span class="p">(</span><span class="n">Hd</span><span class="p">,</span> <span class="n">Hd</span><span class="p">)</span> <span class="o">/</span> <span class="n">dHd</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">outer</span><span class="p">(</span><span class="n">eta</span><span class="p">,</span> <span class="n">eta</span><span class="p">)</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">inner</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">eta</span><span class="p">)</span></div>


<div class="viewcode-block" id="inverseBfgs"><a class="viewcode-back" href="../../algorithms.html#biogeme.algorithms.inverseBfgs">[docs]</a><span class="k">def</span> <span class="nf">inverseBfgs</span><span class="p">(</span><span class="n">Hinv</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Update the inverse BFGS matrix. Formula (13.13) of `Bierlaire (2015)`_</span>

<span class="sd">    .. _`Bierlaire (2015)`: http://optimizationprinciplesalgorithms.com/</span>

<span class="sd">    :param Hinv: current approximation of the inverse of the Hessian</span>
<span class="sd">    :type Hinv: numpy.array (2D)</span>

<span class="sd">    :param d: difference between two consecutive iterates.</span>
<span class="sd">    :type d: numpy.array (1D)</span>

<span class="sd">    :param y: difference between two consecutive gradients.</span>
<span class="sd">    :type y: numpy.array (1D)</span>

<span class="sd">    :return: updated approximation of the inverse of the Hessian.</span>
<span class="sd">    :rtype: numpy.array (2D)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>

    <span class="n">denom</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">inner</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">denom</span> <span class="o">&lt;=</span> <span class="mf">0.0</span><span class="p">:</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Unable to perform BFGS update as d&#39;y = </span><span class="si">{</span><span class="n">denom</span><span class="si">}</span><span class="s2"> &lt;= 0&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">Hinv</span>
    <span class="n">dy</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">outer</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
    <span class="n">yd</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">outer</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">d</span><span class="p">)</span>
    <span class="n">dd</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">outer</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">d</span><span class="p">)</span>
    <span class="n">eye</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">identity</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
    <span class="k">return</span> <span class="p">((</span><span class="n">eye</span> <span class="o">-</span> <span class="p">(</span><span class="n">dy</span> <span class="o">/</span> <span class="n">denom</span><span class="p">))</span> <span class="o">@</span> <span class="n">Hinv</span> <span class="o">@</span> <span class="p">(</span><span class="n">eye</span> <span class="o">-</span> <span class="p">(</span><span class="n">yd</span> <span class="o">/</span> <span class="n">denom</span><span class="p">)))</span> <span class="o">+</span> <span class="n">dd</span> <span class="o">/</span> <span class="n">denom</span></div>


<div class="viewcode-block" id="bfgsLineSearch"><a class="viewcode-back" href="../../algorithms.html#biogeme.algorithms.bfgsLineSearch">[docs]</a><span class="k">def</span> <span class="nf">bfgsLineSearch</span><span class="p">(</span>
    <span class="n">fct</span><span class="p">,</span>
    <span class="n">x0</span><span class="p">,</span>
    <span class="n">initBfgs</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">eps</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">finfo</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span><span class="o">.</span><span class="n">eps</span> <span class="o">**</span> <span class="mf">0.3333</span><span class="p">,</span>
    <span class="n">maxiter</span><span class="o">=</span><span class="mi">1000</span><span class="p">,</span>
<span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;BFGS method with inexact line search (Wolfe conditions)</span>

<span class="sd">    :param fct: object to calculate the objective function and its derivatives.</span>
<span class="sd">    :type fct: optimization.functionToMinimize</span>

<span class="sd">    :param x0: starting point</span>
<span class="sd">    :type x0: numpy.array</span>

<span class="sd">    :param initBfgs: matrix used to initialize BFGS. If None, the</span>
<span class="sd">                     identity matrix is used. Default: None.</span>
<span class="sd">    :type initBfgs: numpy.array</span>

<span class="sd">    :param eps: the algorithm stops when this precision is reached.</span>
<span class="sd">                 Default: :math:`\\varepsilon^{\\frac{1}{3}}`</span>
<span class="sd">    :type eps: float</span>

<span class="sd">    :param maxiter: the algorithm stops if this number of iterations</span>
<span class="sd">                    is reached. Default: 1000</span>
<span class="sd">    :type maxiter: int</span>

<span class="sd">    :return: tuple x, messages, where</span>

<span class="sd">            - x is the solution found,</span>

<span class="sd">            - messages is a dictionary reporting various aspects</span>
<span class="sd">              related to the run of the algorithm.</span>

<span class="sd">    :rtype: numpy.array, dict(str:object)</span>

<span class="sd">    :raises biogeme.exceptions.biogemeError: if the dimensions of the</span>
<span class="sd">             matrix initBfgs do not match the length of x0.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">x0</span><span class="p">)</span>
    <span class="n">xk</span> <span class="o">=</span> <span class="n">x0</span>
    <span class="n">fct</span><span class="o">.</span><span class="n">setVariables</span><span class="p">(</span><span class="n">xk</span><span class="p">)</span>
    <span class="n">f</span><span class="p">,</span> <span class="n">g</span> <span class="o">=</span> <span class="n">fct</span><span class="o">.</span><span class="n">f_g</span><span class="p">()</span>
    <span class="n">nfev</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="n">ngev</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="k">if</span> <span class="n">initBfgs</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">Hinv</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">identity</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">initBfgs</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
            <span class="n">errorMsg</span> <span class="o">=</span> <span class="p">(</span>
                <span class="sa">f</span><span class="s1">&#39;BFGS must be initialized with a </span><span class="si">{</span><span class="n">n</span><span class="si">}</span><span class="s1">x</span><span class="si">{</span><span class="n">n</span><span class="si">}</span><span class="s1"> &#39;</span>
                <span class="sa">f</span><span class="s1">&#39;matrix and not a </span><span class="si">{</span><span class="n">initBfgs</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s1">&#39;</span>
                <span class="s1">&#39;x</span><span class="si">{initBfgs.shape[1]}</span><span class="s1"> matrix.&#39;</span>
            <span class="p">)</span>
            <span class="k">raise</span> <span class="n">excep</span><span class="o">.</span><span class="n">biogemeError</span><span class="p">(</span><span class="n">errorMsg</span><span class="p">)</span>
        <span class="n">Hinv</span> <span class="o">=</span> <span class="n">initBfgs</span>
    <span class="n">typx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">xk</span><span class="p">)</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
    <span class="n">typf</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">f</span><span class="p">),</span> <span class="mf">1.0</span><span class="p">)</span>
    <span class="n">relgrad</span> <span class="o">=</span> <span class="n">relativeGradient</span><span class="p">(</span><span class="n">xk</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">g</span><span class="p">,</span> <span class="n">typx</span><span class="p">,</span> <span class="n">typf</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">relgrad</span> <span class="o">&lt;=</span> <span class="n">eps</span><span class="p">:</span>
        <span class="n">message</span> <span class="o">=</span> <span class="sa">f</span><span class="s1">&#39;Relative gradient = </span><span class="si">{</span><span class="n">relgrad</span><span class="si">:</span><span class="s1">.2g</span><span class="si">}</span><span class="s1"> &lt;= </span><span class="si">{</span><span class="n">eps</span><span class="si">:</span><span class="s1">.2g</span><span class="si">}</span><span class="s1">&#39;</span>
        <span class="n">messages</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s1">&#39;Algorithm&#39;</span><span class="p">:</span> <span class="s1">&#39;Inverse BFGS with line search&#39;</span><span class="p">,</span>
            <span class="s1">&#39;Relative gradient&#39;</span><span class="p">:</span> <span class="n">relgrad</span><span class="p">,</span>
            <span class="s1">&#39;Cause of termination&#39;</span><span class="p">:</span> <span class="n">message</span><span class="p">,</span>
            <span class="s1">&#39;Number of iterations&#39;</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span>
            <span class="s1">&#39;Number of function evaluations&#39;</span><span class="p">:</span> <span class="n">nfev</span><span class="p">,</span>
            <span class="s1">&#39;Number of gradient evaluations&#39;</span><span class="p">:</span> <span class="n">ngev</span><span class="p">,</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="n">xk</span><span class="p">,</span> <span class="n">messages</span>
    <span class="n">k</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">nfev</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">cont</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="k">while</span> <span class="n">cont</span><span class="p">:</span>
        <span class="n">d</span> <span class="o">=</span> <span class="o">-</span><span class="n">Hinv</span> <span class="o">@</span> <span class="n">g</span>
        <span class="n">alpha</span><span class="p">,</span> <span class="n">nfls</span> <span class="o">=</span> <span class="n">lineSearch</span><span class="p">(</span><span class="n">fct</span><span class="p">,</span> <span class="n">xk</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">g</span><span class="p">,</span> <span class="n">d</span><span class="p">)</span>
        <span class="n">nfev</span> <span class="o">+=</span> <span class="n">nfls</span>
        <span class="n">delta</span> <span class="o">=</span> <span class="n">alpha</span> <span class="o">*</span> <span class="n">d</span>
        <span class="n">xk</span> <span class="o">=</span> <span class="n">xk</span> <span class="o">+</span> <span class="n">delta</span>
        <span class="n">gprev</span> <span class="o">=</span> <span class="n">g</span>
        <span class="n">fct</span><span class="o">.</span><span class="n">setVariables</span><span class="p">(</span><span class="n">xk</span><span class="p">)</span>
        <span class="n">f</span><span class="p">,</span> <span class="n">g</span> <span class="o">=</span> <span class="n">fct</span><span class="o">.</span><span class="n">f_g</span><span class="p">()</span>
        <span class="n">nfev</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="n">ngev</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="n">Hinv</span> <span class="o">=</span> <span class="n">inverseBfgs</span><span class="p">(</span><span class="n">Hinv</span><span class="p">,</span> <span class="n">delta</span><span class="p">,</span> <span class="n">g</span> <span class="o">-</span> <span class="n">gprev</span><span class="p">)</span>
        <span class="n">nfev</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="n">k</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="n">relgrad</span> <span class="o">=</span> <span class="n">relativeGradient</span><span class="p">(</span><span class="n">xk</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">g</span><span class="p">,</span> <span class="n">typx</span><span class="p">,</span> <span class="n">typf</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">relgrad</span> <span class="o">&lt;=</span> <span class="n">eps</span><span class="p">:</span>
            <span class="n">message</span> <span class="o">=</span> <span class="sa">f</span><span class="s1">&#39;Relative gradient = </span><span class="si">{</span><span class="n">relgrad</span><span class="si">:</span><span class="s1">.2g</span><span class="si">}</span><span class="s1"> &lt;= </span><span class="si">{</span><span class="n">eps</span><span class="si">:</span><span class="s1">.2g</span><span class="si">}</span><span class="s1">&#39;</span>
            <span class="n">cont</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="n">k</span> <span class="o">==</span> <span class="n">maxiter</span><span class="p">:</span>
            <span class="n">message</span> <span class="o">=</span> <span class="sa">f</span><span class="s1">&#39;Maximum number of iterations reached: </span><span class="si">{</span><span class="n">maxiter</span><span class="si">}</span><span class="s1">&#39;</span>
            <span class="n">cont</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">detailed</span><span class="p">(</span>
            <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">k</span><span class="si">}</span><span class="s1"> f=</span><span class="si">{</span><span class="n">f</span><span class="si">:</span><span class="s1">10.7g</span><span class="si">}</span><span class="s1"> relgrad=</span><span class="si">{</span><span class="n">relgrad</span><span class="si">:</span><span class="s1">6.2g</span><span class="si">}</span><span class="s1">&#39;</span> <span class="sa">f</span><span class="s1">&#39; alpha=</span><span class="si">{</span><span class="n">alpha</span><span class="si">:</span><span class="s1">6.2g</span><span class="si">}</span><span class="s1">&#39;</span>
        <span class="p">)</span>
    <span class="n">messages</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s1">&#39;Algorithm&#39;</span><span class="p">:</span> <span class="s1">&#39;Inverse BFGS with line search&#39;</span><span class="p">,</span>
        <span class="s1">&#39;Relative gradient&#39;</span><span class="p">:</span> <span class="n">relgrad</span><span class="p">,</span>
        <span class="s1">&#39;Cause of termination&#39;</span><span class="p">:</span> <span class="n">message</span><span class="p">,</span>
        <span class="s1">&#39;Number of iterations&#39;</span><span class="p">:</span> <span class="n">k</span><span class="p">,</span>
        <span class="s1">&#39;Number of function evaluations&#39;</span><span class="p">:</span> <span class="n">nfev</span><span class="p">,</span>
        <span class="s1">&#39;Number of gradient evaluations&#39;</span><span class="p">:</span> <span class="n">ngev</span><span class="p">,</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="n">xk</span><span class="p">,</span> <span class="n">messages</span></div>


<div class="viewcode-block" id="bfgsTrustRegion"><a class="viewcode-back" href="../../algorithms.html#biogeme.algorithms.bfgsTrustRegion">[docs]</a><span class="k">def</span> <span class="nf">bfgsTrustRegion</span><span class="p">(</span>
    <span class="n">fct</span><span class="p">,</span>
    <span class="n">x0</span><span class="p">,</span>
    <span class="n">initBfgs</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">delta0</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span>
    <span class="n">eps</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">finfo</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span><span class="o">.</span><span class="n">eps</span> <span class="o">**</span> <span class="mf">0.3333</span><span class="p">,</span>
    <span class="n">dl</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">maxiter</span><span class="o">=</span><span class="mi">1000</span><span class="p">,</span>
    <span class="n">eta1</span><span class="o">=</span><span class="mf">0.01</span><span class="p">,</span>
    <span class="n">eta2</span><span class="o">=</span><span class="mf">0.9</span><span class="p">,</span>
<span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;BFGS method with trust region</span>

<span class="sd">    :param fct: object to calculate the objective function and its derivatives.</span>
<span class="sd">    :type fct: optimization.functionToMinimize</span>

<span class="sd">    :param x0: starting point</span>
<span class="sd">    :type x0: numpy.array</span>

<span class="sd">    :param initBfgs: matrix used to initialize BFGS. If None, the</span>
<span class="sd">                     identity matrix is used. Default: None.</span>
<span class="sd">    :type initBfgs: numpy.array</span>

<span class="sd">    :param delta0: initial radius of the trust region. Default: 100.</span>
<span class="sd">    :type delta0: float</span>

<span class="sd">    :param eps: the algorithm stops when this precision is reached.</span>
<span class="sd">                Default: :math:`\\varepsilon^{\\frac{1}{3}}`</span>
<span class="sd">    :type eps: float</span>

<span class="sd">    :param dl: If True, the Dogleg method is used to solve the</span>
<span class="sd">       trut region subproblem. If False, the truncated conjugate</span>
<span class="sd">       gradient is used. Default: False.</span>
<span class="sd">    :type dl: bool</span>

<span class="sd">    :param maxiter: the algorithm stops if this number of iterations</span>
<span class="sd">                    is reached. Default: 1000.</span>
<span class="sd">    :type maxiter: int</span>

<span class="sd">    :param eta1: threshold for failed iterations. Default: 0.01.</span>
<span class="sd">    :type eta1: float</span>

<span class="sd">    :param eta2: threshold for very successful iterations. Default 0.9.</span>
<span class="sd">    :type eta2: float</span>

<span class="sd">    :return: tuple x, messages, where</span>

<span class="sd">            - x is the solution found,</span>

<span class="sd">            - messages is a dictionary reporting various aspects</span>
<span class="sd">              related to the run of the algorithm.</span>

<span class="sd">    :rtype: numpy.array, dict(str:object)</span>

<span class="sd">    :raises biogeme.exceptions.biogemeError: if the dimensions of the</span>
<span class="sd">              matrix initBfgs do not match the length of x0.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">k</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">xk</span> <span class="o">=</span> <span class="n">x0</span>
    <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">x0</span><span class="p">)</span>
    <span class="n">fct</span><span class="o">.</span><span class="n">setVariables</span><span class="p">(</span><span class="n">xk</span><span class="p">)</span>
    <span class="n">f</span><span class="p">,</span> <span class="n">g</span> <span class="o">=</span> <span class="n">fct</span><span class="o">.</span><span class="n">f_g</span><span class="p">()</span>
    <span class="n">nfev</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="n">ngev</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="k">if</span> <span class="n">initBfgs</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">H</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">identity</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">initBfgs</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
            <span class="n">errorMsg</span> <span class="o">=</span> <span class="p">(</span>
                <span class="sa">f</span><span class="s1">&#39;BFGS must be initialized with a </span><span class="si">{</span><span class="n">n</span><span class="si">}</span><span class="s1">x</span><span class="si">{</span><span class="n">n</span><span class="si">}</span><span class="s1"> &#39;</span>
                <span class="sa">f</span><span class="s1">&#39;matrix and not a </span><span class="si">{</span><span class="n">initBfgs</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s1">&#39;</span>
                <span class="sa">f</span><span class="s1">&#39;x</span><span class="si">{</span><span class="n">initBfgs</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="si">}</span><span class="s1"> matrix.&#39;</span>
            <span class="p">)</span>
            <span class="k">raise</span> <span class="n">excep</span><span class="o">.</span><span class="n">biogemeError</span><span class="p">(</span><span class="n">errorMsg</span><span class="p">)</span>
        <span class="n">H</span> <span class="o">=</span> <span class="n">initBfgs</span>
    <span class="n">typx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">xk</span><span class="p">)</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
    <span class="n">typf</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">f</span><span class="p">),</span> <span class="mf">1.0</span><span class="p">)</span>
    <span class="n">relgrad</span> <span class="o">=</span> <span class="n">relativeGradient</span><span class="p">(</span><span class="n">xk</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">g</span><span class="p">,</span> <span class="n">typx</span><span class="p">,</span> <span class="n">typf</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">relgrad</span> <span class="o">&lt;=</span> <span class="n">eps</span><span class="p">:</span>
        <span class="n">message</span> <span class="o">=</span> <span class="sa">f</span><span class="s1">&#39;Relative gradient = </span><span class="si">{</span><span class="n">relgrad</span><span class="si">:</span><span class="s1">.2g</span><span class="si">}</span><span class="s1"> &lt;= </span><span class="si">{</span><span class="n">eps</span><span class="si">:</span><span class="s1">.2g</span><span class="si">}</span><span class="s1">&#39;</span>
        <span class="n">messages</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s1">&#39;Algorithm&#39;</span><span class="p">:</span> <span class="s1">&#39;BFGS with trust region&#39;</span><span class="p">,</span>
            <span class="s1">&#39;Relative gradient&#39;</span><span class="p">:</span> <span class="n">relgrad</span><span class="p">,</span>
            <span class="s1">&#39;Cause of termination&#39;</span><span class="p">:</span> <span class="n">message</span><span class="p">,</span>
            <span class="s1">&#39;Number of iterations&#39;</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span>
            <span class="s1">&#39;Number of function evaluations&#39;</span><span class="p">:</span> <span class="n">nfev</span><span class="p">,</span>
            <span class="s1">&#39;Number of gradient evaluations&#39;</span><span class="p">:</span> <span class="n">ngev</span><span class="p">,</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="n">xk</span><span class="p">,</span> <span class="n">messages</span>
    <span class="n">delta</span> <span class="o">=</span> <span class="n">delta0</span>
    <span class="n">cont</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="n">maxDelta</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">finfo</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span><span class="o">.</span><span class="n">max</span>
    <span class="n">minDelta</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">finfo</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span><span class="o">.</span><span class="n">eps</span>
    <span class="n">rho</span> <span class="o">=</span> <span class="mf">0.0</span>
    <span class="k">while</span> <span class="n">cont</span><span class="p">:</span>
        <span class="n">k</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">if</span> <span class="n">dl</span><span class="p">:</span>
            <span class="n">step</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">dogleg</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">H</span><span class="p">,</span> <span class="n">delta</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">step</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">truncatedConjugateGradient</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">H</span><span class="p">,</span> <span class="n">delta</span><span class="p">)</span>
        <span class="n">xc</span> <span class="o">=</span> <span class="n">xk</span> <span class="o">+</span> <span class="n">step</span>
        <span class="n">fct</span><span class="o">.</span><span class="n">setVariables</span><span class="p">(</span><span class="n">xc</span><span class="p">)</span>
        <span class="c1"># Calculate the value of the function</span>
        <span class="n">fc</span> <span class="o">=</span> <span class="n">fct</span><span class="o">.</span><span class="n">f</span><span class="p">()</span>
        <span class="n">nfev</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">if</span> <span class="n">fc</span> <span class="o">&gt;=</span> <span class="n">f</span><span class="p">:</span>
            <span class="n">delta</span> <span class="o">=</span> <span class="n">la</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">step</span><span class="p">)</span> <span class="o">/</span> <span class="mf">2.0</span>
            <span class="n">status</span> <span class="o">=</span> <span class="s1">&#39;-&#39;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">num</span> <span class="o">=</span> <span class="n">f</span> <span class="o">-</span> <span class="n">fc</span>
            <span class="n">denom</span> <span class="o">=</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">inner</span><span class="p">(</span><span class="n">step</span><span class="p">,</span> <span class="n">g</span><span class="p">)</span> <span class="o">-</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">inner</span><span class="p">(</span><span class="n">step</span><span class="p">,</span> <span class="n">H</span> <span class="o">@</span> <span class="n">step</span><span class="p">)</span>
            <span class="n">rho</span> <span class="o">=</span> <span class="n">num</span> <span class="o">/</span> <span class="n">denom</span>
            <span class="k">if</span> <span class="n">rho</span> <span class="o">&lt;</span> <span class="n">eta1</span><span class="p">:</span>
                <span class="c1"># Failure: reduce the trust region</span>
                <span class="n">delta</span> <span class="o">=</span> <span class="n">la</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">step</span><span class="p">)</span> <span class="o">/</span> <span class="mf">2.0</span>
                <span class="n">status</span> <span class="o">=</span> <span class="s1">&#39;-&#39;</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># Candidate accepted</span>
                <span class="n">fc</span><span class="p">,</span> <span class="n">gc</span> <span class="o">=</span> <span class="n">fct</span><span class="o">.</span><span class="n">f_g</span><span class="p">()</span>
                <span class="n">nfev</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="n">ngev</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="n">d</span> <span class="o">=</span> <span class="n">xc</span> <span class="o">-</span> <span class="n">xk</span>
                <span class="n">y</span> <span class="o">=</span> <span class="n">gc</span> <span class="o">-</span> <span class="n">g</span>
                <span class="n">xk</span> <span class="o">=</span> <span class="n">xc</span>
                <span class="n">f</span> <span class="o">=</span> <span class="n">fc</span>
                <span class="n">g</span> <span class="o">=</span> <span class="n">gc</span>
                <span class="n">H</span> <span class="o">=</span> <span class="n">bfgs</span><span class="p">(</span><span class="n">H</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">rho</span> <span class="o">&gt;=</span> <span class="n">eta2</span><span class="p">:</span>
                    <span class="c1"># Enlarge the trust region</span>
                    <span class="n">delta</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">delta</span><span class="p">,</span> <span class="n">maxDelta</span><span class="p">)</span>
                    <span class="n">status</span> <span class="o">=</span> <span class="s1">&#39;++&#39;</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">status</span> <span class="o">=</span> <span class="s1">&#39;+&#39;</span>
                <span class="n">relgrad</span> <span class="o">=</span> <span class="n">relativeGradient</span><span class="p">(</span><span class="n">xk</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">g</span><span class="p">,</span> <span class="n">typx</span><span class="p">,</span> <span class="n">typf</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">relgrad</span> <span class="o">&lt;=</span> <span class="n">eps</span><span class="p">:</span>
                    <span class="n">message</span> <span class="o">=</span> <span class="sa">f</span><span class="s1">&#39;Relative gradient = </span><span class="si">{</span><span class="n">relgrad</span><span class="si">:</span><span class="s1">.2g</span><span class="si">}</span><span class="s1"> &lt;= </span><span class="si">{</span><span class="n">eps</span><span class="si">:</span><span class="s1">.2g</span><span class="si">}</span><span class="s1">&#39;</span>
                    <span class="n">cont</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="n">delta</span> <span class="o">&lt;=</span> <span class="n">minDelta</span><span class="p">:</span>
            <span class="n">message</span> <span class="o">=</span> <span class="sa">f</span><span class="s1">&#39;Trust region is too small: </span><span class="si">{</span><span class="n">delta</span><span class="si">}</span><span class="s1">&#39;</span>
            <span class="n">cont</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="n">k</span> <span class="o">==</span> <span class="n">maxiter</span><span class="p">:</span>
            <span class="n">message</span> <span class="o">=</span> <span class="sa">f</span><span class="s1">&#39;Maximum number of iterations reached: </span><span class="si">{</span><span class="n">maxiter</span><span class="si">}</span><span class="s1">&#39;</span>
            <span class="n">cont</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">detailed</span><span class="p">(</span>
            <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">k</span><span class="si">}</span><span class="s1"> f=</span><span class="si">{</span><span class="n">f</span><span class="si">:</span><span class="s1">10.7g</span><span class="si">}</span><span class="s1"> relgrad=</span><span class="si">{</span><span class="n">relgrad</span><span class="si">:</span><span class="s1">6.2g</span><span class="si">}</span><span class="s1">&#39;</span>
            <span class="sa">f</span><span class="s1">&#39; delta=</span><span class="si">{</span><span class="n">delta</span><span class="si">:</span><span class="s1">6.2g</span><span class="si">}</span><span class="s1"> &#39;</span>
            <span class="sa">f</span><span class="s1">&#39;rho=</span><span class="si">{</span><span class="n">rho</span><span class="si">:</span><span class="s1">6.2g</span><span class="si">}</span><span class="s1"> </span><span class="si">{</span><span class="n">status</span><span class="si">}</span><span class="s1">&#39;</span>
        <span class="p">)</span>

    <span class="n">messages</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s1">&#39;Algorithm&#39;</span><span class="p">:</span> <span class="s1">&#39;BFGS with trust region&#39;</span><span class="p">,</span>
        <span class="s1">&#39;Relative gradient&#39;</span><span class="p">:</span> <span class="n">relgrad</span><span class="p">,</span>
        <span class="s1">&#39;Cause of termination&#39;</span><span class="p">:</span> <span class="n">message</span><span class="p">,</span>
        <span class="s1">&#39;Number of iterations&#39;</span><span class="p">:</span> <span class="n">k</span><span class="p">,</span>
        <span class="s1">&#39;Number of function evaluations&#39;</span><span class="p">:</span> <span class="n">nfev</span><span class="p">,</span>
        <span class="s1">&#39;Number of gradient evaluations&#39;</span><span class="p">:</span> <span class="n">ngev</span><span class="p">,</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="n">xk</span><span class="p">,</span> <span class="n">messages</span></div>


<div class="viewcode-block" id="truncatedConjugateGradientSubspace"><a class="viewcode-back" href="../../algorithms.html#biogeme.algorithms.truncatedConjugateGradientSubspace">[docs]</a><span class="k">def</span> <span class="nf">truncatedConjugateGradientSubspace</span><span class="p">(</span>
    <span class="n">xk</span><span class="p">,</span>
    <span class="n">gk</span><span class="p">,</span>
    <span class="n">Hk</span><span class="p">,</span>
    <span class="n">delta</span><span class="p">,</span>
    <span class="n">bounds</span><span class="p">,</span>
    <span class="n">infeasibleIterate</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">tol</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">finfo</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span><span class="o">.</span><span class="n">eps</span> <span class="o">**</span> <span class="mf">0.3333</span><span class="p">,</span>
<span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Find an approximation of the solution of the trust region</span>
<span class="sd">    subproblem using the truncated conjugate gradient method within</span>
<span class="sd">    the subspace of free variables. Free variables are those</span>
<span class="sd">    corresponding to inactive constraints at the generalized Cauchy</span>
<span class="sd">    point.</span>

<span class="sd">    :param xk: current iterate.</span>
<span class="sd">    :type xk: numpy.array</span>

<span class="sd">    :param gk: gradient of the quadratic model.</span>
<span class="sd">    :type gk: numpy.array</span>

<span class="sd">    :param Hk: hessian of the quadrartic model.</span>
<span class="sd">    :type Hk: numpy.array</span>

<span class="sd">    :param delta: radius of the trust region.</span>
<span class="sd">    :type delta: float</span>

<span class="sd">    :param bounds: bounds on the variables.</span>
<span class="sd">    :type bounds: class bioBounds</span>

<span class="sd">    :param infeasibleIterate: if True, the algorithm may continue</span>
<span class="sd">                              until termination.  The result will then</span>
<span class="sd">                              be projected on the feasible domain.  If</span>
<span class="sd">                              False, the algorithm stops as soon as an</span>
<span class="sd">                              infeasible iterate is generated.</span>
<span class="sd">                              Default: False.</span>

<span class="sd">    :type infeasibleIterate: bool</span>

<span class="sd">    :param tol: tolerance used for stopping criterion.</span>
<span class="sd">    :type tol: float</span>

<span class="sd">    :return: d, diagnostic, where</span>

<span class="sd">          - d is the approximate solution of the trust region subproblem,</span>
<span class="sd">          - diagnostic is the nature of the solution:</span>

<span class="sd">            * 1 for convergence,</span>
<span class="sd">            * 2 if out of the trust region,</span>
<span class="sd">            * 3 if negative curvature detected.</span>
<span class="sd">            * 4 if a numerical problem has been encountered</span>

<span class="sd">    :rtype: numpy.array, int</span>

<span class="sd">    :raises biogeme.exceptions.biogemeError: if the dimensions are inconsistent</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">xk</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
        <span class="k">raise</span> <span class="n">excep</span><span class="o">.</span><span class="n">biogemeError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Invalid xk: </span><span class="si">{</span><span class="n">xk</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">gk</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
        <span class="k">raise</span> <span class="n">excep</span><span class="o">.</span><span class="n">biogemeError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Invalid gk: </span><span class="si">{</span><span class="n">gk</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">Hk</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
        <span class="k">raise</span> <span class="n">excep</span><span class="o">.</span><span class="n">biogemeError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Invalid Hk: </span><span class="si">{</span><span class="n">Hk</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>

    <span class="c1"># First, we calculate the intersection between the trust region on</span>
    <span class="c1"># the bounds. The trust region is also a bound constraint (based</span>
    <span class="c1"># on infinity norm) of radius &#39;delta&#39;, centered at xk.</span>

    <span class="n">intersection</span> <span class="o">=</span> <span class="n">bounds</span><span class="o">.</span><span class="n">intersectionWithTrustRegion</span><span class="p">(</span><span class="n">xk</span><span class="p">,</span> <span class="n">delta</span><span class="p">)</span>

    <span class="c1"># Then, we calculate the generalized Cauchy point</span>
    <span class="n">gcp</span> <span class="o">=</span> <span class="n">intersection</span><span class="o">.</span><span class="n">generalizedCauchyPoint</span><span class="p">(</span><span class="n">xk</span><span class="p">,</span> <span class="n">gk</span><span class="p">,</span> <span class="n">Hk</span><span class="p">,</span> <span class="o">-</span><span class="n">gk</span><span class="p">)</span>

    <span class="n">x</span> <span class="o">=</span> <span class="n">gcp</span>
    <span class="n">r</span> <span class="o">=</span> <span class="o">-</span><span class="n">gk</span> <span class="o">-</span> <span class="n">Hk</span> <span class="o">@</span> <span class="p">(</span><span class="n">x</span> <span class="o">-</span> <span class="n">xk</span><span class="p">)</span>

    <span class="n">etak</span> <span class="o">=</span> <span class="n">tol</span>

    <span class="n">activityStatus</span> <span class="o">=</span> <span class="n">intersection</span><span class="o">.</span><span class="n">activity</span><span class="p">(</span><span class="n">gcp</span><span class="p">)</span>
    <span class="n">freeVariables</span> <span class="o">=</span> <span class="n">activityStatus</span> <span class="o">==</span> <span class="mi">0</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">freeVariables</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
        <span class="k">return</span> <span class="n">gcp</span><span class="p">,</span> <span class="mi">1</span>

    <span class="n">xbar</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="n">freeVariables</span><span class="p">]</span>
    <span class="n">rbar</span> <span class="o">=</span> <span class="n">r</span><span class="p">[</span><span class="n">freeVariables</span><span class="p">]</span>

    <span class="c1"># Extract the  bounds for the free variables</span>
    <span class="n">boundsBar</span> <span class="o">=</span> <span class="n">intersection</span><span class="o">.</span><span class="n">subspace</span><span class="p">(</span><span class="n">freeVariables</span><span class="p">)</span>
    <span class="n">Bbar</span> <span class="o">=</span> <span class="n">Hk</span><span class="p">[</span><span class="n">freeVariables</span><span class="p">][:,</span> <span class="n">freeVariables</span><span class="p">]</span>
    <span class="n">pbar</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">rbar</span><span class="p">)</span>
    <span class="n">rho1</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="n">rho2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">inner</span><span class="p">(</span><span class="n">rbar</span><span class="p">,</span> <span class="n">rbar</span><span class="p">)</span>

    <span class="k">while</span> <span class="n">rho2</span> <span class="o">&gt;=</span> <span class="n">etak</span> <span class="o">*</span> <span class="n">etak</span><span class="p">:</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">beta</span> <span class="o">=</span> <span class="n">rho2</span> <span class="o">/</span> <span class="n">rho1</span>
            <span class="n">pbar</span> <span class="o">=</span> <span class="n">rbar</span> <span class="o">+</span> <span class="n">beta</span> <span class="o">*</span> <span class="n">pbar</span>
            <span class="n">ybar</span> <span class="o">=</span> <span class="n">Bbar</span> <span class="o">@</span> <span class="n">pbar</span>

            <span class="k">if</span> <span class="n">boundsBar</span><span class="o">.</span><span class="n">feasible</span><span class="p">(</span><span class="n">xbar</span><span class="p">):</span>
                <span class="n">feasible</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="n">alpha1</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">boundsBar</span><span class="o">.</span><span class="n">maximumStep</span><span class="p">(</span><span class="n">xbar</span><span class="p">,</span> <span class="n">pbar</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">feasible</span> <span class="o">=</span> <span class="kc">False</span>

            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">inner</span><span class="p">(</span><span class="n">pbar</span><span class="p">,</span> <span class="n">ybar</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
                <span class="c1"># Negative curvature has been detected.</span>
                <span class="k">if</span> <span class="n">feasible</span><span class="p">:</span>
                    <span class="n">x</span><span class="p">[</span><span class="n">freeVariables</span><span class="p">]</span> <span class="o">=</span> <span class="n">xbar</span> <span class="o">+</span> <span class="n">alpha1</span> <span class="o">*</span> <span class="n">pbar</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">x</span><span class="p">[</span><span class="n">freeVariables</span><span class="p">]</span> <span class="o">=</span> <span class="n">xbar</span>
                <span class="k">return</span> <span class="n">bounds</span><span class="o">.</span><span class="n">project</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="mi">3</span>

            <span class="n">alpha2</span> <span class="o">=</span> <span class="n">rho2</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">inner</span><span class="p">(</span><span class="n">pbar</span><span class="p">,</span> <span class="n">ybar</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">infeasibleIterate</span> <span class="ow">and</span> <span class="n">alpha2</span> <span class="o">&gt;</span> <span class="n">alpha1</span><span class="p">:</span>
                <span class="c1"># Infeasible iterate</span>
                <span class="n">x</span><span class="p">[</span><span class="n">freeVariables</span><span class="p">]</span> <span class="o">=</span> <span class="n">xbar</span> <span class="o">+</span> <span class="n">alpha1</span> <span class="o">*</span> <span class="n">pbar</span>
                <span class="k">return</span> <span class="n">x</span><span class="p">,</span> <span class="mi">2</span>

            <span class="n">xbar</span> <span class="o">=</span> <span class="n">xbar</span> <span class="o">+</span> <span class="n">alpha2</span> <span class="o">*</span> <span class="n">pbar</span>
            <span class="n">rbar</span> <span class="o">=</span> <span class="n">rbar</span> <span class="o">-</span> <span class="n">alpha2</span> <span class="o">*</span> <span class="n">ybar</span>
            <span class="n">rho1</span> <span class="o">=</span> <span class="n">rho2</span>
            <span class="n">rho2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">inner</span><span class="p">(</span><span class="n">rbar</span><span class="p">,</span> <span class="n">rbar</span><span class="p">)</span>

        <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
            <span class="c1"># Numerical problem detected. Return the current value of x</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s1">&#39;Numerical problem in conjugate gradient algorithm&#39;</span><span class="p">)</span>
            <span class="n">x</span><span class="p">[</span><span class="n">freeVariables</span><span class="p">]</span> <span class="o">=</span> <span class="n">xbar</span>
            <span class="k">if</span> <span class="n">infeasibleIterate</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">bounds</span><span class="o">.</span><span class="n">project</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="mi">4</span>
            <span class="k">return</span> <span class="n">x</span><span class="p">,</span> <span class="mi">4</span>

        <span class="n">x</span><span class="p">[</span><span class="n">freeVariables</span><span class="p">]</span> <span class="o">=</span> <span class="n">xbar</span>
    <span class="k">if</span> <span class="n">infeasibleIterate</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">bounds</span><span class="o">.</span><span class="n">project</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="mi">4</span>
    <span class="k">return</span> <span class="n">x</span><span class="p">,</span> <span class="mi">1</span></div>


<div class="viewcode-block" id="simpleBoundsNewtonAlgorithm"><a class="viewcode-back" href="../../algorithms.html#biogeme.algorithms.simpleBoundsNewtonAlgorithm">[docs]</a><span class="k">def</span> <span class="nf">simpleBoundsNewtonAlgorithm</span><span class="p">(</span>
    <span class="n">fct</span><span class="p">,</span>
    <span class="n">bounds</span><span class="p">,</span>
    <span class="n">x0</span><span class="p">,</span>
    <span class="n">proportionTrueHessian</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span>
    <span class="n">infeasibleConjugateGradient</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">delta0</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span>
    <span class="n">tol</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">finfo</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span><span class="o">.</span><span class="n">eps</span> <span class="o">**</span> <span class="mf">0.3333</span><span class="p">,</span>
    <span class="n">steptol</span><span class="o">=</span><span class="mf">1.0e-5</span><span class="p">,</span>
    <span class="n">cgtol</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">finfo</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span><span class="o">.</span><span class="n">eps</span> <span class="o">**</span> <span class="mf">0.3333</span><span class="p">,</span>
    <span class="n">maxiter</span><span class="o">=</span><span class="mi">1000</span><span class="p">,</span>
    <span class="n">eta1</span><span class="o">=</span><span class="mf">0.01</span><span class="p">,</span>
    <span class="n">eta2</span><span class="o">=</span><span class="mf">0.9</span><span class="p">,</span>
    <span class="n">enlargingFactor</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span>
<span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Trust region algorithm for problems with simple bounds</span>

<span class="sd">    :param fct: object to calculate the objective function and its derivatives.</span>
<span class="sd">    :type fct: optimization.functionToMinimize</span>

<span class="sd">    :param bounds: bounds on the variables</span>
<span class="sd">    :type bounds: class bounds</span>

<span class="sd">    :param x0: starting point</span>
<span class="sd">    :type x0: numpy.array</span>

<span class="sd">    :param proportionTrueHessian: proportion of the iterations where</span>
<span class="sd">                                  the true hessian is calculated. When</span>
<span class="sd">                                  not, the BFGS update is used. If</span>
<span class="sd">                                  1.0, it is used for all</span>
<span class="sd">                                  iterations. If 0.0, it is not used</span>
<span class="sd">                                  at all.</span>
<span class="sd">    :type proportionTrueHessian: float</span>

<span class="sd">    :param infeasibleConjugateGradient: if True, the conjugate</span>
<span class="sd">                              gradient algorithm may generate until</span>
<span class="sd">                              termination.  The result will then be</span>
<span class="sd">                              projected on the feasible domain.  If</span>
<span class="sd">                              False, the algorithm stops as soon as an</span>
<span class="sd">                              infeasible iterate is generated.</span>
<span class="sd">                              Default: False.</span>
<span class="sd">    :type infeasibleConjugateGradient: bool</span>

<span class="sd">    :param delta0: initial radius of the trust region. Default: 100.</span>
<span class="sd">    :type delta0: float</span>

<span class="sd">    :param tol: the algorithm stops when this precision is reached.</span>
<span class="sd">                Default: :math:`\\varepsilon^{\\frac{1}{3}}`</span>
<span class="sd">    :type tol: float</span>

<span class="sd">    :param steptol: the algorithm stops when the relative change in x</span>
<span class="sd">                is below this threshold. Basically, if p significant</span>
<span class="sd">                digits of x are needed, steptol should be set to</span>
<span class="sd">                1.0e-p.  Default: :math:`10^{-5}`</span>

<span class="sd">    :type steptol: float</span>


<span class="sd">    :param cgtol: the conjugate gradient algorithm stops when this</span>
<span class="sd">                  precision is reached.  Default:</span>
<span class="sd">                  :math:`\\varepsilon^{\\frac{1}{3}}`</span>

<span class="sd">    :type cgtol: float</span>

<span class="sd">    :param maxiter: the algorithm stops if this number of iterations</span>
<span class="sd">                    is reached. Default: 1000.</span>

<span class="sd">    :type maxiter: int</span>

<span class="sd">    :param eta1: threshold for failed iterations. Default: 0.01.</span>
<span class="sd">    :type eta1: float</span>

<span class="sd">    :param eta2: threshold for very successful iterations. Default 0.9.</span>
<span class="sd">    :type eta2: float</span>

<span class="sd">    :param enlargingFactor: if an iteration is very successful, the</span>
<span class="sd">                            radius of the trust region is multiplied</span>
<span class="sd">                            by this factor. Default 10.</span>
<span class="sd">    :type enlargingFactor: float</span>

<span class="sd">    :return: x, messages</span>

<span class="sd">        - x is the solution generated by the algorithm,</span>
<span class="sd">        - messages is a dictionary describing information about the lagorithm</span>

<span class="sd">    :rtype: numpay.array, dict(str:object)</span>

<span class="sd">    :raises biogeme.exceptions.biogemeError: if the dimensions of the</span>
<span class="sd">             matrix initBfgs do not match the length of x0.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">x0</span><span class="p">)</span> <span class="o">!=</span> <span class="n">bounds</span><span class="o">.</span><span class="n">n</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">excep</span><span class="o">.</span><span class="n">biogemeError</span><span class="p">(</span>
            <span class="sa">f</span><span class="s1">&#39;Incompatible size:&#39;</span> <span class="sa">f</span><span class="s1">&#39; </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">x0</span><span class="p">)</span><span class="si">}</span><span class="s1"> and </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">bounds</span><span class="p">)</span><span class="si">}</span><span class="s1">&#39;</span>
        <span class="p">)</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">bounds</span><span class="o">.</span><span class="n">feasible</span><span class="p">(</span><span class="n">x0</span><span class="p">):</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span>
            <span class="s1">&#39;Initial point not feasible. &#39;</span>
            <span class="s1">&#39;It will be projected onto the feasible domain.&#39;</span>
        <span class="p">)</span>

    <span class="n">numberOfTrueHessian</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">numberOfMatrices</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="k">if</span> <span class="n">proportionTrueHessian</span> <span class="o">==</span> <span class="mf">1.0</span><span class="p">:</span>
        <span class="n">algo</span> <span class="o">=</span> <span class="s1">&#39;Newton with trust region for simple bound constraints&#39;</span>
    <span class="k">elif</span> <span class="n">proportionTrueHessian</span> <span class="o">==</span> <span class="mf">0.0</span><span class="p">:</span>
        <span class="n">algo</span> <span class="o">=</span> <span class="s1">&#39;BFGS with trust region for simple bound constraints&#39;</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">algo</span> <span class="o">=</span> <span class="p">(</span>
            <span class="sa">f</span><span class="s1">&#39;Hybrid Newton [</span><span class="si">{</span><span class="mi">100</span><span class="o">*</span><span class="n">proportionTrueHessian</span><span class="si">}</span><span class="s1">%] with trust &#39;</span>
            <span class="sa">f</span><span class="s1">&#39;region for simple bound constraints&#39;</span>
        <span class="p">)</span>

    <span class="n">k</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">xk</span> <span class="o">=</span> <span class="n">bounds</span><span class="o">.</span><span class="n">project</span><span class="p">(</span><span class="n">x0</span><span class="p">)</span>
    <span class="n">fct</span><span class="o">.</span><span class="n">setVariables</span><span class="p">(</span><span class="n">xk</span><span class="p">)</span>
    <span class="n">nfev</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">ngev</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">nhev</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">if</span> <span class="n">proportionTrueHessian</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">f</span><span class="p">,</span> <span class="n">g</span><span class="p">,</span> <span class="n">H</span> <span class="o">=</span> <span class="n">fct</span><span class="o">.</span><span class="n">f_g_h</span><span class="p">()</span>
        <span class="n">nfev</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="n">ngev</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="n">nhev</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="n">numberOfTrueHessian</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="n">numberOfMatrices</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="c1"># If there is a numerical problem with the Hessian, we use BFGS instead</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">H</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">()</span> <span class="ow">or</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">H</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mf">1.0e100</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span>
                <span class="sa">f</span><span class="s1">&#39;Numerical problem with the second derivative&#39;</span>
                <span class="sa">f</span><span class="s1">&#39; matrix at the starting point. Norm = &#39;</span>
                <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">H</span><span class="p">)</span><span class="si">}</span><span class="s1">. Replaced by the &#39;</span>
                <span class="sa">f</span><span class="s1">&#39;identity matrix.&#39;</span>
            <span class="p">)</span>
            <span class="n">H</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">xk</span><span class="p">))</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">f</span><span class="p">,</span> <span class="n">g</span> <span class="o">=</span> <span class="n">fct</span><span class="o">.</span><span class="n">f_g</span><span class="p">()</span>
        <span class="n">nfev</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="n">ngev</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="n">H</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">xk</span><span class="p">))</span>
        <span class="n">numberOfMatrices</span> <span class="o">+=</span> <span class="mi">1</span>

    <span class="n">projectedGradient</span> <span class="o">=</span> <span class="n">bounds</span><span class="o">.</span><span class="n">project</span><span class="p">(</span><span class="n">xk</span> <span class="o">-</span> <span class="n">g</span><span class="p">)</span> <span class="o">-</span> <span class="n">xk</span>
    <span class="n">typx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">xk</span><span class="p">)</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
    <span class="n">typf</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">f</span><span class="p">),</span> <span class="mf">1.0</span><span class="p">)</span>
    <span class="n">relchange</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">relgrad</span> <span class="o">=</span> <span class="n">relativeGradient</span><span class="p">(</span><span class="n">xk</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">projectedGradient</span><span class="p">,</span> <span class="n">typx</span><span class="p">,</span> <span class="n">typf</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">relgrad</span> <span class="o">&lt;=</span> <span class="n">tol</span><span class="p">:</span>
        <span class="n">message</span> <span class="o">=</span> <span class="sa">f</span><span class="s1">&#39;Relative gradient = </span><span class="si">{</span><span class="n">relgrad</span><span class="si">:</span><span class="s1">.2g</span><span class="si">}</span><span class="s1"> &lt;= </span><span class="si">{</span><span class="n">tol</span><span class="si">:</span><span class="s1">.2g</span><span class="si">}</span><span class="s1">&#39;</span>
        <span class="n">messages</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s1">&#39;Algorithm&#39;</span><span class="p">:</span> <span class="n">algo</span><span class="p">,</span>
            <span class="s1">&#39;Relative projected gradient&#39;</span><span class="p">:</span> <span class="n">relgrad</span><span class="p">,</span>
            <span class="s1">&#39;Number of iterations&#39;</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span>
            <span class="s1">&#39;Number of function evaluations&#39;</span><span class="p">:</span> <span class="n">nfev</span><span class="p">,</span>
            <span class="s1">&#39;Number of gradient evaluations&#39;</span><span class="p">:</span> <span class="n">ngev</span><span class="p">,</span>
            <span class="s1">&#39;Number of hessian evaluations&#39;</span><span class="p">:</span> <span class="n">nhev</span><span class="p">,</span>
            <span class="s1">&#39;Cause of termination&#39;</span><span class="p">:</span> <span class="n">message</span><span class="p">,</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="n">xk</span><span class="p">,</span> <span class="n">messages</span>

    <span class="n">delta</span> <span class="o">=</span> <span class="n">delta0</span>
    <span class="n">cont</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="n">maxDelta</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">finfo</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span><span class="o">.</span><span class="n">max</span>
    <span class="n">minDelta</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">finfo</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span><span class="o">.</span><span class="n">eps</span>
    <span class="n">rho</span> <span class="o">=</span> <span class="mf">0.0</span>
    <span class="k">while</span> <span class="n">cont</span><span class="p">:</span>
        <span class="n">k</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="c1"># Solve the quandratic problem in the subspace defined by the GCP</span>

        <span class="n">xc</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">truncatedConjugateGradientSubspace</span><span class="p">(</span>
            <span class="n">xk</span><span class="p">,</span> <span class="n">g</span><span class="p">,</span> <span class="n">H</span><span class="p">,</span> <span class="n">delta</span><span class="p">,</span> <span class="n">bounds</span><span class="p">,</span> <span class="n">infeasibleConjugateGradient</span><span class="p">,</span> <span class="n">cgtol</span>
        <span class="p">)</span>

        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">xc</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
            <span class="n">delta</span> <span class="o">=</span> <span class="n">delta</span> <span class="o">/</span> <span class="mf">2.0</span>
            <span class="n">status</span> <span class="o">=</span> <span class="s1">&#39;-&#39;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">failed</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">fct</span><span class="o">.</span><span class="n">setVariables</span><span class="p">(</span><span class="n">xc</span><span class="p">)</span>
                <span class="n">fc</span> <span class="o">=</span> <span class="n">fct</span><span class="o">.</span><span class="n">f</span><span class="p">()</span>
                <span class="n">nfev</span> <span class="o">+=</span> <span class="mi">1</span>

                <span class="n">num</span> <span class="o">=</span> <span class="n">f</span> <span class="o">-</span> <span class="n">fc</span>
                <span class="n">step</span> <span class="o">=</span> <span class="n">xc</span> <span class="o">-</span> <span class="n">xk</span>
                <span class="n">denom</span> <span class="o">=</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">inner</span><span class="p">(</span><span class="n">step</span><span class="p">,</span> <span class="n">g</span><span class="p">)</span> <span class="o">-</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">inner</span><span class="p">(</span><span class="n">step</span><span class="p">,</span> <span class="n">H</span> <span class="o">@</span> <span class="n">step</span><span class="p">)</span>
                <span class="n">rho</span> <span class="o">=</span> <span class="n">num</span> <span class="o">/</span> <span class="n">denom</span>
                <span class="n">failed</span> <span class="o">=</span> <span class="n">rho</span> <span class="o">&lt;</span> <span class="n">eta1</span>
            <span class="k">except</span> <span class="ne">RuntimeError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">e</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="n">xc</span><span class="p">)</span>
                <span class="n">failed</span> <span class="o">=</span> <span class="kc">True</span>

            <span class="k">if</span> <span class="n">failed</span><span class="p">:</span>
                <span class="c1"># Failure: reduce the trust region</span>
                <span class="n">delta</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">delta</span> <span class="o">/</span> <span class="mf">2.0</span><span class="p">,</span> <span class="n">la</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">step</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">)</span> <span class="o">/</span> <span class="mf">2.0</span><span class="p">)</span>
                <span class="n">status</span> <span class="o">=</span> <span class="s1">&#39;-&#39;</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># Candidate accepted</span>
                <span class="k">if</span> <span class="p">(</span>
                    <span class="n">proportionTrueHessian</span> <span class="o">&gt;</span> <span class="mi">0</span>
                    <span class="ow">and</span> <span class="nb">float</span><span class="p">(</span><span class="n">numberOfTrueHessian</span><span class="p">)</span> <span class="o">/</span> <span class="nb">float</span><span class="p">(</span><span class="n">numberOfMatrices</span><span class="p">)</span>
                    <span class="o">&lt;=</span> <span class="n">proportionTrueHessian</span>
                <span class="p">):</span>

                    <span class="k">try</span><span class="p">:</span>
                        <span class="n">fc</span><span class="p">,</span> <span class="n">gc</span><span class="p">,</span> <span class="n">Hc</span> <span class="o">=</span> <span class="n">fct</span><span class="o">.</span><span class="n">f_g_h</span><span class="p">()</span>
                        <span class="n">nfev</span> <span class="o">+=</span> <span class="mi">1</span>
                        <span class="n">ngev</span> <span class="o">+=</span> <span class="mi">1</span>
                        <span class="n">nhev</span> <span class="o">+=</span> <span class="mi">1</span>
                        <span class="n">numberOfTrueHessian</span> <span class="o">+=</span> <span class="mi">1</span>
                        <span class="n">numberOfMatrices</span> <span class="o">+=</span> <span class="mi">1</span>
                        <span class="c1"># If there is a numerical problem with the</span>
                        <span class="c1"># Hessian, we apply BFGS</span>
                        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">Hc</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mf">1.0e100</span><span class="p">:</span>
                            <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span>
                                <span class="sa">f</span><span class="s1">&#39;Numerical problem with the second &#39;</span>
                                <span class="sa">f</span><span class="s1">&#39;derivative matrix. &#39;</span>
                                <span class="sa">f</span><span class="s1">&#39;Norm = </span><span class="si">{</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">Hc</span><span class="p">)</span><span class="si">}</span><span class="s1">. &#39;</span>
                                <span class="sa">f</span><span class="s1">&#39;Replaced by the identity matrix.&#39;</span>
                            <span class="p">)</span>
                            <span class="n">y</span> <span class="o">=</span> <span class="n">gc</span> <span class="o">-</span> <span class="n">g</span>
                            <span class="n">Hc</span> <span class="o">=</span> <span class="n">bfgs</span><span class="p">(</span><span class="n">H</span><span class="p">,</span> <span class="n">step</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
                        <span class="n">fghCalculated</span> <span class="o">=</span> <span class="kc">True</span>
                    <span class="k">except</span> <span class="n">excep</span><span class="o">.</span><span class="n">biogemeError</span><span class="p">:</span>
                        <span class="c1"># Failure: reduce the trust region</span>
                        <span class="n">delta</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">delta</span> <span class="o">/</span> <span class="mf">2.0</span><span class="p">,</span> <span class="n">la</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">step</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">)</span> <span class="o">/</span> <span class="mf">2.0</span><span class="p">)</span>
                        <span class="n">status</span> <span class="o">=</span> <span class="s1">&#39;-&#39;</span>
                        <span class="n">fghCalculated</span> <span class="o">=</span> <span class="kc">False</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">try</span><span class="p">:</span>
                        <span class="n">fc</span><span class="p">,</span> <span class="n">gc</span> <span class="o">=</span> <span class="n">fct</span><span class="o">.</span><span class="n">f_g</span><span class="p">()</span>
                        <span class="n">nfev</span> <span class="o">+=</span> <span class="mi">1</span>
                        <span class="n">ngev</span> <span class="o">+=</span> <span class="mi">1</span>
                        <span class="n">y</span> <span class="o">=</span> <span class="n">gc</span> <span class="o">-</span> <span class="n">g</span>
                        <span class="n">Hc</span> <span class="o">=</span> <span class="n">bfgs</span><span class="p">(</span><span class="n">H</span><span class="p">,</span> <span class="n">step</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
                        <span class="n">numberOfMatrices</span> <span class="o">+=</span> <span class="mi">1</span>
                        <span class="n">fghCalculated</span> <span class="o">=</span> <span class="kc">True</span>
                    <span class="k">except</span> <span class="n">excep</span><span class="o">.</span><span class="n">biogemeError</span><span class="p">:</span>
                        <span class="c1"># Failure: reduce the trust region</span>
                        <span class="n">delta</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">delta</span> <span class="o">/</span> <span class="mf">2.0</span><span class="p">,</span> <span class="n">la</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">step</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">)</span> <span class="o">/</span> <span class="mf">2.0</span><span class="p">)</span>
                        <span class="n">status</span> <span class="o">=</span> <span class="s1">&#39;-&#39;</span>
                        <span class="n">fghCalculated</span> <span class="o">=</span> <span class="kc">False</span>
                <span class="k">if</span> <span class="n">fghCalculated</span><span class="p">:</span>
                    <span class="n">nfev</span> <span class="o">+=</span> <span class="mi">1</span>
                    <span class="n">xpred</span> <span class="o">=</span> <span class="n">xk</span>
                    <span class="n">xk</span> <span class="o">=</span> <span class="n">xc</span>
                    <span class="n">f</span> <span class="o">=</span> <span class="n">fc</span>
                    <span class="n">g</span> <span class="o">=</span> <span class="n">gc</span>
                    <span class="n">H</span> <span class="o">=</span> <span class="n">Hc</span>
                    <span class="k">if</span> <span class="n">rho</span> <span class="o">&gt;=</span> <span class="n">eta2</span><span class="p">:</span>
                        <span class="c1"># Enlarge the trust region</span>
                        <span class="n">delta</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">enlargingFactor</span> <span class="o">*</span> <span class="n">delta</span><span class="p">,</span> <span class="n">maxDelta</span><span class="p">)</span>
                        <span class="n">status</span> <span class="o">=</span> <span class="s1">&#39;++&#39;</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">status</span> <span class="o">=</span> <span class="s1">&#39;+&#39;</span>

                    <span class="n">projectedGradient</span> <span class="o">=</span> <span class="n">bounds</span><span class="o">.</span><span class="n">project</span><span class="p">(</span><span class="n">xk</span> <span class="o">-</span> <span class="n">g</span><span class="p">)</span> <span class="o">-</span> <span class="n">xk</span>
                    <span class="n">relgrad</span> <span class="o">=</span> <span class="n">relativeGradient</span><span class="p">(</span>
                        <span class="n">xk</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">projectedGradient</span><span class="p">,</span> <span class="n">typx</span><span class="p">,</span> <span class="n">typf</span>
                    <span class="p">)</span>
                    <span class="k">if</span> <span class="n">relgrad</span> <span class="o">&lt;=</span> <span class="n">tol</span><span class="p">:</span>
                        <span class="n">message</span> <span class="o">=</span> <span class="p">(</span>
                            <span class="sa">f</span><span class="s1">&#39;Relative gradient = </span><span class="si">{</span><span class="n">relgrad</span><span class="si">:</span><span class="s1">.2g</span><span class="si">}</span><span class="s1"> &lt;= </span><span class="si">{</span><span class="n">tol</span><span class="si">:</span><span class="s1">.2g</span><span class="si">}</span><span class="s1">&#39;</span>
                        <span class="p">)</span>
                        <span class="n">cont</span> <span class="o">=</span> <span class="kc">False</span>
                    <span class="n">relchange</span> <span class="o">=</span> <span class="n">relativeChange</span><span class="p">(</span><span class="n">xk</span><span class="p">,</span> <span class="n">xpred</span><span class="p">,</span> <span class="n">typx</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">relchange</span> <span class="o">&lt;=</span> <span class="n">steptol</span><span class="p">:</span>
                        <span class="n">message</span> <span class="o">=</span> <span class="p">(</span>
                            <span class="sa">f</span><span class="s1">&#39;Relative change = &#39;</span>
                            <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">relchange</span><span class="si">:</span><span class="s1">.3g</span><span class="si">}</span><span class="s1"> &lt;= </span><span class="si">{</span><span class="n">steptol</span><span class="si">:</span><span class="s1">.2g</span><span class="si">}</span><span class="s1">&#39;</span>
                        <span class="p">)</span>
                        <span class="n">cont</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="k">if</span> <span class="n">delta</span> <span class="o">&lt;=</span> <span class="n">minDelta</span><span class="p">:</span>
                <span class="n">message</span> <span class="o">=</span> <span class="sa">f</span><span class="s1">&#39;Trust region is too small: </span><span class="si">{</span><span class="n">delta</span><span class="si">}</span><span class="s1">&#39;</span>
                <span class="n">cont</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="k">if</span> <span class="n">k</span> <span class="o">==</span> <span class="n">maxiter</span><span class="p">:</span>
                <span class="n">message</span> <span class="o">=</span> <span class="sa">f</span><span class="s1">&#39;Maximum number of iterations reached: </span><span class="si">{</span><span class="n">maxiter</span><span class="si">}</span><span class="s1">&#39;</span>
                <span class="n">cont</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="k">if</span> <span class="n">relchange</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">detailed</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">k</span><span class="si">}</span><span class="s1"> f=</span><span class="si">{</span><span class="n">f</span><span class="si">:</span><span class="s1">10.7g</span><span class="si">}</span><span class="s1"> projected &#39;</span>
                    <span class="sa">f</span><span class="s1">&#39;rel. grad.=</span><span class="si">{</span><span class="n">relgrad</span><span class="si">:</span><span class="s1">6.2g</span><span class="si">}</span><span class="s1"> &#39;</span>
                    <span class="sa">f</span><span class="s1">&#39;delta=</span><span class="si">{</span><span class="n">delta</span><span class="si">:</span><span class="s1">6.2g</span><span class="si">}</span><span class="s1"> rho=</span><span class="si">{</span><span class="n">rho</span><span class="si">:</span><span class="s1">6.2g</span><span class="si">}</span><span class="s1"> </span><span class="si">{</span><span class="n">status</span><span class="si">}</span><span class="s1">&#39;</span>
                <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">detailed</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">k</span><span class="si">}</span><span class="s1"> f=</span><span class="si">{</span><span class="n">f</span><span class="si">:</span><span class="s1">10.7g</span><span class="si">}</span><span class="s1"> projected &#39;</span>
                    <span class="sa">f</span><span class="s1">&#39;rel. grad.=</span><span class="si">{</span><span class="n">relgrad</span><span class="si">:</span><span class="s1">6.2g</span><span class="si">}</span><span class="s1"> &#39;</span>
                    <span class="sa">f</span><span class="s1">&#39;rel. change=</span><span class="si">{</span><span class="n">relchange</span><span class="si">:</span><span class="s1">6.2g</span><span class="si">}</span><span class="s1"> &#39;</span>
                    <span class="sa">f</span><span class="s1">&#39;delta=</span><span class="si">{</span><span class="n">delta</span><span class="si">:</span><span class="s1">6.2g</span><span class="si">}</span><span class="s1"> rho=</span><span class="si">{</span><span class="n">rho</span><span class="si">:</span><span class="s1">6.2g</span><span class="si">}</span><span class="s1"> </span><span class="si">{</span><span class="n">status</span><span class="si">}</span><span class="s1">&#39;</span>
                <span class="p">)</span>
    <span class="k">if</span> <span class="n">numberOfMatrices</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">actualProp</span> <span class="o">=</span> <span class="mi">100</span> <span class="o">*</span> <span class="nb">float</span><span class="p">(</span><span class="n">numberOfTrueHessian</span><span class="p">)</span> <span class="o">/</span> <span class="nb">float</span><span class="p">(</span><span class="n">numberOfMatrices</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">actualProp</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">m</span> <span class="o">=</span> <span class="sa">f</span><span class="s1">&#39;Proportion of Hessian calculation: &#39;</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">actualProp</span><span class="si">}</span><span class="s1">%&#39;</span>
    <span class="n">logger</span><span class="o">.</span><span class="n">detailed</span><span class="p">(</span><span class="n">m</span><span class="p">)</span>

    <span class="n">messages</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s1">&#39;Algorithm&#39;</span><span class="p">:</span> <span class="n">algo</span><span class="p">,</span>
        <span class="s1">&#39;Proportion analytical hessian&#39;</span><span class="p">:</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">actualProp</span><span class="si">:</span><span class="s1">.1f</span><span class="si">}</span><span class="s1">%&#39;</span><span class="p">,</span>
        <span class="s1">&#39;Relative projected gradient&#39;</span><span class="p">:</span> <span class="n">relgrad</span><span class="p">,</span>
        <span class="s1">&#39;Relative change&#39;</span><span class="p">:</span> <span class="n">relchange</span><span class="p">,</span>
        <span class="s1">&#39;Number of iterations&#39;</span><span class="p">:</span> <span class="n">k</span><span class="p">,</span>
        <span class="s1">&#39;Number of function evaluations&#39;</span><span class="p">:</span> <span class="n">nfev</span><span class="p">,</span>
        <span class="s1">&#39;Number of gradient evaluations&#39;</span><span class="p">:</span> <span class="n">ngev</span><span class="p">,</span>
        <span class="s1">&#39;Number of hessian evaluations&#39;</span><span class="p">:</span> <span class="n">nhev</span><span class="p">,</span>
        <span class="s1">&#39;Cause of termination&#39;</span><span class="p">:</span> <span class="n">message</span><span class="p">,</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="n">xk</span><span class="p">,</span> <span class="n">messages</span></div>


<div class="viewcode-block" id="relativeChange"><a class="viewcode-back" href="../../algorithms.html#biogeme.algorithms.relativeChange">[docs]</a><span class="k">def</span> <span class="nf">relativeChange</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">xpred</span><span class="p">,</span> <span class="n">typx</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Calculates the relative change.</span>

<span class="sd">    It is typically used as stopping criterion.</span>

<span class="sd">    :param x: current iterate.</span>
<span class="sd">    :type x: numpy.array</span>

<span class="sd">    :param xpred: previous iterate.</span>
<span class="sd">    :type xpred: numpy.array</span>

<span class="sd">    :param typx: typical value for x.</span>
<span class="sd">    :type typx: numpy.array</span>

<span class="sd">    :return: relative change:</span>

<span class="sd">    .. math:: \\max_i \\frac{|(x_k)_i - (x_{k-1})_i|}{\\max(|(x_k)_i|,</span>
<span class="sd">              \\text{typx}_i)}</span>

<span class="sd">    :rtype: float</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">relx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
        <span class="p">[</span><span class="nb">abs</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">xpred</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">/</span> <span class="nb">max</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">]),</span> <span class="n">typx</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">))]</span>
    <span class="p">)</span>
    <span class="n">result</span> <span class="o">=</span> <span class="n">relx</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">result</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">result</span>

    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">finfo</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span><span class="o">.</span><span class="n">max</span></div>
</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2022, Michel Bierlaire.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>