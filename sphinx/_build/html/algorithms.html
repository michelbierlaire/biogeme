<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Algorithms &mdash; Biogeme 3.2.9 documentation</title>
      <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js"></script>
        <script src="_static/jquery.js"></script>
        <script src="_static/underscore.js"></script>
        <script src="_static/_sphinx_javascript_frameworks_compat.js"></script>
        <script src="_static/doctools.js"></script>
        <script async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script src="_static/js/theme.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Assisted specification" href="assisted.html" />
    <link rel="prev" title="Welcome to Biogeme’s documentation!" href="index.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="index.html" class="icon icon-home"> Biogeme
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul class="current">
<li class="toctree-l1 current"><a class="current reference internal" href="#">Algorithms</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#module-biogeme.algorithms">biogeme.algorithms module</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="assisted.html">Assisted specification</a></li>
<li class="toctree-l1"><a class="reference internal" href="biogeme.html">Biogeme</a></li>
<li class="toctree-l1"><a class="reference internal" href="database.html">Database</a></li>
<li class="toctree-l1"><a class="reference internal" href="distributions.html">Distributions</a></li>
<li class="toctree-l1"><a class="reference internal" href="draws.html">Draws</a></li>
<li class="toctree-l1"><a class="reference internal" href="exceptions.html">Exceptions</a></li>
<li class="toctree-l1"><a class="reference internal" href="expressions.html">Expressions</a></li>
<li class="toctree-l1"><a class="reference internal" href="filenames.html">Filenames</a></li>
<li class="toctree-l1"><a class="reference internal" href="idmanager.html">ID manager</a></li>
<li class="toctree-l1"><a class="reference internal" href="loglikelihood.html">Log likelihood</a></li>
<li class="toctree-l1"><a class="reference internal" href="messaging.html">Messaging</a></li>
<li class="toctree-l1"><a class="reference internal" href="models.html">Models</a></li>
<li class="toctree-l1"><a class="reference internal" href="optimization.html">Optimization</a></li>
<li class="toctree-l1"><a class="reference internal" href="results.html">Results</a></li>
<li class="toctree-l1"><a class="reference internal" href="segmentation.html">Segmentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="singleton.html">Singleton</a></li>
<li class="toctree-l1"><a class="reference internal" href="tools.html">Tools</a></li>
<li class="toctree-l1"><a class="reference internal" href="version.html">Version</a></li>
<li class="toctree-l1"><a class="reference internal" href="vns.html">Variable Neighborhood Search</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">Biogeme</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="index.html" class="icon icon-home"></a> &raquo;</li>
      <li>Algorithms</li>
      <li class="wy-breadcrumbs-aside">
            <a href="_sources/algorithms.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="algorithms">
<h1>Algorithms<a class="headerlink" href="#algorithms" title="Permalink to this heading"></a></h1>
<p>Generic optimization algorithms.</p>
<section id="module-biogeme.algorithms">
<span id="biogeme-algorithms-module"></span><h2>biogeme.algorithms module<a class="headerlink" href="#module-biogeme.algorithms" title="Permalink to this heading"></a></h2>
<p>Optimization algorithms.</p>
<dl class="field-list simple">
<dt class="field-odd">author</dt>
<dd class="field-odd"><p>Michel Bierlaire</p>
</dd>
<dt class="field-even">date</dt>
<dd class="field-even"><p>Sun Apr  5 16:48:54 2020</p>
</dd>
</dl>
<dl class="py function">
<dt class="sig sig-object py" id="biogeme.algorithms.bfgs">
<span class="sig-prename descclassname"><span class="pre">biogeme.algorithms.</span></span><span class="sig-name descname"><span class="pre">bfgs</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">H</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">d</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/biogeme/algorithms.html#bfgs"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#biogeme.algorithms.bfgs" title="Permalink to this definition"></a></dt>
<dd><p>Update the BFGS matrix. Formula (13.12) of <a class="reference external" href="http://optimizationprinciplesalgorithms.com/">Bierlaire (2015)</a>
where the method proposed by <a class="reference external" href="https://link.springer.com/content/pdf/10.1007/BFb0067703.pdf">Powell (1977)</a> is applied</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>H</strong> (<em>numpy.array</em><em> (</em><em>2D</em><em>)</em>) – current approximation of the inverse of the Hessian</p></li>
<li><p><strong>d</strong> (<em>numpy.array</em><em> (</em><em>1D</em><em>)</em>) – difference between two consecutive iterates.</p></li>
<li><p><strong>y</strong> (<em>numpy.array</em><em> (</em><em>1D</em><em>)</em>) – difference between two consecutive gradients.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>updated approximation of the inverse of the Hessian.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>numpy.array (2D)</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="biogeme.algorithms.bfgsLineSearch">
<span class="sig-prename descclassname"><span class="pre">biogeme.algorithms.</span></span><span class="sig-name descname"><span class="pre">bfgsLineSearch</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">fct</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">x0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">initBfgs</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">eps</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">6.06273418136464e-06</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">maxiter</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1000</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/biogeme/algorithms.html#bfgsLineSearch"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#biogeme.algorithms.bfgsLineSearch" title="Permalink to this definition"></a></dt>
<dd><p>BFGS method with inexact line search (Wolfe conditions)</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>fct</strong> (<em>optimization.functionToMinimize</em>) – object to calculate the objective function and its derivatives.</p></li>
<li><p><strong>x0</strong> (<em>numpy.array</em>) – starting point</p></li>
<li><p><strong>initBfgs</strong> (<em>numpy.array</em>) – matrix used to initialize BFGS. If None, the
identity matrix is used. Default: None.</p></li>
<li><p><strong>eps</strong> (<em>float</em>) – the algorithm stops when this precision is reached.
Default: <span class="math notranslate nohighlight">\(\varepsilon^{\frac{1}{3}}\)</span></p></li>
<li><p><strong>maxiter</strong> (<em>int</em>) – the algorithm stops if this number of iterations
is reached. Default: 1000</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><p>tuple x, messages, where</p>
<ul class="simple">
<li><p>x is the solution found,</p></li>
<li><p>messages is a dictionary reporting various aspects
related to the run of the algorithm.</p></li>
</ul>
</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>numpy.array, dict(str:object)</p>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><p><a class="reference internal" href="exceptions.html#biogeme.exceptions.biogemeError" title="biogeme.exceptions.biogemeError"><strong>biogeme.exceptions.biogemeError</strong></a> – if the dimensions of the
matrix initBfgs do not match the length of x0.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="biogeme.algorithms.bfgsTrustRegion">
<span class="sig-prename descclassname"><span class="pre">biogeme.algorithms.</span></span><span class="sig-name descname"><span class="pre">bfgsTrustRegion</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">fct</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">x0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">initBfgs</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">delta0</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">eps</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">6.06273418136464e-06</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dl</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">maxiter</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1000</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">eta1</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.01</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">eta2</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.9</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/biogeme/algorithms.html#bfgsTrustRegion"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#biogeme.algorithms.bfgsTrustRegion" title="Permalink to this definition"></a></dt>
<dd><p>BFGS method with trust region</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>fct</strong> (<em>optimization.functionToMinimize</em>) – object to calculate the objective function and its derivatives.</p></li>
<li><p><strong>x0</strong> (<em>numpy.array</em>) – starting point</p></li>
<li><p><strong>initBfgs</strong> (<em>numpy.array</em>) – matrix used to initialize BFGS. If None, the
identity matrix is used. Default: None.</p></li>
<li><p><strong>delta0</strong> (<em>float</em>) – initial radius of the trust region. Default: 100.</p></li>
<li><p><strong>eps</strong> (<em>float</em>) – the algorithm stops when this precision is reached.
Default: <span class="math notranslate nohighlight">\(\varepsilon^{\frac{1}{3}}\)</span></p></li>
<li><p><strong>dl</strong> (<em>bool</em>) – If True, the Dogleg method is used to solve the
trut region subproblem. If False, the truncated conjugate
gradient is used. Default: False.</p></li>
<li><p><strong>maxiter</strong> (<em>int</em>) – the algorithm stops if this number of iterations
is reached. Default: 1000.</p></li>
<li><p><strong>eta1</strong> (<em>float</em>) – threshold for failed iterations. Default: 0.01.</p></li>
<li><p><strong>eta2</strong> (<em>float</em>) – threshold for very successful iterations. Default 0.9.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><p>tuple x, messages, where</p>
<ul class="simple">
<li><p>x is the solution found,</p></li>
<li><p>messages is a dictionary reporting various aspects
related to the run of the algorithm.</p></li>
</ul>
</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>numpy.array, dict(str:object)</p>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><p><a class="reference internal" href="exceptions.html#biogeme.exceptions.biogemeError" title="biogeme.exceptions.biogemeError"><strong>biogeme.exceptions.biogemeError</strong></a> – if the dimensions of the
matrix initBfgs do not match the length of x0.</p>
</dd>
</dl>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="biogeme.algorithms.bioBounds">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">biogeme.algorithms.</span></span><span class="sig-name descname"><span class="pre">bioBounds</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">b</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/biogeme/algorithms.html#bioBounds"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#biogeme.algorithms.bioBounds" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>This class is designed for the management of simple bound constraints</p>
<dl class="py method">
<dt class="sig sig-object py" id="biogeme.algorithms.bioBounds.__init__">
<span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">b</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/biogeme/algorithms.html#bioBounds.__init__"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#biogeme.algorithms.bioBounds.__init__" title="Permalink to this definition"></a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>b</strong> (<em>list</em><em>(</em><em>tuple</em><em>)</em>) – list of tuples (ell,u) containing the lower and
upper bounds for each free parameter.</p>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><p><a class="reference internal" href="exceptions.html#biogeme.exceptions.biogemeError" title="biogeme.exceptions.biogemeError"><strong>biogeme.exceptions.biogemeError</strong></a> – if the bounds are incompatible</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="biogeme.algorithms.bioBounds.activity">
<span class="sig-name descname"><span class="pre">activity</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">epsilon</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">2.220446049250313e-16</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/biogeme/algorithms.html#bioBounds.activity"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#biogeme.algorithms.bioBounds.activity" title="Permalink to this definition"></a></dt>
<dd><p>Determines the activity status of each variable.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x</strong> (<em>numpy.array</em>) – point for which the activity must be determined.</p></li>
<li><p><strong>epsilon</strong> (<em>float</em>) – a bound is considered active if the distance
to it is less rhan epsilon.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><p>a vector, same length as x, where each entry reports
the activity of the corresponding variable:</p>
<ul class="simple">
<li><p>0 if no bound is active</p></li>
<li><p>-1 if the lower bound is active</p></li>
<li><p>1 if the upper bound is active</p></li>
</ul>
</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>numpy.array</p>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><ul class="simple">
<li><p><a class="reference internal" href="exceptions.html#biogeme.exceptions.biogemeError" title="biogeme.exceptions.biogemeError"><strong>biogeme.exceptions.biogemeError</strong></a> – if the vector x is
not feasible</p></li>
<li><p><a class="reference internal" href="exceptions.html#biogeme.exceptions.biogemeError" title="biogeme.exceptions.biogemeError"><strong>biogeme.exceptions.biogemeError</strong></a> – if the dimensions
of x and bounds do not match.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="biogeme.algorithms.bioBounds.bounds">
<span class="sig-name descname"><span class="pre">bounds</span></span><a class="headerlink" href="#biogeme.algorithms.bioBounds.bounds" title="Permalink to this definition"></a></dt>
<dd><p>list of tuples (ell,u) containing the lower and upper bounds for
each free parameter.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="biogeme.algorithms.bioBounds.breakpoints">
<span class="sig-name descname"><span class="pre">breakpoints</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">d</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/biogeme/algorithms.html#bioBounds.breakpoints"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#biogeme.algorithms.bioBounds.breakpoints" title="Permalink to this definition"></a></dt>
<dd><p>Projects the direction d, starting from x,
on the intersection of the bound constraints</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x</strong> (<em>numpy.array</em>) – current point</p></li>
<li><p><strong>d</strong> (<em>numpy.array</em>) – search direction</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>list of tuple (index, value), where index is the index
of the variable, and value the value of the corresponding
breakpoint.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>list(tuple(int,float))</p>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><ul class="simple">
<li><p><a class="reference internal" href="exceptions.html#biogeme.exceptions.biogemeError" title="biogeme.exceptions.biogemeError"><strong>biogeme.exceptions.biogemeError</strong></a> – if the dimensions
are inconsistent</p></li>
<li><p><a class="reference internal" href="exceptions.html#biogeme.exceptions.biogemeError" title="biogeme.exceptions.biogemeError"><strong>biogeme.exceptions.biogemeError</strong></a> – if x is infeasible</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="biogeme.algorithms.bioBounds.feasible">
<span class="sig-name descname"><span class="pre">feasible</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/biogeme/algorithms.html#bioBounds.feasible"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#biogeme.algorithms.bioBounds.feasible" title="Permalink to this definition"></a></dt>
<dd><p>Check if point verifies the bound constraints</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>x</strong> (<em>numpy.array</em>) – point to project</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>True if x is feasible, False otherwise.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>bool</p>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><p><a class="reference internal" href="exceptions.html#biogeme.exceptions.biogemeError" title="biogeme.exceptions.biogemeError"><strong>biogeme.exceptions.biogemeError</strong></a> – if the dimensions
are inconsistent</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="biogeme.algorithms.bioBounds.generalizedCauchyPoint">
<span class="sig-name descname"><span class="pre">generalizedCauchyPoint</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">xk</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">gk</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">H</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">direction</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/biogeme/algorithms.html#bioBounds.generalizedCauchyPoint"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#biogeme.algorithms.bioBounds.generalizedCauchyPoint" title="Permalink to this definition"></a></dt>
<dd><p>Implementation of Step 2 of the Specific Algorithm by
<a class="reference external" href="https://www.ams.org/journals/mcom/1988-50-182/S0025-5718-1988-0929544-3/S0025-5718-1988-0929544-3.pdf">Conn et al. (1988)</a>.</p>
<p>The quadratic model is defined as</p>
<div class="math notranslate nohighlight">
\[m(x) = f(x_k) + (x - x_k)^T g_k +
\frac{1}{2} (x-x_k)^T H (x-x_k).\]</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>xk</strong> (<em>numpy.array. Dimension n.</em>) – current point</p></li>
<li><p><strong>gk</strong> (<em>numpy.array. Dimension n.</em>) – vector g involved in the quadratic model definition.</p></li>
<li><p><strong>H</strong> (<em>numpy.array. Dimension n x n.</em>) – matrix H involved in the quadratic model definition.</p></li>
<li><p><strong>direction</strong> (<em>numpy.array. Dimension n.</em>) – direction along which the GCP is searched.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>generalized Cauchy point based on inexact line search.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>numpy.array. Dimension n.</p>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><ul class="simple">
<li><p><a class="reference internal" href="exceptions.html#biogeme.exceptions.biogemeError" title="biogeme.exceptions.biogemeError"><strong>biogeme.exceptions.biogemeError</strong></a> – if the dimensions are
inconsistent</p></li>
<li><p><a class="reference internal" href="exceptions.html#biogeme.exceptions.biogemeError" title="biogeme.exceptions.biogemeError"><strong>biogeme.exceptions.biogemeError</strong></a> – if xk is infeasible</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="biogeme.algorithms.bioBounds.intersect">
<span class="sig-name descname"><span class="pre">intersect</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">otherBounds</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/biogeme/algorithms.html#bioBounds.intersect"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#biogeme.algorithms.bioBounds.intersect" title="Permalink to this definition"></a></dt>
<dd><p>Create a bounds object representing the intersection of two regions.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>otherBounds</strong> (<em>class bioBounds</em>) – other bound object that must be intersected.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>bound object, intersection of the two.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>class bioBounds</p>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><p><a class="reference internal" href="exceptions.html#biogeme.exceptions.biogemeError" title="biogeme.exceptions.biogemeError"><strong>biogeme.exceptions.biogemeError</strong></a> – if the dimensions
are inconsistent</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="biogeme.algorithms.bioBounds.intersectionWithTrustRegion">
<span class="sig-name descname"><span class="pre">intersectionWithTrustRegion</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">delta</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/biogeme/algorithms.html#bioBounds.intersectionWithTrustRegion"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#biogeme.algorithms.bioBounds.intersectionWithTrustRegion" title="Permalink to this definition"></a></dt>
<dd><p>Create a bioBounds object representing the intersection
between the feasible domain and the trust region.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x</strong> (<em>numpy.array</em>) – center of the trust region</p></li>
<li><p><strong>delta</strong> (<em>float</em>) – radius of the tust region (infinity norm)</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>intersection between the feasible region and the trus region</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>class bioBounds</p>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><p><a class="reference internal" href="exceptions.html#biogeme.exceptions.biogemeError" title="biogeme.exceptions.biogemeError"><strong>biogeme.exceptions.biogemeError</strong></a> – if the dimensions
are inconsistent</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="biogeme.algorithms.bioBounds.lowerBounds">
<span class="sig-name descname"><span class="pre">lowerBounds</span></span><a class="headerlink" href="#biogeme.algorithms.bioBounds.lowerBounds" title="Permalink to this definition"></a></dt>
<dd><p>List of lower bounds</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="biogeme.algorithms.bioBounds.maximumStep">
<span class="sig-name descname"><span class="pre">maximumStep</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">d</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/biogeme/algorithms.html#bioBounds.maximumStep"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#biogeme.algorithms.bioBounds.maximumStep" title="Permalink to this definition"></a></dt>
<dd><p>Calculates the maximum step that can be performed
along a direction while staying feasible.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x</strong> (<em>numpy.array</em>) – reference point</p></li>
<li><p><strong>d</strong> (<em>numpy.array</em>) – direction</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>the largest alpha such that x + alpha * d is feasible
and the list of indices achieving this value.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>float, int</p>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><p><a class="reference internal" href="exceptions.html#biogeme.exceptions.biogemeError" title="biogeme.exceptions.biogemeError"><strong>biogeme.exceptions.biogemeError</strong></a> – if the point is infeasible</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="biogeme.algorithms.bioBounds.n">
<span class="sig-name descname"><span class="pre">n</span></span><a class="headerlink" href="#biogeme.algorithms.bioBounds.n" title="Permalink to this definition"></a></dt>
<dd><p>number of optimization variables</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="biogeme.algorithms.bioBounds.project">
<span class="sig-name descname"><span class="pre">project</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/biogeme/algorithms.html#bioBounds.project"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#biogeme.algorithms.bioBounds.project" title="Permalink to this definition"></a></dt>
<dd><p>Project a point onto the feasible domain defined by the bounds.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>x</strong> (<em>numpy.array</em>) – point to project</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>projected point</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>numpy.array</p>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><p><a class="reference internal" href="exceptions.html#biogeme.exceptions.biogemeError" title="biogeme.exceptions.biogemeError"><strong>biogeme.exceptions.biogemeError</strong></a> – if the dimensions
are inconsistent</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="biogeme.algorithms.bioBounds.subspace">
<span class="sig-name descname"><span class="pre">subspace</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">selectedVariables</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/biogeme/algorithms.html#bioBounds.subspace"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#biogeme.algorithms.bioBounds.subspace" title="Permalink to this definition"></a></dt>
<dd><p>Generate a bioBounds object for selected variables</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>selectedVariables</strong> (<em>numpy.array</em><em>(</em><em>bool</em><em>)</em>) – boolean vector. If an entry is True,
the corresponding variables is considered.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>bound object</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>class bioBounds</p>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><p><a class="reference internal" href="exceptions.html#biogeme.exceptions.biogemeError" title="biogeme.exceptions.biogemeError"><strong>biogeme.exceptions.biogemeError</strong></a> – if the dimensions
are inconsistent</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="biogeme.algorithms.bioBounds.upperBounds">
<span class="sig-name descname"><span class="pre">upperBounds</span></span><a class="headerlink" href="#biogeme.algorithms.bioBounds.upperBounds" title="Permalink to this definition"></a></dt>
<dd><p>List of upper bounds</p>
</dd></dl>

</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="biogeme.algorithms.cauchyNewtonDogleg">
<span class="sig-prename descclassname"><span class="pre">biogeme.algorithms.</span></span><span class="sig-name descname"><span class="pre">cauchyNewtonDogleg</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">g</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">H</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/biogeme/algorithms.html#cauchyNewtonDogleg"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#biogeme.algorithms.cauchyNewtonDogleg" title="Permalink to this definition"></a></dt>
<dd><p>Calculate the Cauchy, the Newton and the dogleg points.</p>
<p>The Cauchy point is defined as</p>
<div class="math notranslate nohighlight">
\[d_c = - \frac{\nabla f(x)^T \nabla f(x)}
{\nabla f(x)^T \nabla^2 f(x)
\nabla f(x)} \nabla f(x)\]</div>
<p>The Newton point <span class="math notranslate nohighlight">\(d_n\)</span> verifies Newton equation:</p>
<div class="math notranslate nohighlight">
\[H_s d_n = - \nabla f(x)\]</div>
<p>where <span class="math notranslate nohighlight">\(H_s\)</span> is a positive definite matrix generated with the
method by <a class="reference external" href="https://doi.org/10.1137/s105262349833266x">Schnabel and Eskow (1999)</a>.</p>
<p>The Dogleg point is</p>
<div class="math notranslate nohighlight">
\[d_d = \eta d_n\]</div>
<p>where</p>
<div class="math notranslate nohighlight">
\[\eta = 0.2 + 0.8 \frac{\alpha^2}{\beta |\nabla f(x)^T d_n|}\]</div>
<p>and <span class="math notranslate nohighlight">\(\alpha= \nabla f(x)^T \nabla f(x)\)</span>,
<span class="math notranslate nohighlight">\(\beta=\nabla f(x)^T \nabla^2 f(x)\nabla f(x).\)</span></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>g</strong> (<em>numpy.array</em>) – gradient <span class="math notranslate nohighlight">\(\nabla f(x)\)</span></p></li>
<li><p><strong>H</strong> (<em>numpy.array</em>) – hessian <span class="math notranslate nohighlight">\(\nabla^2 f(x)\)</span></p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>tuple with Cauchy point, Newton point, Dogleg point</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>numpy.array, numpy.array, numpy.array</p>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><p><a class="reference internal" href="exceptions.html#biogeme.exceptions.biogemeError" title="biogeme.exceptions.biogemeError"><strong>biogeme.exceptions.biogemeError</strong></a> – if the quadratic model is
not convex.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="biogeme.algorithms.dogleg">
<span class="sig-prename descclassname"><span class="pre">biogeme.algorithms.</span></span><span class="sig-name descname"><span class="pre">dogleg</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">g</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">H</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">delta</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/biogeme/algorithms.html#dogleg"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#biogeme.algorithms.dogleg" title="Permalink to this definition"></a></dt>
<dd><p>Find an approximation of the trust region subproblem using
the dogleg method</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>g</strong> (<em>numpy.array</em>) – gradient of the quadratic model.</p></li>
<li><p><strong>H</strong> (<em>numpy.array</em>) – hessian of the quadratic model.</p></li>
<li><p><strong>delta</strong> (<em>float</em>) – radius of the trust region.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><p>d, diagnostic where</p>
<ul>
<li><p>d is an approximate solution of the trust region subproblem</p></li>
<li><p>diagnostic is the nature of the solution:</p>
<blockquote>
<div><ul class="simple">
<li><p>-2 if negative curvature along Newton direction</p></li>
<li><p>-1 if negative curvature along Cauchy direction
(i.e. along the gradient)</p></li>
<li><p>1 if partial Cauchy step</p></li>
<li><p>2 if Newton step</p></li>
<li><p>3 if partial Newton step</p></li>
<li><p>4 if Dogleg</p></li>
</ul>
</div></blockquote>
</li>
</ul>
</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>numpy.array, int</p>
</dd>
</dl>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="biogeme.algorithms.functionToMinimize">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">biogeme.algorithms.</span></span><span class="sig-name descname"><span class="pre">functionToMinimize</span></span><a class="reference internal" href="_modules/biogeme/algorithms.html#functionToMinimize"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#biogeme.algorithms.functionToMinimize" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>This is an abstract class. The actual function to minimize
must be implemented in a concrete class deriving from this one.</p>
<dl class="py method">
<dt class="sig sig-object py" id="biogeme.algorithms.functionToMinimize.f">
<em class="property"><span class="pre">abstract</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">f</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">batch</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/biogeme/algorithms.html#functionToMinimize.f"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#biogeme.algorithms.functionToMinimize.f" title="Permalink to this definition"></a></dt>
<dd><p>Calculate the value of the function</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>batch</strong> (<em>float</em>) – for data driven functions (such as a log
likelikood function), it is possible to
approximate the value of the function using a
sample of the data called a batch. This argument
is a value between 0 and 1 representing the
percentage of the data that should be used for
thre random batch. If None, the full data set is
used. Default: None pass</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>value of the function</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>float</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="biogeme.algorithms.functionToMinimize.f_g">
<em class="property"><span class="pre">abstract</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">f_g</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">batch</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/biogeme/algorithms.html#functionToMinimize.f_g"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#biogeme.algorithms.functionToMinimize.f_g" title="Permalink to this definition"></a></dt>
<dd><p>Calculate the value of the function and the gradient</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>batch</strong> (<em>float</em>) – for data driven functions (such as a log
likelikood function), it is possible to
approximate the value of the function using a
sample of the data called a batch. This argument
is a value between 0 and 1 representing the
percentage of the data that should be used for
the random batch. If None, the full data set is
used. Default: None pass</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>value of the function and the gradient</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>tuple float, numpy.array</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="biogeme.algorithms.functionToMinimize.f_g_bhhh">
<em class="property"><span class="pre">abstract</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">f_g_bhhh</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">batch</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/biogeme/algorithms.html#functionToMinimize.f_g_bhhh"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#biogeme.algorithms.functionToMinimize.f_g_bhhh" title="Permalink to this definition"></a></dt>
<dd><p>Calculate the value of the function, the gradient and
the BHHH matrix</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>batch</strong> (<em>float</em>) – for data driven functions (such as a log
likelikood function), it is possible to
approximate the value of the function using a
sample of the data called a batch. This argument
is a value between 0 and 1 representing the
percentage of the data that should be used for
the random batch. If None, the full data set is
used. Default: None pass</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>value of the function, the gradient and the BHHH</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>tuple float, numpy.array, numpy.array</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="biogeme.algorithms.functionToMinimize.f_g_h">
<em class="property"><span class="pre">abstract</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">f_g_h</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">batch</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/biogeme/algorithms.html#functionToMinimize.f_g_h"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#biogeme.algorithms.functionToMinimize.f_g_h" title="Permalink to this definition"></a></dt>
<dd><p>Calculate the value of the function, the gradient and the Hessian</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>batch</strong> (<em>float</em>) – for data driven functions (such as a log
likelikood function), it is possible to
approximate the value of the function using a
sample of the data called a batch. This argument
is a value between 0 and 1 representing the
percentage of the data that should be used for
the random batch. If None, the full data set is
used. Default: None pass</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>value of the function, the gradient and the Hessian</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>tuple float, numpy.array, numpy.array</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="biogeme.algorithms.functionToMinimize.setVariables">
<em class="property"><span class="pre">abstract</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">setVariables</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/biogeme/algorithms.html#functionToMinimize.setVariables"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#biogeme.algorithms.functionToMinimize.setVariables" title="Permalink to this definition"></a></dt>
<dd><p>Set the values of the variables for which the function
has to be calculated.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>x</strong> (<em>numpy.array</em>) – values</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="biogeme.algorithms.inverseBfgs">
<span class="sig-prename descclassname"><span class="pre">biogeme.algorithms.</span></span><span class="sig-name descname"><span class="pre">inverseBfgs</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">Hinv</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">d</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/biogeme/algorithms.html#inverseBfgs"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#biogeme.algorithms.inverseBfgs" title="Permalink to this definition"></a></dt>
<dd><p>Update the inverse BFGS matrix. Formula (13.13) of <a class="reference external" href="http://optimizationprinciplesalgorithms.com/">Bierlaire (2015)</a></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>Hinv</strong> (<em>numpy.array</em><em> (</em><em>2D</em><em>)</em>) – current approximation of the inverse of the Hessian</p></li>
<li><p><strong>d</strong> (<em>numpy.array</em><em> (</em><em>1D</em><em>)</em>) – difference between two consecutive iterates.</p></li>
<li><p><strong>y</strong> (<em>numpy.array</em><em> (</em><em>1D</em><em>)</em>) – difference between two consecutive gradients.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>updated approximation of the inverse of the Hessian.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>numpy.array (2D)</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="biogeme.algorithms.lineSearch">
<span class="sig-prename descclassname"><span class="pre">biogeme.algorithms.</span></span><span class="sig-name descname"><span class="pre">lineSearch</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">fct</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">f</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">g</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">d</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">alpha0</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">beta1</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.0001</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">beta2</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.99</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lbd</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">2.0</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/biogeme/algorithms.html#lineSearch"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#biogeme.algorithms.lineSearch" title="Permalink to this definition"></a></dt>
<dd><p>Calculate a step along a direction that satisfies both Wolfe conditions</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>fct</strong> (<em>optimization.functionToMinimize</em>) – object to calculate the objective function and its derivatives.</p></li>
<li><p><strong>x</strong> (<em>numpy.array</em>) – current iterate.</p></li>
<li><p><strong>f</strong> (<em>float</em>) – value of the objective function at the current iterate.</p></li>
<li><p><strong>g</strong> (<em>numpy.array</em>) – value of the gradient at the current iterate.</p></li>
<li><p><strong>d</strong> (<em>numpy.array</em>) – descent direction.</p></li>
<li><p><strong>alpha0</strong> (<em>float</em>) – first step to test.</p></li>
<li><p><strong>beta1</strong> (<em>float</em>) – parameter of the first Wolfe condition.</p></li>
<li><p><strong>beta2</strong> (<em>float</em>) – parameter of the second Wolfe condition.</p></li>
<li><p><strong>lbd</strong> (<em>float</em>) – expansion factor for a short step.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>a step verifing both Wolfe conditions</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>float</p>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><ul class="simple">
<li><p><a class="reference internal" href="exceptions.html#biogeme.exceptions.biogemeError" title="biogeme.exceptions.biogemeError"><strong>biogeme.exceptions.biogemeError</strong></a> – if <code class="docutils literal notranslate"><span class="pre">lbd</span></code> <span class="math notranslate nohighlight">\(\leq\)</span> 1</p></li>
<li><p><a class="reference internal" href="exceptions.html#biogeme.exceptions.biogemeError" title="biogeme.exceptions.biogemeError"><strong>biogeme.exceptions.biogemeError</strong></a> – if <code class="docutils literal notranslate"><span class="pre">alpha0</span></code> <span class="math notranslate nohighlight">\(\leq\)</span> 0</p></li>
<li><p><a class="reference internal" href="exceptions.html#biogeme.exceptions.biogemeError" title="biogeme.exceptions.biogemeError"><strong>biogeme.exceptions.biogemeError</strong></a> – if <code class="docutils literal notranslate"><span class="pre">beta1</span></code> <span class="math notranslate nohighlight">\(\geq\)</span> beta2</p></li>
<li><p><a class="reference internal" href="exceptions.html#biogeme.exceptions.biogemeError" title="biogeme.exceptions.biogemeError"><strong>biogeme.exceptions.biogemeError</strong></a> – if <code class="docutils literal notranslate"><span class="pre">d</span></code> is not a descent
direction</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="biogeme.algorithms.newtonLineSearch">
<span class="sig-prename descclassname"><span class="pre">biogeme.algorithms.</span></span><span class="sig-name descname"><span class="pre">newtonLineSearch</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">fct</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">x0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">eps</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">6.06273418136464e-06</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">maxiter</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">100</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/biogeme/algorithms.html#newtonLineSearch"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#biogeme.algorithms.newtonLineSearch" title="Permalink to this definition"></a></dt>
<dd><p>Newton method with inexact line search (Wolfe conditions)</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>fct</strong> (<em>optimization.functionToMinimize</em>) – object to calculate the objective function and its derivatives.</p></li>
<li><p><strong>x0</strong> (<em>numpy.array</em>) – starting point</p></li>
<li><p><strong>eps</strong> (<em>float</em>) – the algorithm stops when this precision is reached.
Default: <span class="math notranslate nohighlight">\(\varepsilon^{\frac{1}{3}}\)</span></p></li>
<li><p><strong>maxiter</strong> (<em>int</em>) – the algorithm stops if this number of iterations
is reached. Defaut: 100</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><p>x, messages</p>
<ul class="simple">
<li><p>x is the solution generated by the algorithm,</p></li>
<li><p>messages is a dictionary describing information about the lagorithm</p></li>
</ul>
</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>numpay.array, dict(str:object)</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="biogeme.algorithms.newtonTrustRegion">
<span class="sig-prename descclassname"><span class="pre">biogeme.algorithms.</span></span><span class="sig-name descname"><span class="pre">newtonTrustRegion</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">fct</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">x0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">delta0</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">eps</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">6.06273418136464e-06</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dl</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">maxiter</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1000</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">eta1</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.01</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">eta2</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.9</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/biogeme/algorithms.html#newtonTrustRegion"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#biogeme.algorithms.newtonTrustRegion" title="Permalink to this definition"></a></dt>
<dd><p>Newton method with trust region</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>fct</strong> (<em>optimization.functionToMinimize</em>) – object to calculate the objective function and its derivatives.</p></li>
<li><p><strong>x0</strong> (<em>numpy.array</em>) – starting point</p></li>
<li><p><strong>delta0</strong> (<em>float</em>) – initial radius of the trust region. Default: 100.</p></li>
<li><p><strong>eps</strong> (<em>float</em>) – the algorithm stops when this precision is reached.
Default: <span class="math notranslate nohighlight">\(\varepsilon^{\frac{1}{3}}\)</span></p></li>
<li><p><strong>dl</strong> (<em>bool</em>) – If True, the Dogleg method is used to solve the
trut region subproblem. If False, the truncated conjugate
gradient is used. Default: False.</p></li>
<li><p><strong>maxiter</strong> (<em>int</em>) – the algorithm stops if this number of iterations
is reached. Default: 1000.</p></li>
<li><p><strong>eta1</strong> (<em>float</em>) – threshold for failed iterations. Default: 0.01.</p></li>
<li><p><strong>eta2</strong> (<em>float</em>) – threshold for very successful iterations. Default 0.9.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><p>tuple x, messages, where</p>
<ul class="simple">
<li><p>x is the solution found,</p></li>
<li><p>messages is a dictionary reporting various aspects
related to the run of the algorithm.</p></li>
</ul>
</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>numpy.array, dict(str:object)</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="biogeme.algorithms.relativeChange">
<span class="sig-prename descclassname"><span class="pre">biogeme.algorithms.</span></span><span class="sig-name descname"><span class="pre">relativeChange</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">xpred</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">typx</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/biogeme/algorithms.html#relativeChange"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#biogeme.algorithms.relativeChange" title="Permalink to this definition"></a></dt>
<dd><p>Calculates the relative change.</p>
<p>It is typically used as stopping criterion.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x</strong> (<em>numpy.array</em>) – current iterate.</p></li>
<li><p><strong>xpred</strong> (<em>numpy.array</em>) – previous iterate.</p></li>
<li><p><strong>typx</strong> (<em>numpy.array</em>) – typical value for x.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>relative change:</p>
</dd>
</dl>
<div class="math notranslate nohighlight">
\[\max_i \frac{|(x_k)_i - (x_{k-1})_i|}{\max(|(x_k)_i|,
\text{typx}_i)}\]</div>
<dl class="field-list simple">
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>float</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="biogeme.algorithms.relativeGradient">
<span class="sig-prename descclassname"><span class="pre">biogeme.algorithms.</span></span><span class="sig-name descname"><span class="pre">relativeGradient</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">f</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">g</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">typx</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">typf</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/biogeme/algorithms.html#relativeGradient"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#biogeme.algorithms.relativeGradient" title="Permalink to this definition"></a></dt>
<dd><p>Calculates the relative gradients.</p>
<p>It is typically used as stopping criterion.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x</strong> (<em>numpy.array</em>) – current iterate.</p></li>
<li><p><strong>f</strong> (<em>float</em>) – value of f(x)</p></li>
<li><p><strong>g</strong> (<em>numpy.array</em>) – <span class="math notranslate nohighlight">\(\nabla f(x)\)</span>, gradient of f at x</p></li>
<li><p><strong>typx</strong> (<em>numpy.array</em>) – typical value for x.</p></li>
<li><p><strong>typf</strong> (<em>float</em>) – typical value for f.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>relative gradient</p>
</dd>
</dl>
<div class="math notranslate nohighlight">
\[\max_{i=1,\ldots,n}\frac{(\nabla f(x))_i
\max(x_i,\text{typx}_i)}
{\max(|f(x)|, \text{typf})}\]</div>
<dl class="field-list simple">
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>float</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="biogeme.algorithms.schnabelEskow">
<span class="sig-prename descclassname"><span class="pre">biogeme.algorithms.</span></span><span class="sig-name descname"><span class="pre">schnabelEskow</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">A</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tau</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">6.06273418136464e-06</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">taubar</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">3.6756745753887175e-11</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mu</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.1</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/biogeme/algorithms.html#schnabelEskow"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#biogeme.algorithms.schnabelEskow" title="Permalink to this definition"></a></dt>
<dd><p>Modified Cholesky factorization by <a class="reference external" href="https://doi.org/10.1137/s105262349833266x">Schnabel and Eskow (1999)</a>.</p>
<p>If the matrix is ‘safely’ positive definite, the output is the
classical Cholesky factor. If not, the diagonal elements are
inflated in order to make it positive definite. The factor <span class="math notranslate nohighlight">\(L\)</span>
is such that <span class="math notranslate nohighlight">\(A + E = PLL^TP^T\)</span>, where <span class="math notranslate nohighlight">\(E\)</span> is a diagonal
matrix contaninig the terms added to the diagonal, <span class="math notranslate nohighlight">\(P\)</span> is a
permutation matrix, and <span class="math notranslate nohighlight">\(L\)</span> is w lower triangular matrix.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>A</strong> (<em>numpy.array</em>) – matrix to factorize. Must be square and symmetric.</p></li>
<li><p><strong>tau</strong> (<em>float</em>) – tolerance factor.
Default: <span class="math notranslate nohighlight">\(\varepsilon^{\frac{1}{3}}\)</span>.
See <a class="reference external" href="https://doi.org/10.1137/s105262349833266x">Schnabel and Eskow (1999)</a></p></li>
<li><p><strong>taubar</strong> (<em>float</em>) – tolerance factor.
Default: <span class="math notranslate nohighlight">\(\varepsilon^{\frac{2}{3}}\)</span>.
See <a class="reference external" href="https://doi.org/10.1137/s105262349833266x">Schnabel and Eskow (1999)</a></p></li>
<li><p><strong>mu</strong> (<em>float</em>) – tolerance factor.
Default: 0.1.  See <a class="reference external" href="https://doi.org/10.1137/s105262349833266x">Schnabel and Eskow (1999)</a></p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>tuple <span class="math notranslate nohighlight">\(L\)</span>, <span class="math notranslate nohighlight">\(E\)</span>, <span class="math notranslate nohighlight">\(P\)</span>,
where <span class="math notranslate nohighlight">\(A + E = PLL^TP^T\)</span>.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>numpy.array, numpy.array, numpy.array</p>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><ul class="simple">
<li><p><a class="reference internal" href="exceptions.html#biogeme.exceptions.biogemeError" title="biogeme.exceptions.biogemeError"><strong>biogeme.exceptions.biogemeError</strong></a> – if the matrix A is not square.</p></li>
<li><p><a class="reference internal" href="exceptions.html#biogeme.exceptions.biogemeError" title="biogeme.exceptions.biogemeError"><strong>biogeme.exceptions.biogemeError</strong></a> – if the matrix A is not symmetric.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="biogeme.algorithms.simpleBoundsNewtonAlgorithm">
<span class="sig-prename descclassname"><span class="pre">biogeme.algorithms.</span></span><span class="sig-name descname"><span class="pre">simpleBoundsNewtonAlgorithm</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">fct</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bounds</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">x0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">proportionTrueHessian</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">infeasibleConjugateGradient</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">delta0</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tol</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">6.06273418136464e-06</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">steptol</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e-05</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cgtol</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">6.06273418136464e-06</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">maxiter</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1000</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">eta1</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.01</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">eta2</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.9</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">enlargingFactor</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">10</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/biogeme/algorithms.html#simpleBoundsNewtonAlgorithm"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#biogeme.algorithms.simpleBoundsNewtonAlgorithm" title="Permalink to this definition"></a></dt>
<dd><p>Trust region algorithm for problems with simple bounds</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>fct</strong> (<em>optimization.functionToMinimize</em>) – object to calculate the objective function and its derivatives.</p></li>
<li><p><strong>bounds</strong> (<em>class bounds</em>) – bounds on the variables</p></li>
<li><p><strong>x0</strong> (<em>numpy.array</em>) – starting point</p></li>
<li><p><strong>proportionTrueHessian</strong> (<em>float</em>) – proportion of the iterations where
the true hessian is calculated. When
not, the BFGS update is used. If
1.0, it is used for all
iterations. If 0.0, it is not used
at all.</p></li>
<li><p><strong>infeasibleConjugateGradient</strong> (<em>bool</em>) – if True, the conjugate
gradient algorithm may generate until
termination.  The result will then be
projected on the feasible domain.  If
False, the algorithm stops as soon as an
infeasible iterate is generated.
Default: False.</p></li>
<li><p><strong>delta0</strong> (<em>float</em>) – initial radius of the trust region. Default: 100.</p></li>
<li><p><strong>tol</strong> (<em>float</em>) – the algorithm stops when this precision is reached.
Default: <span class="math notranslate nohighlight">\(\varepsilon^{\frac{1}{3}}\)</span></p></li>
<li><p><strong>steptol</strong> (<em>float</em>) – the algorithm stops when the relative change in x
is below this threshold. Basically, if p significant
digits of x are needed, steptol should be set to
1.0e-p.  Default: <span class="math notranslate nohighlight">\(10^{-5}\)</span></p></li>
<li><p><strong>cgtol</strong> (<em>float</em>) – the conjugate gradient algorithm stops when this
precision is reached.  Default:
<span class="math notranslate nohighlight">\(\varepsilon^{\frac{1}{3}}\)</span></p></li>
<li><p><strong>maxiter</strong> (<em>int</em>) – the algorithm stops if this number of iterations
is reached. Default: 1000.</p></li>
<li><p><strong>eta1</strong> (<em>float</em>) – threshold for failed iterations. Default: 0.01.</p></li>
<li><p><strong>eta2</strong> (<em>float</em>) – threshold for very successful iterations. Default 0.9.</p></li>
<li><p><strong>enlargingFactor</strong> (<em>float</em>) – if an iteration is very successful, the
radius of the trust region is multiplied
by this factor. Default 10.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><p>x, messages</p>
<ul class="simple">
<li><p>x is the solution generated by the algorithm,</p></li>
<li><p>messages is a dictionary describing information about the lagorithm</p></li>
</ul>
</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>numpay.array, dict(str:object)</p>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><p><a class="reference internal" href="exceptions.html#biogeme.exceptions.biogemeError" title="biogeme.exceptions.biogemeError"><strong>biogeme.exceptions.biogemeError</strong></a> – if the dimensions of the
matrix initBfgs do not match the length of x0.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="biogeme.algorithms.truncatedConjugateGradient">
<span class="sig-prename descclassname"><span class="pre">biogeme.algorithms.</span></span><span class="sig-name descname"><span class="pre">truncatedConjugateGradient</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">g</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">H</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">delta</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/biogeme/algorithms.html#truncatedConjugateGradient"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#biogeme.algorithms.truncatedConjugateGradient" title="Permalink to this definition"></a></dt>
<dd><p>Find an approximation of the trust region subproblem using the
truncated conjugate gradient method</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>g</strong> (<em>numpy.array</em>) – gradient of the quadratic model.</p></li>
<li><p><strong>H</strong> (<em>numpy.array</em>) – hessian of the quadrartic model.</p></li>
<li><p><strong>delta</strong> (<em>float</em>) – radius of the trust region.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><p>d, diagnostic, where</p>
<ul class="simple">
<li><p>d is the approximate solution of the trust region subproblem,</p></li>
<li><p>diagnostic is the nature of the solution:</p>
<ul>
<li><p>1 for convergence,</p></li>
<li><p>2 if out of the trust region,</p></li>
<li><p>3 if negative curvature detected.</p></li>
<li><p>4 if a numerical problem has been encountered</p></li>
</ul>
</li>
</ul>
</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>numpy.array, int</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="biogeme.algorithms.truncatedConjugateGradientSubspace">
<span class="sig-prename descclassname"><span class="pre">biogeme.algorithms.</span></span><span class="sig-name descname"><span class="pre">truncatedConjugateGradientSubspace</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">xk</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">gk</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Hk</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">delta</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bounds</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">infeasibleIterate</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tol</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">6.06273418136464e-06</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/biogeme/algorithms.html#truncatedConjugateGradientSubspace"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#biogeme.algorithms.truncatedConjugateGradientSubspace" title="Permalink to this definition"></a></dt>
<dd><p>Find an approximation of the solution of the trust region
subproblem using the truncated conjugate gradient method within
the subspace of free variables. Free variables are those
corresponding to inactive constraints at the generalized Cauchy
point.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>xk</strong> (<em>numpy.array</em>) – current iterate.</p></li>
<li><p><strong>gk</strong> (<em>numpy.array</em>) – gradient of the quadratic model.</p></li>
<li><p><strong>Hk</strong> (<em>numpy.array</em>) – hessian of the quadrartic model.</p></li>
<li><p><strong>delta</strong> (<em>float</em>) – radius of the trust region.</p></li>
<li><p><strong>bounds</strong> (<em>class bioBounds</em>) – bounds on the variables.</p></li>
<li><p><strong>infeasibleIterate</strong> (<em>bool</em>) – if True, the algorithm may continue
until termination.  The result will then
be projected on the feasible domain.  If
False, the algorithm stops as soon as an
infeasible iterate is generated.
Default: False.</p></li>
<li><p><strong>tol</strong> (<em>float</em>) – tolerance used for stopping criterion.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><p>d, diagnostic, where</p>
<ul class="simple">
<li><p>d is the approximate solution of the trust region subproblem,</p></li>
<li><p>diagnostic is the nature of the solution:</p>
<ul>
<li><p>1 for convergence,</p></li>
<li><p>2 if out of the trust region,</p></li>
<li><p>3 if negative curvature detected.</p></li>
<li><p>4 if a numerical problem has been encountered</p></li>
</ul>
</li>
</ul>
</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>numpy.array, int</p>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><p><a class="reference internal" href="exceptions.html#biogeme.exceptions.biogemeError" title="biogeme.exceptions.biogemeError"><strong>biogeme.exceptions.biogemeError</strong></a> – if the dimensions are inconsistent</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="biogeme.algorithms.trustRegionIntersection">
<span class="sig-prename descclassname"><span class="pre">biogeme.algorithms.</span></span><span class="sig-name descname"><span class="pre">trustRegionIntersection</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dc</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">d</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">delta</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/biogeme/algorithms.html#trustRegionIntersection"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#biogeme.algorithms.trustRegionIntersection" title="Permalink to this definition"></a></dt>
<dd><p>Calculates the intersection with the boundary of the trust region.</p>
<p>Consider a trust region of radius <span class="math notranslate nohighlight">\(\delta\)</span>, centered at
<span class="math notranslate nohighlight">\(\hat{x}\)</span>. Let <span class="math notranslate nohighlight">\(x_c\)</span> be in the trust region, and
<span class="math notranslate nohighlight">\(d_c = x_c - \hat{x}\)</span>, so that <span class="math notranslate nohighlight">\(\|d_c\| \leq
\delta\)</span>. Let <span class="math notranslate nohighlight">\(x_d\)</span> be out of the trust region, and
<span class="math notranslate nohighlight">\(d_d = x_d - \hat{x}\)</span>, so that <span class="math notranslate nohighlight">\(\|d_d\| \geq
\delta\)</span>.  We calculate <span class="math notranslate nohighlight">\(\lambda\)</span> such that</p>
<div class="math notranslate nohighlight">
\[\| d_c + \lambda (d_d - d_c)\| = \delta\]</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>dc</strong> (<em>numpy.array</em>) – xc - xhat.</p></li>
<li><p><strong>d</strong> (<em>numpy.array</em>) – dd - dc.</p></li>
<li><p><strong>delta</strong> (<em>float</em>) – radius of the trust region.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><span class="math notranslate nohighlight">\(\lambda\)</span> such that <span class="math notranslate nohighlight">\(\| d_c +
\lambda (d_d - d_c)\| = \delta\)</span></p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>float</p>
</dd>
</dl>
</dd></dl>

</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="index.html" class="btn btn-neutral float-left" title="Welcome to Biogeme’s documentation!" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="assisted.html" class="btn btn-neutral float-right" title="Assisted specification" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2022, Michel Bierlaire.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>