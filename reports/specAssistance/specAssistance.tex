\documentclass[12pt,a4paper]{article}

% Package to include code
\usepackage{listings}
\usepackage{color}
\usepackage{tikz}
\usepackage{pgfplots}
\lstset{language=Python}
\lstset{numbers=none, basicstyle=\footnotesize,
  numberstyle=\tiny,keywordstyle=\color{blue},stringstyle=\ttfamily,showstringspaces=false}
\lstset{backgroundcolor=\color[rgb]{0.95 0.95 0.95}}
\lstdefinestyle{numbers}{numbers=left, stepnumber=1,
  numberstyle=\tiny,basicstyle=\tiny, numbersep=10pt}
\lstdefinestyle{nonumbers}{numbers=none}


% Font selection: uncomment the next line to use the ``beton'' font
%\usepackage{beton}

% Font selection: uncomment the next line to use the ``times'' font
%\usepackage{times}

% Font for equations
\usepackage{euler}


%Package to define the headers and footers of the pages
\usepackage{fancyhdr}


%Package to include an index
\usepackage{index}

%Package to display boxes around texts. Used especially for the internal notes.
\usepackage{framed}

%PSTricks is a collection of PostScript-based TEX macros that is compatible
% with most TEX macro packages
\usepackage{pstricks}
\usepackage{pst-node}
\usepackage{pst-plot}
\usepackage{pst-tree}

%Package to display boxes around a minipage. Used especially to
%describe the biography of people.
\usepackage{boxedminipage}

%Package to include postscript figures
\usepackage{epsfig}

%Package for the bibliography
% \cite{XXX} produces Ben-Akiva et. al., 2010
% \citeasnoun{XXX} produces Ben-Akiva et al. (2010)
% \citeasnoun*{XXX} produces Ben-Akiva, Bierlaire, Bolduc and Walker (2010)
\usepackage[dcucite,abbr]{harvard}
\harvardparenthesis{none}\harvardyearparenthesis{round}

%Packages for advanced mathematics typesetting
\usepackage{amsmath,amsfonts,amssymb}

%Package to display trees easily
%\usepackage{xyling}

%Package to include smart references (on the next page, on the
%previous page, etc.)
%%

%% Remove as it is not working when the book will be procesed by the
%% publisher.
%\usepackage{varioref}

%Package to display the euro sign
\usepackage[right,official]{eurosym}

%Rotate material, especially large table (defines sidewaystable)
\usepackage[figuresright]{rotating}

%Defines the subfigure environment, to obtain refs like Figure 1(a)
%and Figure 1(b).
\usepackage{subfigure}

%Package for appendices. Allows subappendices, in particular
\usepackage{appendix}

%Package controling the fonts for the captions
\usepackage[font={small,sf}]{caption}

%Defines new types of columns for tabular ewnvironment
\usepackage{dcolumn}
\newcolumntype{d}{D{.}{.}{-1}}
\newcolumntype{P}[1]{>{#1\hspace{0pt}\arraybackslash}}
\newcolumntype{.}{D{.}{.}{9.3}}

%Allows multi-row cells in tables
\usepackage{multirow}

%Tables spaning more than one page
\usepackage{longtable}


%%
%%  Macros by Michel
%%

\newcommand{\PBIOGEME}{PythonBiogeme}
\newcommand{\PDBIOGEME}{Biogeme}
\newcommand{\BIOGEME}{Biogeme}
\newcommand{\BBIOGEME}{BisonBiogeme}


%Internal notes
\newcommand{\note}[1]{
  \begin{framed}{}%
    \textbf{\underline{Internal note}:} #1
\end{framed}}

%Use this version to turn off the notes
%\newcommand{\note}[1]{}


%Include a postscript figure . Note that the label is prefixed with
%``fig:''. Remember it when you refer to it.
%Three arguments:
% #1 label
% #2 file (without extension)
% #3 Caption
\newcommand{\afigure}[3]{%
  \begin{figure}[!tbp]%
    \begin{center}%
      \epsfig{figure=#2,width=0.8\textwidth}%
    \end{center}
    \caption{\label{fig:#1} #3}%
\end{figure}}






%Include two postscript figures side by side.
% #1 label of the first figure
% #2 file for the first figure
% #3 Caption for the first figure
% #4 label of the second figure
% #5 file for the second figure
% #6 Caption for the first figure
% #7 Caption for the set of two figures
\newcommand{\twofigures}[7]{%
  \begin{figure}[htb]%
    \begin{center}%
      \subfigure[\label{fig:#1}#3]{\epsfig{figure=#2,width=0.45\textwidth}}%
      \hfill
      \subfigure[\label{fig:#4}#6]{\epsfig{figure=#5,width=0.45\textwidth}}%
    \end{center}
    \caption{#7}%
\end{figure}}

%Include a figure generated by gnuplot using the epslatex output. Note that the label is prefixed with
%``fig:''. Remember it when you refer to it.

%Three arguments:
% #1 label
% #2 file (without extension)
% #3 Caption
\newcommand{\agnuplotfigure}[3]{%
  \begin{figure}[!tbp]%
    \begin{center}%
      \input{#2}%
    \end{center}
    \caption{\label{fig:#1} #3}%
\end{figure}}

%Three arguments:
% #1 label
% #2 file (without extension)
% #3 Caption
\newcommand{\asidewaysgnuplotfigure}[3]{%
  \begin{sidewaysfigure}[!tbp]%
    \begin{center}%
      \input{#2}%
    \end{center}
    \caption{\label{fig:#1} #3}%
\end{sidewaysfigure}}


%Include two postscript figures side by side.
% #1 label of the first figure
% #2 file for the first figure
% #3 Caption for the first figure
% #4 label of the second figure
% #5 file for the second figure
% #6 Caption for the second figure
% #7 Caption for the set of two figures
% #8 label for the whole figure
\newcommand{\twognuplotfigures}[7]{%
  \begin{figure}[htb]%
    \begin{center}%
      \subfigure[\label{fig:#1}#3]{\input{#2}}%
      \hfill
      \subfigure[\label{fig:#4}#6]{\input{#5}}%
    \end{center}
    \caption{#7}%
\end{figure}}



%Include the description of somebody. Four arguments:
% #1 label
% #2 Name
% #3 file (without extension)
% #4 description
\newcommand{\people}[4]{
  \begin{figure}[tbf]
    \begin{boxedminipage}{\textwidth}
      \parbox{0.40\textwidth}{\epsfig{figure=#3,width = 0.39\textwidth}}%\hfill
      \parbox{0.59\textwidth}{%
        #4%
      }%
    \end{boxedminipage}
    \caption{\label{fig:#1} #2}
  \end{figure}
}

%Default command for a definition
% #1 label (prefix def:)
% #2 concept to be defined
% #3 definition
\newtheorem{definition}{Definition}
\newcommand{\mydef}[3]{%
  \begin{definition}%
    \index{#2|textbf}%
    \label{def:#1}%
    \textbf{#2} \slshape #3\end{definition}}

%Reference to a definitoin. Prefix 'def:' is assumed
\newcommand{\refdef}[1]{definition~\ref{def:#1}}


%Default command for a theorem, with proof
% #1: label (prefix thm:)
% #2: name of the theorem
% #3: statement
% #4: proof
\newtheorem{theorem}{Theorem}
\newcommand{\mytheorem}[4]{%
  \begin{theorem}%
    \index{#2|textbf}%
    \index{Theorems!#2}%
    \label{thm:#1}%
    \textbf{#2} \sffamily \slshape #3
  \end{theorem} \bpr #4 \epr \par}


%Default command for a theorem, without proof
% #1: label (prefix thm:)
% #2: name of the theorem
% #3: statement
\newcommand{\mytheoremsp}[3]{%
  \begin{theorem}%
    \index{#2|textbf}%
    \index{Theorems!#2}%
    \label{thm:#1}%
    \textbf{#2} \sffamily \slshape #3
\end{theorem}}



%Put parentheses around the reference, as standard for equations
\newcommand{\req}[1]{(\ref{#1})}

%Short cut to make a column vector in math environment (centered)
\newcommand{\cvect}[1]{\left(\begin{array}{c} #1 \end{array} \right) }

%Short cut to make a column vector in math environment (right justified)
\newcommand{\rvect}[1]{\left(\begin{array}{r} #1 \end{array} \right) }

%A reference to a theorem. Prefix thm: is assumed for the label.
\newcommand{\refthm}[1]{Theorem~\ref{thm:#1}}

%Reference to a figure. Prefix fig: is assumed for the label.
\newcommand{\reffig}[1]{Figure~\ref{fig:#1}}

%Smart reference to a figure. Prefix fig: is assumed for the label.
%\newcommand{\vreffig}[1]{Figure~\vref{fig:#1}}

%C in mathcal font for the choice set
\newcommand{\C}{\mathcal{C}}

%R in bold font for the set of real numbers
\newcommand{\R}{\mathbb{R}}

%N in bold font for the set of natural numbers
\newcommand{\N}{\mathbb{N}}

%C in mathcal font for the log likelihood
\renewcommand{\L}{\mathcal{L}}

%S in mathcal font for the subset S
\renewcommand{\S}{\mathcal{S}}

%To write an half in math envionment
\newcommand{\half}{\frac{1}{2}}

%Probability
\newcommand{\prob}{\operatorname{Pr}}

%Expectation
\newcommand{\expect}{\operatorname{E}}

%Variance
\newcommand{\var}{\operatorname{Var}}

%Covariance
\newcommand{\cov}{\operatorname{Cov}}

%Correlation
\newcommand{\corr}{\operatorname{Corr}}

%Span
\newcommand{\myspan}{\operatorname{span}}

%plim
\newcommand{\plim}{\operatorname{plim}}

%Displays n in bold (for the normal distribution?)
\newcommand{\n}{{\bf n}}

%Includes footnote in a table environment. Warning: the footmark is
%always 1.
\newcommand{\tablefootnote}[1]{\begin{flushright}
    \rule{5cm}{1pt}\\
    \protect\footnotemark[1]{\footnotesize #1}
  \end{flushright}
}
\renewcommand*{\thefootnote}{\alph{footnote}}

%Defines the ``th'' as in ``19th'' to be a superscript
\renewcommand{\th}{\textsuperscript{th}}

%Begin and end of a proof
\newcommand{\bpr}{{\bf Proof.} \hspace{1 em}}
\newcommand{\epr}{$\Box$}


\title{Assisted specification with Biogeme}
\author{Michel Bierlaire \and Nicola Ortelli}
\date{July 7, 2022}


\begin{document}


\begin{titlepage}
  \pagestyle{empty}

  \maketitle
  \vspace{2cm}

  \begin{center}
    \small Report TRANSP-OR 220707 \\ Transport and Mobility Laboratory \\ School of Architecture, Civil and Environmental Engineering \\ Ecole Polytechnique F\'ed\'erale de Lausanne \\ \verb+transp-or.epfl.ch+
    \begin{center}
      \textsc{Series on Biogeme}
    \end{center}
  \end{center}


  \clearpage
\end{titlepage}


The package Biogeme (\texttt{biogeme.epfl.ch}) is designed to estimate
the parameters of various models using maximum likelihood
estimation. It is particularly designed for discrete choice
models.

This document describes how to use \PDBIOGEME\ to apply the
methodology for assisted specification described by
\citeasnoun{OrteHillCamadeLaBier21}. In a nutshell, an optimization
algorithm is used to generate models based on a minimal
number of inputs provided by the analyst. These inputs are used to
build a space of possible specifications that may contain any form of
variable interaction, nonlinear transformation, segmentation of the
population in the dataset and potential choice models; the space is
then explored by an algorithm that sequentially introduces small
modifications to an initial set of promising specifications.

We assume that the reader is already familiar with discrete choice
models, and has successfully installed \PDBIOGEME.\@  \PDBIOGEME\ is
a Python package written in Python and C++, that relies on the
Pandas library for the management of the data.  This document has
been written using \PDBIOGEME\ 3.2.9.

\clearpage

\section{Modeling elements}

We first define the modeling elements that are combined for the
specification of a discrete choice model.

\begin{description}
\item[Alternatives] An alternative is an element of the choice
  set $\C$.
\item[Variable] A variable is an explanatory, or independent, variable that is
  present in the data set. 
\item[Characteristic] A characteristic is a variable that does not
  vary across alternatives. Typical characteristics are the
  socio-economic characteristics of the decision-maker (age, income,
  gender, etc.), and the variables describing the choice context
  (day of the week, weather conditions, etc.) In our context, they
  are used to segment the population into mutually exclusive segments.
\item[Attribute] An attribute is a variable that does vary across
  alternatives.
\item[Group of attributes] A group captures the same attribute in
  different utility functions. All attributes in the same group play
  similar roles in the specification of the model. A group of
  attributes is said to be \emph{active} if it is involved in the
  specification of the choice model.
\item[Coefficient] When the utility function is a linear combination
  of attributes, the coefficients of this combination are unknown
  parameters to be estimated.
\item[Segmentation] The population can be segmented using one or
  several characteristics. In that case, a different coefficient is
  associated with each segment of the population.
\item[Generic group of attributes] A group of attributes is said to
  be generic if the same coefficient is used for each attribute in
  the group.
\item[Alternative specific group of attributes] A group of  attributes that is not
  generic is said to be ``alternative specific''. 
\item[Transformation] A transformation is a function that transforms the value
  of the attributes in a group. It may involve unknown parameters and
  nonlinear specifications. 
\end{description}

\section{A step by step specification}

We describe now how to prepare a Python script for the assisted
specification of a choice model. We use the Swissmetro example to
illustrate each step.

\begin{enumerate}
\item \label{item:data}Data preparation: this step is exactly the same as for any
  Biogeme model. An object of type \lstinline@biogeme.database@ has to
  be defined. Each variable is associated with an object of type
  \lstinline@biogeme.expressions.Variable@, which can be a column of
  the original dataset, or a new variable defined by the user. We
  refer the reader to the documentation of \PDBIOGEME\ and to the
  online examples for more details.
\item \label{item:attributes}Dictionary of attributes: the attributes that may be involved in
  the model specification are identified and named, in the form of a
  dictionary. The keys of the dictionary are the names, and the values
  are the corresponding  \lstinline@biogeme.expressions.Variable@. For
  example,

  \begin{lstlisting}
    attributes = {
      'Train travel time': TRAIN_TT_SCALED,
      'Swissmetro travel time': SM_TT_SCALED,
      'Car travel time': CAR_TT_SCALED,
      'Train travel cost': TRAIN_COST,
      'Swissmetro travel cost': SM_COST,
      'Car travel cost': CAR_COST,
      'Train headway': TRAIN_HE,
      'Swissmetro headway': SM_HE,
    }
  \end{lstlisting}
\item \label{item:groups} Dictionary of groups of attributes: the keys of the dictionary
  are the names of the group. The values are a list of names of
  attributes. Note that no attribute can appear in more than one
  group.
  \begin{lstlisting}
    groupsOfAttributes = {
      'Travel time': [
        'Train travel time',
        'Swissmetro travel time',
        'Car travel time',
      ],
      'Travel cost': [
        'Train travel cost',
        'Swissmetro travel cost',
        'Car travel cost',
      ],
      'Headway': ['Train headway', 'Swissmetro headway'],
    }
  \end{lstlisting}
\item \label{item:generic} The algorithm tries to change the status of groups of
  attributes from generic to alternative specific. It is possible to
  force some groups to always be alternative specific by defining
  the list of their names. If there is no such restriction, set the
  list to None.
  \begin{lstlisting}
    genericForbiden = None
  \end{lstlisting}
\item \label{item:active}The algorithm tries to include or not each group of
  attributes in the model. It is possible to force some groups to
  always be active, that is, to be in the model, by defining the list
  of their names. If there is no such restriction, set the
  list to None. 
  \begin{lstlisting}
    forceActive = ['Travel time', 'Travel cost']
  \end{lstlisting}
\item \label{item:transform}Define possible transformations of the attributes. Each of these
  transformations is characterized by a Python function that takes a
  real number as input, and returns a tuple with two elements:
  \begin{enumerate}
  \item the name of the transformation,
  \item a Biogeme expression (that is, an object of type

    \lstinline@biogeme.expressions@) to calculate the transformation.
  \end{enumerate}
  \begin{lstlisting}
    def mylog(x):
    """Log of the attribute, or 0 if it is zero"""
    return 'log', Elem({0: log(x), 1: Numeric(0)}, x == 0)
  \end{lstlisting}
  More examples are discussed in Section~\ref{sec:transform}.
Then, associate each group of attributes with possible
  transformations. Note that the option not to transform the attribute
  is automatically considered. Define a dictionary where the keys are the
  names of the groups of attributes, and the values are lists of
  functions defined in the previous step.
  \begin{lstlisting}
    transformations = {
      'Travel time': [
        mylog,
        sqrt,
        square,
        piecewise_time_1,
        piecewise_time_2,
        boxcox_time,
      ],
      'Travel cost': [
        mylog,
        sqrt,
        square,
        piecewise_cost_1,
        piecewise_cost_2,
        boxcox_cost,
      ],
      'Headway': [mylog, sqrt, square, boxcox_headway],
    }

  \end{lstlisting}

\item \label{item:segment}Define the  potential segmentations. A segmentation is based on
  a discrete characteristic $z$ that can take several values:
  $z_1,\ldots, z_\ell$. It is defined by a tuple with two elements:
  \begin{enumerate}
  \item an object of type \lstinline@biogeme.expressions.Variable@
    that captures the characteristic,
  \item a dictionary associating each possible value with a name
    describing it.
  \end{enumerate}
  As a group of attributes can potentially be associated with several
  segmentations, we define a dictionary where the keys are the names
  of the segmentations, and the values are the tuples described above.
  \begin{lstlisting}
segmentations_cost = {
    'GA': DiscreteSegmentationTuple(
        variable=GA,
        mapping={1: 'GA', 0: 'noGA'}
    ),
    'gender': DiscreteSegmentationTuple(
        variable=MALE,
        mapping={0: 'female', 1: 'male'}
    ),
    'income': DiscreteSegmentationTuple(
        variable=INCOME,
        mapping={
            1: 'inc-under50',
            2: 'inc-50-100',
            3: 'inc-100+',
            4: 'inc-unknown',
        },
    ),
    'class': DiscreteSegmentationTuple(
        variable=FIRST,
        mapping={0: 'secondClass', 1: 'firstClass'}
    ),
    'who': DiscreteSegmentationTuple(
        variable=WHO,
        mapping={1: 'egoPays', 2: 'employerPays', 3: 'fiftyFifty'},
    ),
}
  \end{lstlisting}

  Each of these potential segmentations is then associated with a name,
  using a dictionary. It also clarifies if the segmentation should be
  done for each characteristic separately, or if all combinations of
  all possible values of the characteristics should be used for the
  segmentation. In the latter case, \lstinline@combinatorial@ must be
  set to True.
  \begin{lstlisting}
segmentations = {
    'Seg. cte': SegmentedParameterTuple(
        dict=segmentations_cte, combinatorial=False
    ),
    'Seg. cost': SegmentedParameterTuple(
        dict=segmentations_cost, combinatorial=False
    ),
    'Seg. time': SegmentedParameterTuple(
        dict=segmentations_time, combinatorial=False
    ),
    'Seg. headway': SegmentedParameterTuple(
        dict=segmentations_headway, combinatorial=False
    ),
}
  \end{lstlisting}
Note that this feature allows the algorithm to investigate interactions between
attributes and discrete characteristics. In order to model
interactions between attributes and continuous characteristics, see
the example provided in Section~\ref{sec:transform}.  
\item \label{item:util}Specification of the utility functions as a list of
  terms. Each term is a tuple with the following elements:
  \begin{enumerate}
  \item the name of an attribute, or \lstinline@None@ for the
    alternative specific constant,
  \item the name of a list of segmentations,
  \item the bounds on the associated coefficients, in the form of
    a tuple \lstinline@(lower_bound, upper_bound)@, where each of
    these entries can be set to \lstinline@None@ is no bound is
    needed,
  \item a function that verifies the validity of the estimated
    coefficient. Each model where the estimated value of the
    parameter is invalid is rejected. The function takes a value as input and returns
    a boolean. For instance, if we expect a coefficient to be
    negative, we can define the following function:
    \begin{lstlisting}
def negativeParameter(val):
      return val < 0
    \end{lstlisting}
  \end{enumerate}
  Note that the bounds apply to the coefficients of
  each segment of the population.  Here is an example of the definition
  of the utility function:
  \begin{lstlisting}
utility_train = [
    TermTuple(
        attribute=None,
        segmentation='Seg. cte',
        bounds=(None, None),
        validity=None,
    ),
    TermTuple(
        attribute='Train travel time',
        segmentation='Seg. time',
        bounds=(None, 0),
        validity=None,
    ),
    TermTuple(
        attribute='Train travel cost',
        segmentation='Seg. cost',
        bounds=(None, 0),
        validity=None,
    ),
    TermTuple(
        attribute='Train headway',
        segmentation='Seg. headway',
        bounds=(None, 0),
        validity=None,
    ),
]
  \end{lstlisting}
Then, associate each utility function with the ID of the alternative,
  and with a name. Define a dictionary such that the keys are the ID
  of the alternatives, and the values are a tuple with the following
  elements:
  \begin{enumerate}
  \item the name of the alternative,
  \item a list describing the specification of the utility function,
    as described in the previous step.
  \end{enumerate}
  For example,
  \begin{lstlisting}
    utilities = {
      1: ('train', utility_train),
      2: ('Swissmetro', utility_sm),
      3: ('car', utility_car),
    }
  \end{lstlisting}
\item \label{item:avail}Define the availability condition, in the exact same way as
  for any Biogeme specification, that is a dictionary where the keys
  are the ID of the alternatives, and the values are Biogeme
  expressions (\lstinline@biogeme.expressions.Expression@). For
  example,
  \begin{lstlisting}
    availabilities = {
      1: TRAIN_AV_SP,
      2: SM_AV,
      3: CAR_AV_SP
    }
  \end{lstlisting}
\item \label{item:models}We define potential candidates for the choice model. Each
  candidate is a function that takes as input three arguments:
  \begin{enumerate}
  \item the dictionary of utility functions,
  \item the dictionary of availability conditions, and
  \item the expression to calculate the chosen alternative. 
  \end{enumerate}
  It returns, as output, an expression representing the
  contribution of each observation to the log likelihood function.
  For example,
  \begin{lstlisting}
def nested1(V, av, choice):
    existing = Beta('mu_existing', 1, 1, None, 0), [1, 3]
    future = 1.0, [2]
    nests = existing, future
    return models.lognested(V, av, nests, choice)
  \end{lstlisting}

  
  Each of these functions is associated with a name in a
  dictionary:
  \begin{lstlisting}
    myModels = {
      'Logit': logit,
      'Nested one stop': nested1,
      'Nested same': nested2,
      'CNL alpha fixed': cnl1,
      'CNL alpha est.': cnl2,
    }
  \end{lstlisting}
\item The last step consists in defining the optimization problem,
  gathering the ingredients defined above. An object of type
  \lstinline@biogeme.assisted.specificationProblem@ is created, with
  the following arguments for the constructor:
  \begin{enumerate}
  \item the name of the problem,
  \item the \lstinline{biogeme.database} object containing the data
    (from step~\ref{item:data}),
  \item the dictionary of all attributes, defined at
    step~\ref{item:attributes},
  \item the dictionary of all groups of attributes, defined at
    step~\ref{item:groups},
  \item the list of groups that must be alternative specific,
    defined at step~\ref{item:generic},
  \item the list of groups that must be in the model, defined at
    step~\ref{item:active},
  \item the dictionary of transformations of attributes, defined
    at step~\ref{item:transform},
  \item the dictionary of segmentations, defined at step~\ref{item:segment},
  \item the dictionary of utility functions, defined at
    step~\ref{item:util},
  \item the dictionary of availability conditions, defined at
    step \ref{item:avail},
  \item the Biogeme expression calculating the chosen alternative,
  \item the dictionary of possible choice models, defined
    at step~\ref{item:models}.
  \end{enumerate}
  For example,
  \begin{lstlisting}
theProblem = assisted.specificationProblem(
    'Swissmetro',
    database,
    attributes,
    groupsOfAttributes,
    genericForbiden,
    forceActive,
    transformations,
    segmentations,
    utilities,
    availabilities,
    CHOICE,
    myModels,
)
  \end{lstlisting}
\end{enumerate}

\section{Running the algorithm}

In order to run the algorithm, we need to provide initial
specifications that the algorithm tries to improve. A
specification is characterized by two dictionaries. The first one
associates each group of attributes with the index of a transformation (or
\lstinline@None@) and a boolean that is True if the coefficient is
generic, and False if it is alternative specific.
For instance,
\begin{lstlisting}
attr = {
    'Travel time': (1, False),
    'Travel cost': (0, True),
    'Headway': (0, False),
}
\end{lstlisting}
If $n$ transformations have been associated with a group of
attributes, the index must be between $0$ and $n-1$.
The second dictionary activates specific dimensions of the
segmentations. For instance, the following dictionary
activates one dimension for the constant  and the
headway coefficients, and two dimensions for the cost coefficient.
The time coefficient is not segmented, and is the same for all observations.
\begin{lstlisting}
sg = {
    'Seg. cte': ['GA'],
    'Seg. cost': ['class', 'who'],
    'Seg. time': [],
    'Seg. headway': ['class'],
}
\end{lstlisting}
The actual model is generated by the function
\lstinline@generateSolution@ that takes three arguments:
\begin{enumerate}
\item the dictionary describing the transformation, as introduced above,
\item the dictionary describing the segmentations, as introduced
  above,
\item the name of the choice model.
\end{enumerate}
For instance, we can create five models, with the same specification
for the utility functions, but different assumptions for the error
term as follows:
\begin{lstlisting}
initSolutions = [
    theProblem.generateSolution(attr, sg, 'Logit'),
    theProblem.generateSolution(attr, sg, 'Nested one stop'),
    theProblem.generateSolution(attr, sg, 'Nested same'),
    theProblem.generateSolution(attr, sg, 'CNL alpha fixed'),
    theProblem.generateSolution(attr, sg, 'CNL alpha est.'),
]
\end{lstlisting}

The algorithm investigates many specifications, and estimates the
corresponding set of parameters. All these specifications are stored
in a \lstinline@pickle@ file (a binary representation of Python
objects).  Therefore, the algorithm can be interrupted at any time,
and restarted at the point it was interrupted. Moreover, the
\lstinline@pickle@ file contains the Pareto optimal models, as
discussed later.

The following instruction launches the algorithm:
\begin{lstlisting}
vns.vns(
    theProblem,
    initSolutions,
    archiveInputFile='swissmetroPareto.pickle',
    pickleOutputFile='swissmetroPareto.pickle',
)
\end{lstlisting}
Note that it is simpler to use the same \lstinline@pickle@ file for
input and output, to avoid any specific manipulation between two
runs. For the first run, when no \lstinline@pickle@ file is available
yet, simply define \lstinline@archiveInputFile=None@.


\section{Exploring the Pareto set}

The algorithm generates a \lstinline@pickle@ file where the Pareto
optimal solutions are stored. These solutions can be explored using
the following statements: 
\begin{lstlisting}
from biogeme import vns
pickleFile = 'swissmetroPareto.pickle'
pareto = vns.paretoClass(
    0,
    archiveInputFile=pickleFile
)
for p in pareto.pareto:
    print('----------------------------')
    print(p)
\end{lstlisting}
For each model, it prints the name of the model, the description of
the specification of the utility function, the value of the final
log likelihood function and the number of parameters, as in the
following examples:
\begin{lstlisting}
Nested one stop----------------------
Alternative train [1]
----------------------
Cte. <GA, gender>
Train travel time_log [alt. spec.] <GA>
Train travel cost_log [alt. spec.] <class, who>
Train headway_log [generic] <class>
---------------------------
Alternative Swissmetro [2]
---------------------------
Cte. <GA, gender>
Swissmetro travel time_log [alt. spec.] <GA>
Swissmetro travel cost_log [alt. spec.] <class, who>
Swissmetro headway_log [generic] <class>
--------------------
Alternative car [3]
--------------------
Car travel time_log [alt. spec.] <GA>
Car travel cost_log [alt. spec.] <class, who>

Neg. log likelihood: 7786.078102793665
#parameters: 32
\end{lstlisting}

Actually, the \lstinline@pickle@ file contains  three sets of models:
\begin{itemize}
  \item the set of Pareto optimal solutions that are not dominated by
    any other model (illustrated above),
  \item the set of considered solutions that contains all models that
    have been investigated by the algorithm,
  \item the set of removed solutions that contains the models that
    have been at some point in the Pareto set, but have been removed
    when a better model has been found. 
\end{itemize}

It is interesting to visualize these three sets using the following code:
\begin{lstlisting}
import matplotlib.pyplot as plt
from biogeme import vns

pickleFile = 'swissmetroPareto.pickle'
pareto = vns.paretoClass(0, archiveInputFile=pickleFile)

objectives = list(pareto.pareto)[0].objectivesNames
par_obj = [p.objectives for p in pareto.pareto]
par_x, par_y = zip(*par_obj)
con_obj = [p.objectives for p in pareto.considered]
con_x, con_y = zip(*con_obj)
rem_obj = [p.objectives for p in pareto.removed]
rem_x, rem_y = zip(*rem_obj)

x_buffer = 10
y_buffer = 0.1

plt.axis(
    [
        min(par_x) - x_buffer,
        max(par_x) + x_buffer,
        min(par_y) - y_buffer,
        max(par_y) + y_buffer,
    ]
)
plt.plot(par_x, par_y, 'o', label='Pareto')
plt.plot(rem_x, rem_y, 'x', label='Removed')
plt.plot(con_x, con_y, ',', label='Considered')
plt.xlabel(objectives[0])
plt.ylabel(objectives[1])
plt.legend()
plt.show()
\end{lstlisting}
The resulting plot is represented in Figure~\ref{fig:pareto}, where
the $x$-axis represents the value of the negative log likelihood, and
the $y$-axis represents the number of parameters. The idea is that
each of these objectives should be as small as possible. The trade-off
between these two objectives is well illustrated by this figure.
\begin{figure}
  \begin{center}
    \epsfig{figure=pareto, width=0.9\textwidth}
  \end{center}
  \caption{\label{fig:pareto}Illustration of the models investigated
    by the algorithm}
\end{figure}

The results of the algorithm allow to better appreciate
the trade-off between the goodness of fit and the
parsimony. But the final decision about which model in the Pareto set
must be preferred lies with
the modeler.

\section{Transformation of variables}
\label{sec:transform}

The transformation of variables provides a great flexibility to
investigate various specifications of a choice model. In general, it
is used to investigate nonlinear specifications, but it does not have
to.

We provide here some examples of transformations.

First, any simple transformation can be investigated. For instance,
the square of the variable:
\begin{lstlisting}
def square(x):
    return 'square', x ** 2
\end{lstlisting}

The Box-Cox transformation can also be investigated. In that case, it
involves an additional parameter to be estimated. We first define a
generic Box-Cox function, as follows.
\begin{lstlisting}
def boxcox(x, name):
    ell = Beta(f'lambda_{name}', 1, None, None, 0)
    return f'Box-Cox_{name}', models.boxcox(x, ell)
\end{lstlisting}
It defines first a parameter, which is initialized at the value
1. Then, it combines the name of the transformation, with the Box-Cox
model implemented in the Biogeme module \lstinline@models@.

This generic function can now be used to implement several specific
transformations. For instance, the Box-Cox transformation of the
travel time variable can be coded as follows:
\begin{lstlisting}
def boxcox_time(x):
    return boxcox(x, 'time')
\end{lstlisting}
Similarly, the Box-Cox transformation of the cost variable can be
coded as follows:
\begin{lstlisting}
def boxcox_cost(x):
    return boxcox(x, 'cost')
\end{lstlisting}
The reason why we need two different functions is to associate a
different parameter with each transformation.

A similar implementation can be used to investigate piecewise linear
specifications. Indeed, different variables are associated with
different thresholds for such a specification. We first implement a
generic function, that also relies on the Biogeme module
\lstinline@models@:
\begin{lstlisting}
def piecewise(x, thresholds, name):
    piecewiseVariables = models.piecewiseVariables(x, thresholds)
    formula = piecewiseVariables[0]
    for k in range(1, len(thresholds) - 1):
        formula += (
            Beta(
                f'pw_{name}_{thresholds[k-1]}_{thresholds[k]}',
                0,
                None,
                None,
                0,
            )
            * piecewiseVariables[k]
        )
    return (f'piecewise_{name}_{thresholds}', formula)
\end{lstlisting}
Now, we can define specific transformations of the same variable. For
example, we transform the time variable based on the threshold $[0,
  0.1, \infty[$ as follows:
    \begin{lstlisting}
def piecewise_time_1(x):
    return piecewise(x, [0, 0.1, None], 'time')
    \end{lstlisting}
The transformation of the same variable with a different list of
thresholds is obtained as follows:
\begin{lstlisting}
def piecewise_time_2(x):
    return piecewise(x, [0, 0.25, None], 'time')
\end{lstlisting}

Transformation of variables can also be used to investigate
interactions with continuous characteristics. In the following
example, the variable \lstinline@distance_km@ is a continuous
characteristic. It provides the distance between an origin and a
destination in a mode choice context. In order to investigate its
interaction with an attribute, the following transformation can be
implemented:
\begin{lstlisting}
from biogeme.expressions import Variable
def distanceInteraction(x):
    return (
        'dist. interaction',
        x * log(1 + Variable('distance_km') / 1000)
    )
\end{lstlisting}
If income is coded as a continuous variable, its interaction with an
attribute can be coded as follows: 
\begin{lstlisting}
from biogeme.expressions import Variable
def incomeInteraction(x):
    return (
        'income interaction',
        x / Variable('income)
    )
\end{lstlisting}



\bibliographystyle{dcu}
\bibliography{../dca}

\end{document}
