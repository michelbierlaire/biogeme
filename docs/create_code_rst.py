import os
import shutil
from datetime import datetime

from biogeme.native_draws import description_of_native_draws
from biogeme.default_parameters import all_parameters_tuple, ParameterTuple
from biogeme.parameters import Parameters


def readme_file(filename: str) -> None:
    """Generates a README file

    :param filename: name of the file
    """
    with open(file=filename, mode='w') as f:
        now = datetime.now()
        title = 'Generated documentation for Biogeme'
        print(title, file=f)
        print('=' * len(title), file=f)
        print(
            f'The content of this directory has been generated by a script on {now.strftime("%Y-%m-%d %H:%M:%S")}.',
            file=f,
        )
        print('Its content should not be manually edited.', file=f)


def draws_documentation(filename: str) -> None:
    header = """
The generation of draws is performed using the command ``bioDraws(’var’, ’DRAW_TYPE’)``, where the first argument, ``var``, 
provides the name of the random variable associated with the draws, and the second argument, ``DRAW_TYPE``, provides the 
distribution of the random variable (see the :class:`~biogeme.expressions.elementary_expressions.bioDraws` documentation). 
The draw type can either be a user-defined type 
(see `Bierlaire (2019) <http://transp-or.epfl.ch/documents/technicalReports/Bier19.pdf>`_ for details)
or native draws provided with Biogeme. The list if native doraws is provided in the following table.
    """

    description: dict[str, str] = description_of_native_draws()
    with open(file=filename, mode='w') as f:
        title = 'Native draws'
        print(title, file=f)
        print('=' * len(title), file=f)
        print(header, file=f)
        print('', file=f)
        print('.. list-table::', file=f)
        print('   :header-rows: 1', file=f)
        print('', file=f)
        print('   * - Name', file=f)
        print('     - Description', file=f)
        for name, desc in description.items():
            print(f'   * - ``{name}``', file=f)
            print(f'     - {desc}', file=f)

        print('.. toctree::', file=f)
        print('  :maxdepth: 2', file=f)
        print('  :caption: Native draws', file=f)


def toml_documentation(filename: str) -> None:
    header = """
Biogeme can be configured using a parameter file. By default, the name is supposed to be ``biogeme.toml``. If such a
file does not exist, Biogeme will create one containing the default values. The following table provides a description
of all parameters that can be configured.
    """

    # Retrieve all parameters, and organize them by section, in alphabetical order.
    all_parameters: tuple[ParameterTuple, ...] = all_parameters_tuple()
    # Extract unique section names and sort them
    sections: list[str] = sorted(set(param.section for param in all_parameters))
    # Group ParameterTuple objects by their section
    grouped_by_section: dict[str : list[ParameterTuple]] = {
        section: [] for section in sections
    }
    for param in all_parameters:
        grouped_by_section[param.section].append(param)

    # Sort each group by name
    for section in grouped_by_section:
        grouped_by_section[section].sort(key=lambda param: param.name)

    with open(file=filename, mode='w') as f:
        title = 'Configuration parameters'
        print(title, file=f)
        print('=' * len(title), file=f)
        print(header, file=f)
        print('', file=f)
        print('.. list-table::', file=f)
        print('   :header-rows: 1', file=f)
        print('', file=f)
        print('   * - Name', file=f)
        print('     - Description', file=f)
        print('     - Default', file=f)
        print('     - Section', file=f)
        print('     - Type', file=f)

        for section, the_list in grouped_by_section.items():
            for the_parameter in the_list:
                the_class_type = str(the_parameter.type)
                the_type = the_class_type.split("'")[1].split("'")[0]
                print(f'   * - {the_parameter.name}', file=f)
                print(f'     - {the_parameter.description}', file=f)
                print(f'     - {the_parameter.value}', file=f)
                print(f'     - {section}', file=f)
                print(f'     - {the_type}', file=f)

        print('', file=f)
        print('The structure of the ``biogeme.toml`` file is as follows.', file=f)
        print('', file=f)
        print('.. literalinclude:: biogeme.toml', file=f)
        print('   :language: none', file=f)
        print('   :linenos:', file=f)
        print('', file=f)

        print('.. toctree::', file=f)
        print('  :maxdepth: 2', file=f)
        print('  :caption: Configuration parameters', file=f)


def create_rst_structure(src_dir: str, dst_dir: str) -> None:
    if os.path.exists(dst_dir):
        user_input = input(
            f'The destination directory {dst_dir} already exists. Do you want to delete it and create a new one? (yes/no): '
        )
        if user_input.lower() == 'yes':
            shutil.rmtree(dst_dir)
        else:
            print("Operation cancelled.")
            return

    os.makedirs(dst_dir)

    readme = os.path.join(dst_dir, f'README.rst')
    readme_file(filename=readme)

    draws = os.path.join(dst_dir, f'native_draws.rst')
    draws_documentation(filename=draws)

    toml = os.path.join(dst_dir, f'toml.rst')
    toml_documentation(filename=toml)

    # Generate a TOML file
    biogeme_toml = os.path.join(dst_dir, f'biogeme.toml')
    the_parameters = Parameters()
    the_parameters.dump_file(file_name=biogeme_toml)

    exclude_dirs = ['.mypy_cache', 'biogeme.egg-info', '__pycache__']
    exclude_files = ['__init__.py', 'logging_tmp.py']

    # Create first the auto-modules
    for root, dirs, files in os.walk(src_dir):
        dirs[:] = sorted([d for d in dirs if d not in exclude_dirs])
        files = sorted(
            [f for f in files if f.endswith('.py') and f not in exclude_files]
        )
        # Get the relative path to the current directory from the source directory
        relative_path = os.path.relpath(root, src_dir)
        dst_root = os.path.join(dst_dir, relative_path)

        if not os.path.exists(dst_root):
            os.makedirs(dst_root)
        # Process each .py file in the current directory
        print('Processing files....')
        for file in files:
            rst_file = os.path.join(dst_root, file.replace('.py', '.rst'))
            module_path = rst_file.replace(os.sep, '.')[
                len('source.code.') : -len('.rst')
            ]
            print(f'    Create {rst_file}: {module_path}')
            with open(rst_file, 'w') as f:
                title = f'{module_path} module'
                print(title, file=f)
                print('+' * len(title), file=f)
                print('', file=f)
                print(f'.. automodule:: {module_path}', file=f)
                print('   :members:', file=f)
                print('   :undoc-members:', file=f)
                print('   :show-inheritance:', file=f)

    print('**************** Process directories ***********************')
    # Then create the directory structure

    for root, dirs, files in os.walk(dst_dir, topdown=False):
        dirs[:] = sorted([d for d in dirs if d not in exclude_dirs])
        for the_dir in dirs:
            if not the_dir:
                continue
            rst_file = os.path.join(root, f'{the_dir}.rst')
            module_path = root.replace(os.sep, '.')[len('source.code.') :]
            if module_path == '.':
                module_path = ''
            print(
                f'    Create {rst_file} for directory. Module: {module_path}.{the_dir}'
            )
            with open(rst_file, 'w') as f:
                title = f'{module_path}.{the_dir} module'
                print(title, file=f)
                print('%' * len(title), file=f)
                print('', file=f)
                print('.. toctree::', file=f)
                print('  :maxdepth: 2', file=f)
                print('', file=f)
                subdir_path = os.path.join(root, the_dir)
                subdir_files = os.listdir(subdir_path)
                rst_files = sorted(
                    [file for file in subdir_files if file.endswith('.rst')]
                )
                for rst in rst_files:
                    print(f'  {the_dir}/{rst}', file=f)


if __name__ == "__main__":
    src = '../src'
    dst = 'source/code'

    create_rst_structure(src, dst)
